// Generated by CoffeeScript 1.7.1
(function() {
  this.RollerPath.source = "class RollerPath extends PrecisePath\n	@rname = 'Roller brush'\n	@iconUrl = 'static/icons/inverted/rollerBrush.png'\n	@iconAlt = 'roller brush'\n	@rdescription = \"The stroke width is function of the speed: the faster the wider.\"\n\n	@parameters: ()->\n		parameters = super()\n		parameters['Style'].strokeWidth.default = 0 \n		parameters['Style'].strokeColor.defaultCheck = false\n		parameters['Style'].fillColor.defaultCheck = true\n\n		parameters['Parameters'] ?= {}\n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 30\n			max: 300\n			default: 20\n			simplified: 20\n			step: 1\n		parameters['Parameters'].trackWidth =\n			type: 'slider'\n			label: 'Track width'\n			min: 1\n			max: 100\n			default: 20\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n		@path = @addPath()\n		@path.add(@controlPath.firstSegment.point)\n		return\n\n	drawUpdate: (length)->\n\n		point = @controlPath.getPointAt(length)\n		normal = @controlPath.getNormalAt(length).normalize()\n\n		delta = normal.multiply(@data.trackWidth/2)\n		top = point.add(delta)\n		bottom = point.subtract(delta)\n\n		@path.add(top)\n		@path.insert(0, bottom)\n		return\n\n	drawEnd: ()->\n		@path.add(@controlPath.lastSegment.point)\n		@path.closed = true\n		@path.smooth()\n		return";

  this.SpiralPath.source = "class SpiralPath extends PrecisePath\n	@rname = 'Spiral path'\n	@rdescription = \"Spiral path.\"\n\n	@parameters: ()->\n		parameters = super()\n		parameters['Parameters'] ?= {}\n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 10\n			max: 100\n			default: 20\n			simplified: 20\n			step: 1\n		parameters['Parameters'].thickness =\n			type: 'slider'\n			label: 'Thickness'\n			min: 1\n			max: 30\n			default: 5\n			step: 1\n		parameters['Parameters'].rsmooth =\n			type: 'checkbox'\n			label: 'Smooth'\n			default: false\n\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n		@line = @addPath()\n		@spiral = @addPath()\n		return\n\n	drawUpdate: (length)->\n\n		point = @controlPath.getPointAt(length)\n		normal = @controlPath.getNormalAt(length).normalize()\n		tangent = normal.rotate(90)\n\n		@line.add(point)\n\n		@spiral.add(point.add(normal.multiply(@data.thickness)))\n\n		p1 = point.add(normal.multiply(@data.step))\n		@spiral.add(p1)\n\n		p2 = p1.add(tangent.multiply(@data.step-@data.thickness))\n		@spiral.add(p2)\n\n		p3 = p2.add(normal.multiply( -(@data.step-2*@data.thickness) ))\n		@spiral.add(p3)\n\n		p4 = p3.add(tangent.multiply( -(@data.step-3*@data.thickness) ))\n		@spiral.add(p4)\n\n		p5 = p4.add(normal.multiply( @data.thickness ))\n		@spiral.add(p5)\n\n		p6 = p5.add(tangent.multiply( @data.step-4*@data.thickness ))\n		@spiral.add(p6)\n\n		p7 = p6.add(normal.multiply( @data.step-4*@data.thickness ))\n		@spiral.add(p7)\n\n		p8 = p7.add(tangent.multiply( -(@data.step-3*@data.thickness) ))\n		@spiral.add(p8)\n\n		p9 = p8.add(normal.multiply( -(@data.step-2*@data.thickness) ))\n		@spiral.add(p9)\n\n		return\n\n	drawEnd: ()->\n		if @data.rsmooth \n			@spiral.smooth()\n			@line.smooth()\n		return\n";

  this.FuzzyPath.source = "class FuzzyPath extends SpeedPath\n	@rname = 'Fuzzy brush'\n	@rdescription = \"Brush with lines poping out of the path.\"\n\n	@parameters: ()->\n		parameters = super()\n\n		parameters['Parameters'] ?= {} \n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 5\n			max: 100\n			default: 20\n			simplified: 20\n			step: 1\n		parameters['Parameters'].minWidth =\n			type: 'slider'\n			label: 'Min width'\n			min: 1\n			max: 100\n			default: 20\n		parameters['Parameters'].maxWidth =\n			type: 'slider'\n			label: 'Max width'\n			min: 1\n			max: 250\n			default: 200\n		parameters['Parameters'].minSpeed =\n			type: 'slider'\n			label: 'Min speed'\n			min: 1\n			max: 250\n			default: 1\n		parameters['Parameters'].maxSpeed =\n			type: 'slider'\n			label: 'Max speed'\n			min: 1\n			max: 250\n			default: 200\n		parameters['Parameters'].nLines =\n			type: 'slider'\n			label: 'N lines'\n			min: 1\n			max: 5\n			default: 2\n			simplified: 2\n			step: 1\n		parameters['Parameters'].symmetric =\n			type: 'dropdown'\n			label: 'Symmetry'\n			values: ['symmetric', 'top', 'bottom']\n			default: 'symmetric'\n		parameters['Parameters'].speedForWidth =\n			type: 'checkbox'\n			label: 'Speed for width'\n			default: true\n		parameters['Parameters'].speedForLength =\n			type: 'checkbox'\n			label: 'Speed for length'\n			default: false\n		parameters['Parameters'].orthoLines =\n			type: 'checkbox'\n			label: 'Orthogonal lines'\n			default: true\n		parameters['Parameters'].lengthLines =\n			type: 'checkbox'\n			label: 'Length lines'\n			default: true\n\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n\n		if @data.lengthLines\n			@lines = []\n			nLines = @data.nLines\n			if @data.symmetric == 'symmetric' then nLines *= 2\n			for i in [1 .. nLines]\n				@lines.push( @addPath() )\n\n		@lastLength = 0\n\n		return\n\n	drawUpdate: (length)->\n		console.log \"drawUpdate\"\n\n		speed = @speedAt(length)\n\n		addPoint = (length, speed)=>\n			point = @controlPath.getPointAt(length)\n			normal = @controlPath.getNormalAt(length).normalize()\n\n			if @data.speedForWidth\n				width = @data.minWidth + (@data.maxWidth - @data.minWidth) * speed / @constructor.speedMax\n			else\n				width = @data.minWidth\n\n\n			if @data.lengthLines\n				divisor = if @data.nLines>1 then @data.nLines-1 else 1\n				if @data.symmetric == 'symmetric'\n					for line, i in @lines by 2\n						@lines[i+0].add(point.add(normal.multiply(i*width*0.5/divisor)))\n						@lines[i+1].add(point.add(normal.multiply(-i*width*0.5/divisor)))\n				else\n					if @data.symmetric == 'top'\n						line.add(point.add(normal.multiply(i*width/divisor))) for line, i in @lines\n					else if @data.symmetric == 'bottom'\n						line.add(point.add(normal.multiply(-i*width/divisor))) for line, i in @lines\n\n			if @data.orthoLines\n				path = @addPath()\n				delta = normal.multiply(width)\n				switch @data.symmetric\n					when 'symmetric'\n						path.add(point.add(delta))\n						path.add(point.subtract(delta))\n					when 'top'\n						path.add(point.add(delta))\n						path.add(point)\n					when 'bottom'\n						path.add(point.subtract(delta))\n						path.add(point)\n			return\n\n		if not @data.speedForLength\n			addPoint(length, speed)\n		else 	# @data.speedForLength\n			speed = @data.minSpeed + (speed / @constructor.speedMax) * (@data.maxSpeed - @data.minSpeed)\n	\n			stepLength = length-@lastLength\n\n			if stepLength>speed\n				midLength = (length+@lastLength)/2\n				addPoint(midLength, speed)\n				@lastLength = length\n\n		return\n\n	drawEnd: ()->\n		return";

  this.SketchPath.source = "class SketchPath extends PrecisePath\n	@rname = 'Sketch brush'\n	@rdescription = \"Sketch path.\"\n\n	@parameters: ()->\n		parameters = super()\n		parameters['Style'].strokeColor.default = \"rgba(0, 0, 0, 0.25)\"\n		delete parameters['Style'].fillColor\n\n		parameters['Parameters'] ?= {}\n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 5\n			max: 100\n			default: 20\n			simplified: 20\n			step: 1\n		parameters['Parameters'].distance =\n			type: 'slider'\n			label: 'Distance'\n			min: 5\n			max: 250\n			default: 100\n			simplified: 100\n\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(true)\n\n		@points = []\n		return\n\n	drawUpdate: (length)->\n		console.log \"drawUpdate\"\n\n		point = @controlPath.getPointAt(length)\n		normal = @controlPath.getNormalAt(length).normalize()\n\n		point = @projectToRaster(point)\n		@points.push(point)\n		\n		distMax = @data.distance*@data.distance\n\n		for pt in @points\n\n			if point.getDistance(pt, true) < distMax\n				@context.beginPath()\n				@context.moveTo(point.x,point.y)\n				@context.lineTo(pt.x,pt.y)\n				@context.stroke()\n		\n		return\n\n	drawEnd: ()->\n		return";

  this.ShapePath.source = "class ShapePath extends SpeedPath\n	@rname = 'Shape path'\n	@rdescription = \"Places shape along the path.\"\n\n	@parameters: ()->\n		parameters = super()\n\n		parameters['Parameters'] ?= {}\n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 5\n			max: 100\n			default: 20\n			simplified: 20\n			step: 1\n		parameters['Parameters'].minWidth =\n			type: 'slider'\n			label: 'Min width'\n			min: 1\n			max: 250\n			default: 1\n		parameters['Parameters'].maxWidth =\n			type: 'slider'\n			label: 'Max width'\n			min: 1\n			max: 250\n			default: 200\n		parameters['Parameters'].speedForLength =\n			type: 'checkbox'\n			label: 'Speed for length'\n			default: false\n		parameters['Parameters'].minSpeed =\n			type: 'slider'\n			label: 'Min speed'\n			min: 1\n			max: 250\n			default: 1\n		parameters['Parameters'].maxSpeed =\n			type: 'slider'\n			label: 'Max speed'\n			min: 1\n			max: 250\n			default: 200\n\n		return parameters\n\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n		@lastLength = 0\n		return\n\n	drawUpdate: (length)->\n		console.log \"drawUpdate\"\n\n		speed = @speedAt(length)\n\n		addPoint = (length, height, speed)=>\n			point = @controlPath.getPointAt(length)\n			normal = @controlPath.getNormalAt(length)\n\n			width = @data.minWidth + (@data.maxWidth - @data.minWidth) * speed / @constructor.speedMax\n			shape = @addPath(new Path.Rectangle(point.subtract(new Point(width/2, height/2)), new Size(width, height)))\n			shape.rotation = normal.angle\n			return\n\n		if not @data.speedForLength\n			addPoint(length, @data.step, speed)\n		else 	# @data.speedForLength\n			speed = @data.minSpeed + (speed / @constructor.speedMax) * (@data.maxSpeed - @data.minSpeed)\n			\n			stepLength = length-@lastLength\n			if stepLength>speed\n				midLength = (length+@lastLength)/2\n				addPoint(midLength, stepLength, speed)\n				@lastLength = length\n\n		return\n\n	drawEnd: ()->\n		return";

  this.RectangleShape.source = "class RectangleShape extends RShape\n	@Shape = paper.Path.Rectangle\n	@rname = 'Rectangle'\n	# @iconUrl = 'static/icons/inverted/rectangle.png'\n	# @iconAlt = 'rectangle'\n	@rdescription = \"Simple rectangle, square by default (use shift key to change to a rectangle). It can have rounded corners.\"\n\n	@parameters: ()->\n		parameters = super()\n		parameters['Style'] ?= {} \n		parameters['Style'].cornerRadius =\n			type: 'slider'\n			label: 'Corner radius'\n			min: 0\n			max: 100\n			default: 0\n		return parameters\n\n	createShape: ()->\n		@shape = @addPath(new @constructor.Shape(@rectangle, @data.cornerRadius))\n";

  this.EllipseShape.source = "class EllipseShape extends RShape\n	@Shape = paper.Path.Ellipse\n	@rname = 'Ellipse'\n	@iconUrl = 'static/icons/inverted/circle.png'\n	@iconAlt = 'circle'\n	@rdescription = \"Simple ellipse, circle by default (use shift key to change to an ellipse).\"\n";

  this.StarShape.source = "class StarShape extends RShape\n	@Shape = paper.Path.Star\n	@rname = 'Star'\n	@rdescription = \"Star shape.\"\n\n	@parameters: ()->\n		parameters = super()\n		parameters['Style'] ?= {} \n		parameters['Style'].nPoints =\n			type: 'slider'\n			label: 'N points'\n			min: 1\n			max: 100\n			default: 5\n			step: 2\n		parameters['Style'].internalRadius =\n			type: 'slider'\n			label: 'Internal radius'\n			min: -200\n			max: 100\n			default: 37\n		parameters['Style'].rsmooth =\n			type: 'checkbox'\n			label: 'Smooth'\n			default: false\n		return parameters\n\n	createShape: ()->\n		if @data.internalRadius>-100\n			externalRadius = @rectangle.width/2\n			internalRadius = externalRadius*@data.internalRadius/100\n		else\n			internalRadius = @rectangle.width/2\n			externalRadius = internalRadius*100/@data.internalRadius\n		@shape = @addPath(new @constructor.Shape(@rectangle.center, @data.nPoints, externalRadius, internalRadius))\n		if @data.rsmooth then @shape.smooth()\n";

  this.SpiralShape.source = "class SpiralShape extends RShape\n	@Shape = paper.Path.Ellipse\n	@rname = 'Spiral'\n	# @iconUrl = 'static/icons/inverted/spiral.png'\n	# @iconAlt = 'spiral'\n	@rdescription = \"Spiral shape, can have an intern radius, and any number of sides.\"\n\n	@parameters: ()->\n		parameters = super()\n\n		parameters['Parameters'] ?= {} \n		parameters['Parameters'].minRadius =\n			type: 'slider'\n			label: 'Minimum radius'\n			min: 0\n			max: 100\n			default: 0\n			# onSlide: @radiusMinChanged #optional slide event handler\n			# onSlideStop: @radiusMinStopped\n		parameters['Parameters'].nTurns =\n			type: 'slider'\n			label: 'Number of turns'\n			min: 1 \n			max: 50\n			default: 10\n		parameters['Parameters'].nSides =\n			type: 'slider'\n			label: 'Sides'\n			min: 3\n			max: 100\n			default: 50\n\n		return parameters\n\n	createShape: ()->\n		@shape = @addPath()\n\n		hw = @rectangle.width/2\n		hh = @rectangle.height/2\n		c = @rectangle.center\n		angle = 0\n\n		angleStep = 360.0/@data.nSides\n		spiralWidth = hw-hw*@data.minRadius/100.0\n		spiralHeight = hh-hh*@data.minRadius/100.0\n		radiusStepX = (spiralWidth / @data.nTurns) / @data.nSides\n		radiusStepY = (spiralHeight / @data.nTurns) / @data.nSides\n		for i in [0..@data.nTurns-1]\n			for step in [0..@data.nSides-1]\n				@shape.add(new Point(c.x+hw*Math.cos(angle), c.y+hh*Math.sin(angle)))\n				angle += (2.0*Math.PI*angleStep/360.0)\n				hw -= radiusStepX\n				hh -= radiusStepY\n		@shape.add(new Point(c.x+hw*Math.cos(angle), c.y+hh*Math.sin(angle)))";

  this.PrecisePath.source = "class PrecisePath extends RPath 	# must extend PrecisePath, SpeedPath or RShape\n	@rname = 'Precise path'\n	# @iconUrl = '/static/icons/inverted/editCurve.png'\n	# @iconAlt = 'edit curve'\n	@rdescription = \"This path offers precise controls, one can modify points along with their handles and their type.\"\n\n\n	@parameters: ()->\n\n		parameters = super()\n\n		parameters['General'].polygonMode =\n			type: 'checkbox'\n			label: 'Polygon mode'\n			default: g.polygonMode\n			onChange: (value)-> g.polygonMode = value\n\n		parameters['Edit curve'] =			\n			smooth:\n				type: 'checkbox'\n				label: 'Smooth'\n				default: false\n			pointType:\n				type: 'dropdown'\n				label: 'Point type'\n				values: ['smooth', 'corner', 'point']\n				default: 'smooth'\n				onChange: (value)-> item.changeSelectedPoint?(true, value) for item in g.selectedItems()\n			deletePoint: \n				type: 'button'\n				label: 'Delete point'\n				default: ()-> item.deleteSelectedPoint?() for item in g.selectedItems()\n\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n		@path = @addPath()\n		@path.segments = @controlPath.segments\n		@path.selected = false\n		return\n\n	drawUpdate: (length)->\n		@path.segments = @controlPath.segments\n		@path.selected = false\n		return\n\n	drawEnd: ()->\n		@path.segments = @controlPath.segments\n		@path.selected = false\n		return";

  this.Checkpoint.source = "class Checkpoint extends RShape\n	@Shape = paper.Path.Rectangle\n	@rname = 'Checkpoint'\n	# @iconUrl = 'static/icons/inverted/spiral.png'\n	# @iconAlt = 'spiral'\n	@rdescription = \"Checkpoint.\"\n	\n	constructor: (@date=null, @data=null, @pk=null, points=null) ->\n		super(@date, @data, @pk, points)\n		return\n	\n	createShape: ()->\n		@game = g.gameAt(@rectangle.center)\n		if @game?\n			if @game.checkpoints.indexOf(@)<0 then @game.checkpoints.push(@)\n			@data.checkpointNumber ?= @game.checkpoints.indexOf(@)\n\n		@data.strokeColor = 'rgb(150,30,30)'\n		@data.fillColor = null\n		@checkpointRectangle = @rectangle\n		@checkpointRectangle.height = 30\n		@checkpointRectangle.center = @rectangle.center\n		@shape = @addPath(new Path.Rectangle(@checkpointRectangle))\n		@text = @addPath(new PointText(@rectangle.center.add(0,4)))\n		@text.content = if @data.checkpointNumber? then 'Checkpoint ' + @data.checkpointNumber else 'Checkpoint'\n		@text.justification = 'center'\n		\n		return\n\n	contains: (point)->\n		delta = point.subtract(@checkpointRectangle.center)\n		delta.rotation = -@data.rotation\n		return @checkpointRectangle.contains(@checkpointRectangle.center.add(delta))\n\n	remove: ()->\n		@game?.checkpoints.remove(@)\n		super()\n		return";

  g.codeExample = "class NewPath extends PrecisePath\n	@rname = 'New path'\n	@rdescription = \"New tool description.\"\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n		@path = @addPath()\n		return\n\n	drawUpdate: (length)->\n		point = @controlPath.getPointAt(length)\n		@path.add(point)\n		return\n\n	drawEnd: ()->\n		@path.simplify()\n		@path.smooth()\n		return";

}).call(this);

//# sourceMappingURL=pathSources.map
