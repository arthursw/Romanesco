// Generated by CoffeeScript 1.7.1
(function() {
  var init, initPosition, initTools;

  paper.install(window);

  g.hideOthers = function(me) {
    var item, name, _ref, _ref1;
    _ref = g.paths;
    for (name in _ref) {
      item = _ref[name];
      if (item !== me) {
        if ((_ref1 = item.group) != null) {
          _ref1.visible = false;
        }
      }
    }
    g.fastModeOn = true;
  };

  g.showAll = function(me) {
    var item, name, _ref, _ref1;
    if (!g.fastModeOn) {
      return;
    }
    _ref = g.paths;
    for (name in _ref) {
      item = _ref[name];
      if ((_ref1 = item.group) != null) {
        _ref1.visible = true;
      }
    }
    g.fastModeOn = false;
  };

  g.getLimitPaths = function() {
    var limit, limitPathH, limitPathV;
    limit = getLimit();
    limitPathV = null;
    limitPathH = null;
    if (limit.x >= view.bounds.left && limit.x <= view.bounds.right) {
      limitPathV = new Path();
      limitPathV.name = 'limitPathV';
      limitPathV.add(limit.x, view.bounds.top);
      limitPathV.add(limit.x, view.bounds.bottom);
    }
    if (limit.y >= view.bounds.top && limit.y <= view.bounds.bottom) {
      limitPathH = new Path();
      limitPathH.name = 'limitPathH';
      limitPathH.add(view.bounds.left, limit.y);
      limitPathH.add(view.bounds.right, limit.y);
    }
    return {
      vertical: limitPathV,
      horizontal: limitPathH
    };
  };

  g.rectangleOverlapsTwoPlanets = function(rectangle) {
    return g.overlapsTwoPlanets(new Path.Rectangle(rectangle));
  };

  g.pathOverlapsTwoPlanets = function(path) {
    var intersections, limitPathH, limitPathV, limitPaths;
    limitPaths = g.getLimitPaths();
    limitPathV = limitPaths.vertical;
    limitPathH = limitPaths.horizontal;
    if (limitPathV != null) {
      intersections = path.getIntersections(limitPathV);
      limitPathV.remove();
      if (intersections.length > 0) {
        return true;
      }
    }
    if (limitPathH != null) {
      intersections = path.getIntersections(limitPathH);
      limitPathH.remove();
      if (intersections.length > 0) {
        return true;
      }
    }
    return false;
  };

  g.updateGrid = function() {
    var b, debug, i, ijOnPlanet, j, l, limitPathH, limitPathV, limitPaths, n, p, planet, planetText, pos, posOnPlanet, posText, px, py, r, snap, t, x, y;
    g.grid.removeChildren();
    limitPaths = g.getLimitPaths();
    limitPathV = limitPaths.vertical;
    limitPathH = limitPaths.horizontal;
    if (limitPathV != null) {
      limitPathV.strokeColor = "#00FF00";
      limitPathV.strokeWidth = 5;
      g.grid.addChild(limitPathV);
    }
    if (limitPathH != null) {
      limitPathH.strokeColor = "#00FF00";
      limitPathH.strokeWidth = 5;
      g.grid.addChild(limitPathH);
    }
    if (!g.displayGrid) {
      return;
    }
    t = Math.floor(view.bounds.top / g.scale);
    l = Math.floor(view.bounds.left / g.scale);
    b = Math.floor(view.bounds.bottom / g.scale);
    r = Math.floor(view.bounds.right / g.scale);
    pos = getTopLeftCorner();
    planet = projectToPlanet(pos);
    posOnPlanet = projectToPosOnPlanet(pos);
    debug = false;
    snap = g.getSnap();
    if (snap < 15) {
      snap = 15;
    }
    if (debug) {
      snap = 250;
    }
    n = 1;
    i = l;
    j = t;
    while (i < r + 1 || j < b + 1) {
      px = new Path();
      px.name = "grid px";
      py = new Path();
      px.name = "grid py";
      ijOnPlanet = projectToPosOnPlanet(new Point(i * g.scale, j * g.scale));
      if (ijOnPlanet.x === -180) {
        px.strokeColor = "#00FF00";
        px.strokeWidth = 5;
      } else if (n < 4) {
        px.strokeColor = "#666666";
      } else {
        px.strokeColor = "#000000";
        px.strokeWidth = 2;
      }
      if (ijOnPlanet.y === -90) {
        py.strokeColor = "#00FF00";
        py.strokeWidth = 5;
      } else if (n < 4) {
        py.strokeColor = "#666666";
      } else {
        py.strokeColor = "#000000";
        py.strokeWidth = 2;
      }
      px.add(new Point(i * g.scale, view.bounds.top));
      px.add(new Point(i * g.scale, view.bounds.bottom));
      py.add(new Point(view.bounds.left, j * g.scale));
      py.add(new Point(view.bounds.right, j * g.scale));
      g.grid.addChild(px);
      g.grid.addChild(py);
      i += snap / g.scale;
      j += snap / g.scale;
      if (n === 4) {
        n = 0;
      }
      n++;
    }
    if (!debug) {
      return;
    }
    i = l;
    while (i < r + 1) {
      j = t;
      while (j < b + 1) {
        x = i * g.scale;
        y = j * g.scale;
        planetText = new PointText(new Point(x - 10, y - 40));
        planetText.justification = 'right';
        planetText.fillColor = 'black';
        p = projectToPlanet(new Point(i * g.scale, j * g.scale));
        planetText.content = 'px: ' + Math.floor(p.x) + ', py: ' + Math.floor(p.y);
        g.grid.addChild(planetText);
        posText = new PointText(new Point(x - 10, y - 20));
        posText.justification = 'right';
        posText.fillColor = 'black';
        p = projectToPosOnPlanet(new Point(i * g.scale, j * g.scale));
        posText.content = 'x: ' + p.x.toFixed(2) + ', y: ' + p.y.toFixed(2);
        g.grid.addChild(posText);
        j += snap / g.scale;
      }
      i += snap / g.scale;
    }
  };

  this.gameAt = function(point) {
    var div, _i, _len, _ref;
    _ref = g.divs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      div = _ref[_i];
      if (div.getBounds().contains(point) && div.constructor.name === 'RVideoGame') {
        return div;
      }
    }
    return null;
  };

  g.RMoveTo = function(pos) {
    return g.RMoveBy(pos.subtract(view.center));
  };

  g.RMoveBy = function(delta) {
    var area, div, newEntireArea, newView, restrictedAreaShrinked, _i, _j, _len, _len1, _ref, _ref1;
    if (g.restrictedArea != null) {
      if (!g.restrictedArea.contains(view.center)) {
        delta = g.restrictedArea.center.subtract(view.center);
      } else {
        newView = view.bounds.clone();
        newView.center.x += delta.x;
        newView.center.y += delta.y;
        if (!g.restrictedArea.contains(newView)) {
          restrictedAreaShrinked = g.restrictedArea.expand(view.size.multiply(-1));
          if (restrictedAreaShrinked.width < 0) {
            restrictedAreaShrinked.left = restrictedAreaShrinked.right = g.restrictedArea.center.x;
          }
          if (restrictedAreaShrinked.height < 0) {
            restrictedAreaShrinked.top = restrictedAreaShrinked.bottom = g.restrictedArea.center.y;
          }
          newView.center.x = g.clamp(restrictedAreaShrinked.left, newView.center.x, restrictedAreaShrinked.right);
          newView.center.y = g.clamp(restrictedAreaShrinked.top, newView.center.y, restrictedAreaShrinked.bottom);
          delta = newView.center.subtract(view.center);
        }
      }
    }
    project.view.scrollBy(new Point(delta.x, delta.y));
    _ref = g.divs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      div = _ref[_i];
      div.updateTransform();
    }
    newEntireArea = null;
    _ref1 = g.entireAreas;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      area = _ref1[_j];
      if (area.getBounds().contains(project.view.center)) {
        newEntireArea = area;
        break;
      }
    }
    if ((g.entireArea == null) && (newEntireArea != null)) {
      g.entireArea = newEntireArea.getBounds();
    } else if ((g.entireArea != null) && (newEntireArea == null)) {
      g.entireArea = null;
    }
    updateGrid();
    if (newEntireArea != null) {
      load(g.entireArea);
    } else {
      load();
    }
    g.updateRoom();
    g.defferedExecution(g.updateHash, 500);
    g.setControllerValue(g.parameters.location.controller, null, '' + view.center.x.toFixed(2) + ',' + view.center.y.toFixed(2));
  };

  g.updateHash = function() {
    g.moving = true;
    location.hash = '' + view.center.x.toFixed(2) + ',' + view.center.y.toFixed(2);
  };

  window.onhashchange = function(event) {
    var p, pos;
    if (g.moving) {
      g.moving = false;
      return;
    }
    pos = location.hash.substr(1).split(',');
    p = new Point();
    p.x = parseFloat(pos[0]);
    p.y = parseFloat(pos[1]);
    if (!p.x) {
      p.x = 0;
    }
    if (!p.y) {
      p.y = 0;
    }
    g.RMoveTo(p);
  };

  initTools = function() {
    var error, initToolTypeahead, sortStart, sortStop;
    g.toolsJ = $(".tool-list");
    g.favoriteToolsJ = $("#FavoriteTools .tool-list");
    g.allToolsContainerJ = $("#AllTools");
    g.allToolsJ = g.allToolsContainerJ.find(".all-tool-list");
    if (typeof localStorage !== "undefined" && localStorage !== null) {
      try {
        g.favoriteTools = JSON.parse(localStorage.favorites);
      } catch (_error) {
        error = _error;
        console.log(error);
      }
    }
    g.tools = new Object();
    new MoveTool();
    new CarTool();
    new SelectTool();
    new CodeTool();
    new LockTool(RLock);
    new TextTool(RText);
    new MediaTool(RMedia);
    new ScreenshotTool();
    new PathTool(PrecisePath);
    new PathTool(RectangleShape);
    new PathTool(SpiralShape);
    new PathTool(SketchPath);
    new PathTool(SpiralPath);
    new PathTool(ShapePath);
    new PathTool(StarShape);
    new PathTool(EllipseShape);
    new PathTool(RollerPath);
    new PathTool(FuzzyPath);
    new PathTool(Checkpoint);
    initToolTypeahead = function() {
      var promise, tool, toolValues, _i, _len, _ref;
      toolValues = [];
      _ref = g.allToolsJ.children();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tool = _ref[_i];
        toolValues.push({
          value: $(tool).attr("data-type")
        });
      }
      g.typeaheadToolEngine = new Bloodhound({
        name: 'Tools',
        local: toolValues,
        datumTokenizer: Bloodhound.tokenizers.obj.whitespace('value'),
        queryTokenizer: Bloodhound.tokenizers.whitespace
      });
      promise = g.typeaheadToolEngine.initialize();
      g.searchToolInputJ = g.allToolsContainerJ.find("input.search-tool");
      g.searchToolInputJ.keyup(function(event) {
        var query;
        query = g.searchToolInputJ.val();
        if (query === "") {
          g.allToolsJ.children().show();
          return;
        }
        g.allToolsJ.children().hide();
        g.typeaheadToolEngine.get(query, function(suggestions) {
          var suggestion, _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = suggestions.length; _j < _len1; _j++) {
            suggestion = suggestions[_j];
            console.log(suggestion);
            _results.push(g.allToolsJ.children("[data-type='" + suggestion.value + "']").show());
          }
          return _results;
        });
      });
    };
    Dajaxice.draw.getTools(function(result) {
      var script, scripts, _i, _len;
      scripts = JSON.parse(result.tools);
      for (_i = 0, _len = scripts.length; _i < _len; _i++) {
        script = scripts[_i];
        g.runScript(script);
      }
      initToolTypeahead();
    });
    sortStart = function(event, ui) {
      $("#sortable1, #sortable2").addClass("drag-over");
    };
    sortStop = function(event, ui) {
      var li, names, tool, toolValues, _i, _j, _len, _len1, _ref, _ref1;
      $("#sortable1, #sortable2").removeClass("drag-over");
      if (typeof localStorage === "undefined" || localStorage === null) {
        return;
      }
      names = [];
      _ref = g.favoriteToolsJ.children();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        li = _ref[_i];
        names.push($(li).attr("data-type"));
      }
      localStorage.favorites = JSON.stringify(names);
      toolValues = [];
      _ref1 = g.allToolsJ.children();
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        tool = _ref1[_j];
        toolValues.push({
          value: $(tool).attr("data-type")
        });
      }
      g.typeaheadToolEngine.clear();
      g.typeaheadToolEngine.add(toolValues);
    };
    $("#sortable1, #sortable2").sortable({
      connectWith: ".connectedSortable",
      appendTo: g.sidebarJ,
      helper: "clone",
      start: sortStart,
      stop: sortStop
    }).disableSelection();
    return g.tools['Move'].select();
  };

  this.deselectAll = function() {
    var item, _i, _len, _ref;
    _ref = g.selectedItems();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (typeof item.deselect === "function") {
        item.deselect();
      }
    }
    project.activeLayer.selected = false;
  };

  this.mousedown = function(event) {
    var _base;
    switch (event.which) {
      case 2:
        g.tools['Move'].select();
        break;
      case 3:
        if (typeof (_base = g.selectedTool).finishPath === "function") {
          _base.finishPath();
        }
    }
    if (g.selectedTool.name === 'Move') {
      g.selectedTool.beginNative(event);
      return;
    }
    if (event.target.nodeName === "CANVAS") {
      return false;
    }
    g.previousPoint = new Point(event.pageX, event.pageY);
  };

  this.mousemove = function(event) {
    var item, _i, _len, _ref;
    if (g.selectedTool.name === 'Move') {
      g.selectedTool.updateNative(event);
    }
    if (g.previousPoint != null) {
      event.delta = new Point(event.pageX - g.previousPoint.x, event.pageY - g.previousPoint.y);
      g.previousPoint = new Point(event.pageX, event.pageY);
      _ref = g.selectedItems();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        if (typeof item.selectUpdate === "function") {
          item.selectUpdate(event);
        }
      }
    }
    if (g.draggingEditor) {
      g.editorJ.css({
        right: g.windowJ.width() - event.pageX
      });
    }
  };

  this.mouseup = function(event) {
    var item, _i, _len, _ref, _ref1;
    if (g.selectedTool.name === 'Move') {
      g.selectedTool.endNative(event);
    }
    if (event.which === 2) {
      if ((_ref = g.previousTool) != null) {
        _ref.select();
      }
    }
    g.mousemove(event);
    if (g.previousPoint != null) {
      event.delta = new Point(event.pageX - g.previousPoint.x, event.pageY - g.previousPoint.y);
      g.previousPoint = null;
      _ref1 = g.selectedItems();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        item = _ref1[_i];
        if (typeof item.selectEnd === "function") {
          item.selectEnd(event);
        }
      }
    }
    g.draggingEditor = false;
  };

  this.selectedItems = function() {
    var item, items, _i, _len, _ref;
    items = [];
    _ref = project.selectedItems;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if ((item.controller != null) && items.indexOf(item.controller) < 0) {
        items.push(item.controller);
      }
    }
    return items.concat(g.selectedDivs);
  };

  this.sel = function() {
    return g.selectedItems()[0];
  };

  initPosition = function() {
    var box, boxRectangle, boxString, br, controller, folder, folderName, loadEntireArea, planet, pos, site, siteString, tl, _i, _len, _ref, _ref1;
    boxString = g.canvasJ.attr("data-box");
    if (!boxString || boxString.length === 0) {
      window.onhashchange();
      return;
    }
    box = JSON.parse(boxString);
    planet = new Point(box.planetX, box.planetY);
    tl = posOnPlanetToProject(box.box.coordinates[0][0], planet);
    br = posOnPlanetToProject(box.box.coordinates[0][2], planet);
    boxRectangle = new Rectangle(tl, br);
    pos = boxRectangle.center;
    loadEntireArea = g.canvasJ.attr("data-load-entire-area");
    g.RMoveTo(pos);
    if (loadEntireArea) {
      g.entireArea = boxRectangle;
      g.load(boxRectangle);
    }
    siteString = g.canvasJ.attr("data-site");
    site = JSON.parse(siteString);
    if (site.restrictedArea) {
      g.restrictedArea = boxRectangle;
    }
    g.tools['Select'].select();
    if (site.disableToolbar) {
      g.sidebarJ.hide();
    } else {
      g.sidebarJ.find("div.panel.panel-default:not(:last)").hide();
      _ref = g.gui.__folders;
      for (folderName in _ref) {
        folder = _ref[folderName];
        _ref1 = folder.__controllers;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          controller = _ref1[_i];
          if (controller.name !== 'Zoom') {
            folder.remove(controller);
            folder.__controllers.remove(controller);
          }
        }
        if (folder.__controllers.length === 0) {
          g.gui.removeFolder(folderName);
        }
      }
      g.sidebarHandleJ.click();
    }
  };

  this.toggleSidebar = function(show) {
    if (show == null) {
      show = !g.sidebarJ.hasClass("r-hidden");
    }
    if (show) {
      g.sidebarJ.addClass("r-hidden");
      g.editorJ.addClass("r-hidden");
      g.alertsContainer.addClass("r-sidebar-hidden");
      g.sidebarHandleJ.find("span").removeClass("glyphicon-chevron-left").addClass("glyphicon-chevron-right");
    } else {
      g.sidebarJ.removeClass("r-hidden");
      g.editorJ.removeClass("r-hidden");
      g.alertsContainer.removeClass("r-sidebar-hidden");
      g.sidebarHandleJ.find("span").removeClass("glyphicon-chevron-right").addClass("glyphicon-chevron-left");
    }
  };

  init = function() {
    var activeLayer;
    g.windowJ = $(window);
    g.stageJ = $("#stage");
    g.sidebarJ = $("#sidebar");
    g.canvasJ = g.stageJ.find("#canvas");
    g.canvas = g.canvasJ[0];
    g.context = g.canvas.getContext('2d');
    g.templatesJ = $("#templates");
    g.me = null;
    g.dragOffset = {
      x: 0,
      y: 0
    };
    g.draggedDivJ = null;
    g.selectedDivs = [];
    g.selectionGroup = null;
    g.polygonMode = false;
    g.selectionBlue = '#2fa1d6';
    g.updateTimeout = {};
    g.restrictedArea = null;
    g.offset = {
      x: 0,
      y: 0
    };
    g.OSName = "Unknown OS";
    g.currentPaths = {};
    g.loadingBarTimeout = null;
    g.entireArea = null;
    g.entireAreas = [];
    g.animatedItems = [];
    g.cars = {};
    g.fastMode = false;
    g.fastModeOn = false;
    if (navigator.appVersion.indexOf("Win") !== -1) {
      g.OSName = "Windows";
    }
    if (navigator.appVersion.indexOf("Mac") !== -1) {
      g.OSName = "MacOS";
    }
    if (navigator.appVersion.indexOf("X11") !== -1) {
      g.OSName = "UNIX";
    }
    if (navigator.appVersion.indexOf("Linux") !== -1) {
      g.OSName = "Linux";
    }
    paper.setup(canvas);
    activeLayer = project.activeLayer;
    g.carLayer = new Layer();
    activeLayer.activate();
    paper.settings.hitTolerance = 5;
    Point.prototype.toJSON = function() {
      return {
        x: this.x,
        y: this.y
      };
    };
    Point.prototype.exportJSON = function() {
      return JSON.stringify(this.toJSON());
    };
    g.tool = new Tool();
    g.paths = new Object();
    g.sortedPaths = [];
    g.grid = new Group();
    g.grid.name = 'grid group';
    g.defaultColors = ['#d7dddb', '#4f8a83', '#e76278', '#fac699', '#712164'];
    g.alertsContainer = $("#Romanesco_alerts");
    g.alerts = [];
    g.currentAlert = -1;
    g.alertTimeOut = -1;
    g.alertsContainer.find(".btn-up").click(function() {
      return setAlert(g.currentAlert - 1);
    });
    g.alertsContainer.find(".btn-down").click(function() {
      return setAlert(g.currentAlert + 1);
    });
    g.loadedAreas = [];
    g.areasToObjects = new Object();
    g.items = new Object();
    g.locks = [];
    g.divs = [];
    g.sidebarHandleJ = g.sidebarJ.find(".sidebar-handle");
    g.sidebarHandleJ.click(function() {
      g.toggleSidebar();
    });
    g.sidebarJ.find("#buyRomanescoins").click(function() {
      var paypalFormJ;
      g.templatesJ.find('#romanescoinModal').modal('show');
      paypalFormJ = g.templatesJ.find("#paypalForm");
      return paypalFormJ.find("input[name='submit']").click(function() {
        var data;
        data = {
          user: g.me,
          location: {
            x: view.center.x,
            y: view.center.y
          }
        };
        return paypalFormJ.find("input[name='custom']").attr("value", JSON.stringify(data));
      });
    });
    g.sidebarJ.find("#codeSubmit").click(function() {});
    g.sound = new RSound(['/static/sounds/viper.ogg']);
    initOptions();
    initCodeEditor();
    initTools();
    initSocket();
    initPosition();
    g.canvasJ.mousedown(g.mousedown);
    g.stageJ.mousedown(g.mousedown);
    $(window).mousemove(g.mousemove);
    $(window).mouseup(g.mouseup);
    g.stageJ.mousewheel(function(event) {
      g.RMoveBy(new Point(-event.deltaX, -event.deltaY));
    });
  };

  $(document).ready(function() {
    init();
    updateGrid();
    canvasJ.dblclick(function(event) {
      var _base;
      return typeof (_base = g.selectedTool).doubleClick === "function" ? _base.doubleClick(event) : void 0;
    });
    canvasJ.keydown(function(event) {
      if (event.key === 43) {
        return event.preventDefault();
      }
    });
    tool.onMouseDown = function(event) {
      $(document.activeElement).blur();
      return g.selectedTool.begin(event);
    };
    tool.onMouseDrag = function(event) {
      event = g.snap(event);
      return g.selectedTool.update(event);
    };
    tool.onMouseUp = function(event) {
      event = g.snap(event);
      return g.selectedTool.end(event);
    };
    tool.onKeyDown = function(event) {
      var selectedDiv, _i, _len, _ref;
      _ref = g.selectedDivs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        selectedDiv = _ref[_i];
        if (selectedDiv.constructor.name === 'RText') {
          return;
        }
      }
      if (event.key === 'delete') {
        event.preventDefault();
      }
      if (event.key === 'space' && g.selectedTool.name !== 'Move') {
        return g.tools['Move'].select();
      }
    };
    tool.onKeyUp = function(event) {
      var delta, item, _base, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      if ($(document.activeElement).parents(".sidebar").length || $(document.activeElement).is("textarea")) {
        return;
      }
      if ((_ref = event.key) === 'left' || _ref === 'right' || _ref === 'up' || _ref === 'down') {
        delta = event.modifiers.shift ? 50 : event.modifiers.option ? 5 : 1;
      }
      switch (event.key) {
        case 'right':
          _ref1 = g.selectedItems();
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            item = _ref1[_i];
            item.moveBy(new Point(delta, 0));
          }
          break;
        case 'left':
          _ref2 = g.selectedItems();
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            item = _ref2[_j];
            item.moveBy(new Point(-delta, 0));
          }
          break;
        case 'up':
          _ref3 = g.selectedItems();
          for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
            item = _ref3[_k];
            item.moveBy(new Point(0, -delta));
          }
          break;
        case 'down':
          _ref4 = g.selectedItems();
          for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
            item = _ref4[_l];
            item.moveBy(new Point(0, delta));
          }
          break;
        case 'enter':
        case 'escape':
          if (typeof (_base = g.selectedTool).finishPath === "function") {
            _base.finishPath();
          }
          break;
        case 'space':
          if ((_ref5 = g.previousTool) != null) {
            _ref5.select();
          }
          break;
        case 'v':
          g.tools['Select'].select();
          break;
        case 'delete':
        case 'backspace':
          _ref6 = g.selectedItems();
          for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {
            item = _ref6[_m];
            item["delete"]();
          }
      }
      return event.preventDefault();
    };
    view.onFrame = function(event) {
      var car, direction, item, username, _base, _i, _len, _ref, _ref1;
      if (typeof (_base = g.selectedTool).onFrame === "function") {
        _base.onFrame(event);
      }
      _ref = g.animatedItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.onFrame(event);
      }
      _ref1 = g.cars;
      for (username in _ref1) {
        car = _ref1[username];
        direction = new Point(1, 0);
        direction.angle = car.rotation - 90;
        car.position = car.position.add(direction.multiply(car.speed));
        if (Date.now() - car.rLastUpdate > 1000) {
          g.cars[username].remove();
          delete g.cars[username];
        }
      }
    };
    $(".mCustomScrollbar.sidebar-scrollbar").mCustomScrollbar({
      keyboard: false
    });
    return g.windowJ.resize(function(event) {
      updateGrid();
      $(".mCustomScrollbar").mCustomScrollbar("update");
      return view.draw();
    });
  });

  this.logItems = function() {
    var i, item, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    console.log("Selected items:");
    _ref = project.selectedItems;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      if (((_ref1 = item.name) != null ? _ref1.indexOf("debug") : void 0) === 0) {
        continue;
      }
      console.log("------" + i + "------");
      console.log(item.name);
      console.log(item);
      console.log(item.controller);
      console.log((_ref2 = item.controller) != null ? _ref2.pk : void 0);
    }
    console.log("All items:");
    _ref3 = project.activeLayer.children;
    for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
      item = _ref3[i];
      if (((_ref4 = item.name) != null ? _ref4.indexOf("debug") : void 0) === 0) {
        continue;
      }
      console.log("------" + i + "------");
      console.log(item.name);
      console.log(item);
      console.log(item.controller);
      console.log((_ref5 = item.controller) != null ? _ref5.pk : void 0);
    }
    console.log("hiiiiiii");
    return "--- THE END ---";
  };

  this.checkRasters = function() {
    var item, _i, _len, _ref;
    _ref = project.activeLayer.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if ((item.controller != null) && (item.controller.raster == null)) {
        console.log(item.controller);
      }
    }
  };

}).call(this);

//# sourceMappingURL=main.map
