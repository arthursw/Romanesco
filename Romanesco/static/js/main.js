// Generated by CoffeeScript 1.7.1
(function() {
  define(['utils', 'paper', 'coordinateSystems', 'global', 'ajax', 'options', 'socket', 'command', 'item', 'div', 'lock', 'path', 'tools', 'rasterizer', 'editor', 'sound', 'modal', 'jquery', 'jqueryUi', 'mousewheel', 'scrollbar', 'tween', 'typeahead', 'prefix', 'ace'], function(utils, paper) {
    var g, init, initPosition, initTools, initializeAddons;
    g = utils.g();

    /*
    	 * Romanesco documentation #
    
    	Romanesco is an experiment about freedom, creativity and collaboration.
    
    	tododoc
    	tododoc: define RItems
    
    	The source code is divided in files:
    	 - [main.coffee](http://main.html) which is where the initialization
    	 - [path.coffee](http://path.html)
    	 - etc
    
    	Notations:
    	 - override means that the method extends functionnalities of the inherited method (super is called at some point)
    	 - redefine means that it totally replace the method (super is never called)
     */
    initializeAddons = function() {
      var initAddonTypeahead;
      if (g.rasterizerMode != null) {
        g.setTools();
        return;
      }
      initAddonTypeahead = function(addons) {
        g.typeaheadAddonEngine = new Bloodhound({
          name: 'Addons',
          local: addons,
          datumTokenizer: Bloodhound.tokenizers.obj.whitespace('value'),
          queryTokenizer: Bloodhound.tokenizers.whitespace
        });
        g.typeaheadAddonEngine.initialize();
        g.codeEditor.initializeAddonInput();
      };
      g.allAddonsJ = g.allToolsContainerJ.find(".all-tool-list");
      Dajaxice.draw.getAddons(function(result) {
        var addon, addonValues, addons, i, _i, _len;
        addons = JSON.parse(result.addons);
        addonValues = [];
        for (i = _i = 0, _len = addons.length; _i < _len; i = ++_i) {
          addon = addons[i];
          g.createButton(addon.name, addon.iconURL, g.allAddonsJ);
          addonValues.push({
            value: addon.name,
            iconURL: addon.iconURL
          });
        }
        initAddonTypeahead(addonValues);
      });
      g.searchAddonInputJ = $("#AllTools").find("input.search-tool");
      g.searchAddonInputJ.keyup(function(event) {
        var query;
        query = g.searchAddonInputJ.val();
        if (query === "") {
          g.allAddonsJ.children().show();
          return;
        }
        g.allAddonsJ.children().hide();
        g.typeaheadAddonEngine.get(query, function(suggestions) {
          var suggestion, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = suggestions.length; _i < _len; _i++) {
            suggestion = suggestions[_i];
            _results.push(g.allAddonsJ.children("[data-type='" + suggestion.value + "']").show());
          }
          return _results;
        });
      });
    };
    initTools = function() {
      var defaultFavoriteTools, error, pathClass, sortStart, sortStop, sortableArgs, _i, _len, _ref;
      if (g.rasterizerMode != null) {
        g.setTools();
        return;
      }
      g.toolsJ = $(".tool-list");
      g.favoriteToolsJ = $("#FavoriteTools .tool-list");
      g.allToolsContainerJ = $("#AllTools");
      g.allToolsJ = g.allToolsContainerJ.find(".all-tool-list");
      g.favoriteTools = [];
      if (typeof localStorage !== "undefined" && localStorage !== null) {
        try {
          g.favoriteTools = JSON.parse(localStorage.favorites);
        } catch (_error) {
          error = _error;
          console.log(error);
        }
      }
      defaultFavoriteTools = [g.PrecisePath, g.ThicknessPath, g.Meander, g.GeometricLines, g.RectangleShape, g.EllipseShape, g.StarShape, g.SpiralShape];
      while (g.favoriteTools.length < 8) {
        g.pushIfAbsent(g.favoriteTools, defaultFavoriteTools.pop().rname);
      }
      g.tools = {};
      new g.MoveTool();
      new g.CarTool();
      new g.SelectTool();
      new g.CodeTool();
      new g.LockTool(g.RLock);
      new g.TextTool(g.RText);
      new g.MediaTool(g.RMedia);
      new g.ScreenshotTool();
      _ref = g.pathClasses;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pathClass = _ref[_i];
        new g.PathTool(pathClass);
      }
      initializeAddons();
      sortStart = function(event, ui) {
        $("#sortable1, #sortable2").addClass("drag-over");
      };
      sortStop = function(event, ui) {
        var li, names, tool, toolValues, _j, _k, _len1, _len2, _ref1, _ref2;
        $("#sortable1, #sortable2").removeClass("drag-over");
        if (typeof localStorage === "undefined" || localStorage === null) {
          return;
        }
        names = [];
        _ref1 = g.favoriteToolsJ.children();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          li = _ref1[_j];
          names.push($(li).attr("data-type"));
        }
        localStorage.favorites = JSON.stringify(names);
        toolValues = [];
        _ref2 = g.allToolsJ.children();
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          tool = _ref2[_k];
          toolValues.push({
            value: $(tool).attr("data-type")
          });
        }
        g.typeaheadToolEngine.clear();
        g.typeaheadToolEngine.add(toolValues);
      };
      sortableArgs = {
        connectWith: ".connectedSortable",
        appendTo: g.sidebarJ,
        helper: "clone",
        start: sortStart,
        stop: sortStop,
        delay: 250
      };
      $("#sortable1, #sortable2").sortable(sortableArgs).disableSelection();
      g.tools['Move'].select();
      g.wacomPlugin = document.getElementById('wacomPlugin');
      if (g.wacomPlugin != null) {
        g.wacomPenAPI = wacomPlugin.penAPI;
        g.wacomTouchAPI = wacomPlugin.touchAPI;
        g.wacomPointerType = {
          0: 'Mouse',
          1: 'Pen',
          2: 'Puck',
          3: 'Eraser'
        };
      }
    };
    initPosition = function() {
      var box, boxRectangle, boxString, br, controller, folder, folderName, loadEntireArea, planet, pos, site, siteString, tl, _i, _len, _ref, _ref1;
      if (g.rasterizerMode) {
        return;
      }
      boxString = g.canvasJ.attr("data-box");
      if (!boxString || boxString.length === 0) {
        window.onhashchange();
        return;
      }
      box = JSON.parse(boxString);
      planet = new Point(box.planetX, box.planetY);
      tl = g.posOnPlanetToProject(box.box.coordinates[0][0], planet);
      br = g.posOnPlanetToProject(box.box.coordinates[0][2], planet);
      boxRectangle = new Rectangle(tl, br);
      pos = boxRectangle.center;
      g.RMoveTo(pos);
      loadEntireArea = g.canvasJ.attr("data-load-entire-area");
      if (loadEntireArea) {
        g.entireArea = boxRectangle;
        g.load(boxRectangle);
      }
      siteString = g.canvasJ.attr("data-site");
      site = JSON.parse(siteString);
      if (site.restrictedArea) {
        g.restrictedArea = boxRectangle;
      }
      g.tools['Select'].select();
      if (site.disableToolbar) {
        g.sidebarJ.hide();
      } else {
        g.sidebarJ.find("div.panel.panel-default:not(:last)").hide();
        _ref = g.gui.__folders;
        for (folderName in _ref) {
          folder = _ref[folderName];
          _ref1 = folder.__controllers;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            controller = _ref1[_i];
            if (controller.name !== 'Zoom') {
              folder.remove(controller);
              folder.__controllers.remove(controller);
            }
          }
          if (folder.__controllers.length === 0) {
            g.gui.removeFolder(folderName);
          }
        }
        g.sidebarHandleJ.click();
      }
    };
    paper.install(window);
    init = function() {
      var hueRange, i, minHue, step, _i;
      g.romanescoURL = 'http://localhost:8000/';
      g.stageJ = $("#stage");
      g.sidebarJ = $("#sidebar");
      g.canvasJ = g.stageJ.find("#canvas");
      g.canvas = g.canvasJ[0];
      g.canvas.width = window.innerWidth;
      g.canvas.height = window.innerHeight;
      g.context = g.canvas.getContext('2d');
      g.templatesJ = $("#templates");
      g.me = null;
      g.selectionLayer = null;
      g.polygonMode = false;
      g.selectionBlue = '#2fa1d6';
      g.updateTimeout = {};
      g.requestedCallbacks = {};
      g.restrictedArea = null;
      g.OSName = "Unknown OS";
      g.currentPaths = {};
      g.loadingBarTimeout = null;
      g.entireArea = null;
      g.entireAreas = [];
      g.loadedAreas = [];
      g.paths = new Object();
      g.items = new Object();
      g.locks = [];
      g.divs = [];
      g.sortedPaths = [];
      g.sortedDivs = [];
      g.animatedItems = [];
      g.cars = {};
      g.alerts = null;
      g.scale = 1000.0;
      g.previousPoint = null;
      g.draggingEditor = false;
      g.areasToUpdate = {};
      g.rastersToUpload = [];
      g.areasToRasterize = [];
      g.isUpdatingRasters = false;
      g.viewUpdated = false;
      g.currentDiv = null;
      g.areasToUpdateRectangles = {};
      g.catchErrors = false;
      g.previousMousePosition = null;
      g.initialMousePosition = null;
      g.previousViewPosition = null;
      g.backgroundRectangle = null;
      g.limitPathV = null;
      g.limitPathH = null;
      g.selectedItems = [];
      g.ignoreSockets = false;
      g.itemListsJ = $("#RItems .layers");
      g.pathList = g.itemListsJ.find(".rPath-list");
      g.pathList.sortable({
        stop: g.zIndexSortStop,
        delay: 250
      });
      g.pathList.disableSelection();
      g.divList = g.itemListsJ.find(".rDiv-list");
      g.divList.sortable({
        stop: g.zIndexSortStop,
        delay: 250
      });
      g.divList.disableSelection();
      g.itemListsJ.find('.title').click(function(event) {
        $(this).parent().toggleClass('closed');
      });
      g.commandManager = new g.CommandManager();
      Dajaxice.setup({
        'default_exception_callback': function(error) {
          console.log('Dajaxice error!');
          g.romanesco_alert("Connection error", "error");
        }
      });
      if (navigator.appVersion.indexOf("Win") !== -1) {
        g.OSName = "Windows";
      }
      if (navigator.appVersion.indexOf("Mac") !== -1) {
        g.OSName = "MacOS";
      }
      if (navigator.appVersion.indexOf("X11") !== -1) {
        g.OSName = "UNIX";
      }
      if (navigator.appVersion.indexOf("Linux") !== -1) {
        g.OSName = "Linux";
      }
      paper.setup(g.canvas);
      g.project = project;
      g.mainLayer = project.activeLayer;
      g.debugLayer = new Layer();
      g.debugLayer.name = 'debug layer';
      g.carLayer = new Layer();
      g.carLayer.name = 'car layer';
      g.lockLayer = new Layer();
      g.lockLayer.name = 'lock layer';
      g.selectionLayer = new Layer();
      g.selectionLayer.name = 'selection layer';
      g.areasToUpdateLayer = new Layer();
      g.areasToUpdateLayer.name = 'areasToUpdateLayer';
      g.mainLayer.activate();
      paper.settings.hitTolerance = 5;
      g.grid = new Group();
      g.grid.name = 'grid group';
      view.zoom = 1;
      g.previousViewPosition = view.center;
      if (g.rasterizer == null) {
        g.rasterizer = new g.Rasterizer();
      }
      Point.prototype.toJSON = function() {
        return {
          x: this.x,
          y: this.y
        };
      };
      Point.prototype.exportJSON = function() {
        return JSON.stringify(this.toJSON());
      };
      Rectangle.prototype.toJSON = function() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height
        };
      };
      Rectangle.prototype.exportJSON = function() {
        return JSON.stringify(this.toJSON());
      };
      Rectangle.prototype.translate = function(point) {
        return new Rectangle(this.x + point.x, this.y + point.y, this.width, this.height);
      };
      Rectangle.prototype.moveSide = function(sideName, destination) {
        switch (sideName) {
          case 'left':
            this.x = destination;
            break;
          case 'right':
            this.x = destination - this.width;
            break;
          case 'top':
            this.y = destination;
            break;
          case 'bottom':
            this.y = destination - this.height;
        }
      };
      Rectangle.prototype.moveCorner = function(cornerName, destination) {
        switch (cornerName) {
          case 'topLeft':
            this.x = destination.x;
            this.y = destination.y;
            break;
          case 'topRight':
            this.x = destination.x - this.width;
            this.y = destination.y;
            break;
          case 'bottomRight':
            this.x = destination.x - this.width;
            this.y = destination.y - this.height;
            break;
          case 'bottomLeft':
            this.x = destination.x;
            this.y = destination.y - this.height;
        }
      };
      Rectangle.prototype.moveCenter = function(destination) {
        this.x = destination.x - this.width * 0.5;
        this.y = destination.y - this.height * 0.5;
      };
      Event.prototype.toJSON = function() {
        var event;
        event = {
          modifiers: this.modifiers,
          event: {
            which: this.event.which
          },
          point: this.point,
          downPoint: this.downPoint,
          delta: this.delta,
          middlePoint: this.middlePoint,
          type: this.type,
          count: this.count
        };
        return event;
      };
      Event.prototype.fromJSON = function(event) {
        if (event.point != null) {
          event.point = new Point(event.point);
        }
        if (event.downPoint != null) {
          event.downPoint = new Point(event.downPoint);
        }
        if (event.delta != null) {
          event.delta = new Point(event.delta);
        }
        if (event.middlePoint != null) {
          event.middlePoint = new Point(event.middlePoint);
        }
        return event;
      };
      g.defaultColors = [];
      hueRange = g.random(10, 180);
      minHue = g.random(0, 360 - hueRange);
      step = hueRange / 10;
      for (i = _i = 0; _i <= 10; i = ++_i) {
        g.defaultColors.push(Color.HSL(minHue + i * step, g.random(0.3, 0.9), g.random(0.5, 0.7)).toCSS());
      }
      g.alertsContainer = $("#Romanesco_alerts");
      g.alerts = [];
      g.currentAlert = -1;
      g.alertTimeOut = -1;
      g.alertsContainer.find(".btn-up").click(function() {
        return showAlert(g.currentAlert - 1);
      });
      g.alertsContainer.find(".btn-down").click(function() {
        return showAlert(g.currentAlert + 1);
      });
      g.sidebarHandleJ = g.sidebarJ.find(".sidebar-handle");
      g.sidebarHandleJ.click(function() {
        g.toggleSidebar();
      });
      $(".mCustomScrollbar.sidebar-scrollbar").mCustomScrollbar({
        keyboard: false
      });
      g.sound = new g.RSound(['/static/sounds/viper.ogg']);
      $.ajax({
        url: g.romanescoURL + "static/coffee/path.coffee"
      }).done(function(data) {
        var classMap, expression, expressions, lines, pathClass, source, _j, _k, _len, _len1, _ref, _ref1;
        lines = data.split(/\n/);
        expressions = CoffeeScript.nodes(data).expressions;
        classMap = {};
        _ref = g.pathClasses;
        for (_j = 0, _len = _ref.length; _j < _len; _j++) {
          pathClass = _ref[_j];
          classMap[pathClass.name] = pathClass;
        }
        for (_k = 0, _len1 = expressions.length; _k < _len1; _k++) {
          expression = expressions[_k];
          source = lines.slice(expression.locationData.first_line, +expression.locationData.last_line + 1 || 9e9).join("\n");
          if ((_ref1 = classMap[expression.variable.base.value]) != null) {
            _ref1.source = source;
          }
        }
      });
      g.initializeGlobalParameters();
      g.initParameters();
      g.initCodeEditor();
      g.initSocket();
      initTools();
      initPosition();
      g.updateGrid();
    };
    $(document).ready(function() {
      var focusIsOnCanvas, mousedown, mousemove, mouseup;
      init();
      if (g.rasterizerMode) {
        return;
      }
      g.canvasJ.dblclick(function(event) {
        var _base;
        return typeof (_base = g.selectedTool).doubleClick === "function" ? _base.doubleClick(event) : void 0;
      });
      g.canvasJ.keydown(function(event) {
        if (event.key === 46) {
          event.preventDefault();
          return false;
        }
      });
      g.tool = new Tool();
      focusIsOnCanvas = function() {
        var activeElementIsOnParameterBar, activeElementIsOnSidebar, activeElementIsTextarea;
        activeElementIsOnSidebar = $(document.activeElement).parents(".sidebar").length > 0;
        activeElementIsTextarea = $(document.activeElement).is("textarea");
        activeElementIsOnParameterBar = $(document.activeElement).parents(".dat-gui").length;
        return !activeElementIsOnSidebar && !activeElementIsTextarea && !activeElementIsOnParameterBar;
      };
      g.tool.onMouseDown = function(event) {
        var _ref;
        if ((_ref = g.wacomPenAPI) != null ? _ref.isEraser : void 0) {
          g.tool.onKeyUp({
            key: 'delete'
          });
          return;
        }
        $(document.activeElement).blur();
        g.selectedTool.begin(event);
      };
      g.tool.onMouseDrag = function(event) {
        var _ref;
        if ((_ref = g.wacomPenAPI) != null ? _ref.isEraser : void 0) {
          return;
        }
        if (g.currentDiv != null) {
          return;
        }
        g.selectedTool.update(event);
      };
      g.tool.onMouseUp = function(event) {
        var _ref;
        if ((_ref = g.wacomPenAPI) != null ? _ref.isEraser : void 0) {
          return;
        }
        if (g.currentDiv != null) {
          return;
        }
        g.selectedTool.end(event);
      };
      g.tool.onKeyDown = function(event) {
        if (!focusIsOnCanvas()) {
          return;
        }
        if (event.key === 'delete') {
          event.preventDefault();
          return false;
        }
        if (event.key === 'space' && g.selectedTool.name !== 'Move') {
          g.tools['Move'].select();
        }
      };
      g.tool.onKeyUp = function(event) {
        var delta, item, selectedItems, _base, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        if (!focusIsOnCanvas()) {
          return;
        }
        if ((_ref = event.key) === 'left' || _ref === 'right' || _ref === 'up' || _ref === 'down') {
          delta = event.modifiers.shift ? 50 : event.modifiers.option ? 5 : 1;
        }
        switch (event.key) {
          case 'right':
            _ref1 = g.selectedItems;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              item = _ref1[_i];
              item.moveBy(new Point(delta, 0), true);
            }
            break;
          case 'left':
            _ref2 = g.selectedItems;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              item = _ref2[_j];
              item.moveBy(new Point(-delta, 0), true);
            }
            break;
          case 'up':
            _ref3 = g.selectedItems;
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              item = _ref3[_k];
              item.moveBy(new Point(0, -delta), true);
            }
            break;
          case 'down':
            _ref4 = g.selectedItems;
            for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
              item = _ref4[_l];
              item.moveBy(new Point(0, delta), true);
            }
            break;
          case 'enter':
          case 'escape':
            if (typeof (_base = g.selectedTool).finish === "function") {
              _base.finish();
            }
            break;
          case 'space':
            if ((_ref5 = g.previousTool) != null) {
              _ref5.select();
            }
            break;
          case 'v':
            g.tools['Select'].select();
            break;
          case 'delete':
          case 'backspace':
            selectedItems = g.selectedItems.slice();
            for (_m = 0, _len4 = selectedItems.length; _m < _len4; _m++) {
              item = selectedItems[_m];
              if (((_ref6 = item.selectionState) != null ? _ref6.segment : void 0) != null) {
                item.deletePointCommand();
              } else {
                item.deleteCommand();
              }
            }
        }
        event.preventDefault();
      };
      view.onFrame = function(event) {
        var car, direction, item, username, _base, _i, _len, _ref, _ref1;
        TWEEN.update(event.time);
        if (typeof (_base = g.selectedTool).onFrame === "function") {
          _base.onFrame(event);
        }
        _ref = g.animatedItems;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          item.onFrame(event);
        }
        _ref1 = g.cars;
        for (username in _ref1) {
          car = _ref1[username];
          direction = new Point(1, 0);
          direction.angle = car.rotation - 90;
          car.position = car.position.add(direction.multiply(car.speed));
          if (Date.now() - car.rLastUpdate > 1000) {
            g.cars[username].remove();
            delete g.cars[username];
          }
        }
      };
      $(window).resize(function(event) {
        g.updateGrid();
        $(".mCustomScrollbar").mCustomScrollbar("update");
        view.update();
      });
      mousedown = function(event) {
        var _base;
        switch (event.which) {
          case 2:
            g.tools['Move'].select();
            break;
          case 3:
            if (typeof (_base = g.selectedTool).finish === "function") {
              _base.finish();
            }
        }
        if (g.selectedTool.name === 'Move') {
          g.selectedTool.beginNative(event);
          return;
        }
        g.initialMousePosition = g.jEventToPoint(event);
        g.previousMousePosition = g.initialMousePosition.clone();
      };
      mousemove = function(event) {
        var paperEvent, _base;
        if (g.selectedTool.name === 'Move' && g.selectedTool.dragging) {
          g.selectedTool.updateNative(event);
          return;
        }
        g.codeEditor.mousemove(event);
        if (g.currentDiv != null) {
          paperEvent = g.jEventToPaperEvent(event, g.previousMousePosition, g.initialMousePosition, 'mousemove');
          if (typeof (_base = g.currentDiv).updateSelect === "function") {
            _base.updateSelect(paperEvent);
          }
          g.previousMousePosition = paperEvent.point;
        }
      };
      mouseup = function(event) {
        var paperEvent, _base, _ref;
        if (g.selectedTool.name === 'Move') {
          g.selectedTool.endNative(event);
          return;
        }
        if (event.which === 2) {
          if ((_ref = g.previousTool) != null) {
            _ref.select();
          }
        }
        if (g.currentDiv != null) {
          paperEvent = g.jEventToPaperEvent(event, g.previousMousePosition, g.initialMousePosition, 'mouseup');
          if (typeof (_base = g.currentDiv).endSelect === "function") {
            _base.endSelect(paperEvent);
          }
          g.previousMousePosition = paperEvent.point;
        }
        g.codeEditor.mouseup(event);
      };
      g.canvasJ.mousedown(mousedown);
      g.stageJ.mousedown(mousedown);
      $(window).mousemove(mousemove);
      $(window).mouseup(mouseup);
      g.stageJ.mousewheel(function(event) {
        g.RMoveBy(new Point(-event.deltaX, event.deltaY));
      });
    });
  });

}).call(this);

//# sourceMappingURL=main.map
