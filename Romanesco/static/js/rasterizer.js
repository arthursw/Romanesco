// Generated by CoffeeScript 1.7.1
(function() {
  var Rasterizer;

  Rasterizer = (function() {
    function Rasterizer() {
      var areasToLoad, b, bounds, l, r, scale, t, x, y, zoom, _i, _j;
      this.drawAllMode = false;
      this.rasters = {};
      bounds = view.bounds;
      zoom = this.quantizeZoom(1.0 / view.zoom);
      scale = zoom * g.scale;
      t = g.roundToLowerMultiple(bounds.top, scale);
      l = g.roundToLowerMultiple(bounds.left, scale);
      b = g.roundToLowerMultiple(bounds.bottom, scale);
      r = g.roundToLowerMultiple(bounds.right, scale);
      areasToLoad = [];
      for (x = _i = l; scale > 0 ? _i <= r : _i >= r; x = _i += scale) {
        for (y = _j = t; scale > 0 ? _j <= b : _j >= b; y = _j += scale) {
          this.createRaster(x, y, zoom);
        }
      }
      this.moveRasters();
      return;
    }

    Rasterizer.prototype.quantizeZoom = function(zoom) {
      if (zoom < 5) {
        zoom = 1;
      } else if (zoom < 25) {
        zoom = 5;
      } else {
        zoom = 25;
      }
      return zoom;
    };

    Rasterizer.prototype.createRaster = function(x, y, zoom) {
      var raster, _base, _ref;
      if (((_ref = this.rasters[x]) != null ? _ref[y] : void 0) != null) {
        return;
      }
      raster = {};
      raster.canvasJ = $('<canvas hidpi="off" width="1000" height="1000">');
      raster.canvas = raster.canvasJ[0];
      raster.zoom = zoom;
      raster.context = raster.canvas.getContext('2d');
      raster.image = new Image();
      raster.image.onload = function() {
        raster.context.drawImage(raster.image, 0, 0);
      };
      if ((_base = this.rasters)[x] == null) {
        _base[x] = {};
      }
      this.rasters[x][y] = raster;
    };

    Rasterizer.prototype.getRasterBounds = function(x, y) {
      var size;
      size = this.rasters[x][y].zoom * 1000;
      return new Rectangle(x, y, size, size);
    };

    Rasterizer.prototype.removeRaster = function(raster, x, y) {
      raster.canvasJ.remove();
      delete this.rasters[x][y];
      if (g.isEmpty(this.rasters[x])) {
        delete this.rasters[x];
      }
    };

    Rasterizer.prototype.unload = function(limit) {
      var raster, rasterColumn, rectangle, x, y, _ref;
      _ref = this.rasters;
      for (x in _ref) {
        rasterColumn = _ref[x];
        for (y in rasterColumn) {
          raster = rasterColumn[y];
          rectangle = this.getRasterBounds(x, y);
          if (!limit.contains(rectangle)) {
            this.removeRaster(raster, x, y);
          }
        }
      }
    };

    Rasterizer.prototype.load = function(rasters, zoom) {
      var r, x, y, _i, _len;
      zoom = this.quantizeZoom(zoom);
      for (_i = 0, _len = rasters.length; _i < _len; _i++) {
        r = rasters[_i];
        x = r.position.x;
        y = r.position.y;
        this.createRaster(x, y, zoom);
        this.rasters[x][y][zoom].image.src = g.romanescoURL + r.url;
      }
      this.moveRasters();
    };

    Rasterizer.prototype.moveRasters = function() {
      var css, raster, rasterColumn, viewPos, x, y, zoom, _ref;
      _ref = this.rasters;
      for (x in _ref) {
        rasterColumn = _ref[x];
        for (y in rasterColumn) {
          raster = rasterColumn[y];
          viewPos = view.projectToView(new Point(x, y));
          if (view.zoom === 1) {
            raster.canvasJ.css({
              'left': viewPos.x,
              'top': viewPos.y,
              'transform': 'none'
            });
          } else {
            zoom = view.zoom * raster.zoom;
            css = 'translate(' + viewPos.x + 'px,' + viewPos.y + 'px)';
            css += ' scale(' + zoom + ')';
            raster.canvasJ.css({
              'transform': css,
              'top': 0,
              'left': 0
            });
          }
        }
      }
    };

    Rasterizer.prototype.drawImageInRaster = function(raster, x, y, zoom) {
      var destinationRectangle, imageData, intersection, rectangle, _ref;
      if (((_ref = this.rasters[x]) != null ? _ref[y] : void 0) == null) {
        return;
      }
      rectangle = this.getRasterBounds(x, y);
      intersection = raster.bounds.intersect(rectangle);
      imageData = raster.getImageData(new Rectangle(intersection.x - bounds.x, intersection.y - bounds.y, intersection.width, intersection.height));
      destinationRectangle = new Rectangle(intersection.topLeft.subtract(rectangle.topLeft).divide(zoom), intersection.size.divide(zoom));
      this.rasters[x][y].context.drawImage(imageData, destinationRectangle);
    };

    Rasterizer.prototype.drawRaster = function(raster) {
      var b, bounds, l, r, scale, t, x, y, zoom, _i, _j;
      bounds = raster.bounds;
      zoom = this.quantizeZoom(1.0 / view.zoom);
      scale = zoom * g.scale;
      t = g.roundToLowerMultiple(bounds.top, scale);
      l = g.roundToLowerMultiple(bounds.left, scale);
      b = g.roundToLowerMultiple(bounds.bottom, scale);
      r = g.roundToLowerMultiple(bounds.right, scale);
      for (x = _i = l; scale > 0 ? _i <= r : _i >= r; x = _i += scale) {
        for (y = _j = t; scale > 0 ? _j <= b : _j >= b; y = _j += scale) {
          this.drawImageInRaster(raster, x, y, zoom);
        }
      }
    };

    Rasterizer.prototype.drawView = function(bounds) {
      var b, imageData, intersection, l, r, rectangle, scale, t, x, y, _i, _j, _ref;
      if (bounds == null) {
        bounds = view.bounds;
      }
      bounds = g.projectToViewRectangle(bounds);
      scale = g.scale;
      t = g.roundToLowerMultiple(bounds.top, scale);
      l = g.roundToLowerMultiple(bounds.left, scale);
      b = g.roundToLowerMultiple(bounds.bottom, scale);
      r = g.roundToLowerMultiple(bounds.right, scale);
      for (x = _i = l; scale > 0 ? _i <= r : _i >= r; x = _i += scale) {
        for (y = _j = t; scale > 0 ? _j <= b : _j >= b; y = _j += scale) {
          if (((_ref = g.rasters[x]) != null ? _ref[y] : void 0) == null) {
            console.log('Error: missing raster: ' + x(', ' + y));
          }
          rectangle = g.projectToViewRectangle(this.getRasterBounds(x, y));
          intersection = bounds.intersect(rectangle);
          imageData = g.context.getImageData(intersection.x, intersection.y, intersection.width, intersection.height);
          g.rasters[x][y].context.drawImage(imageData, intersection.x - rectangle.x, intersection.y - rectangle.y, intersection.width, intersection.height);
        }
      }
    };

    Rasterizer.prototype.drawAll = function() {
      var item, pk, raster, rasterColumn, x, y, _ref, _ref1;
      this.drawAllMode = true;
      _ref = g.items;
      for (pk in _ref) {
        item = _ref[pk];
        if (typeof item.draw === "function") {
          item.draw();
        }
        item.group.visible = true;
      }
      _ref1 = this.rasters;
      for (x in _ref1) {
        rasterColumn = _ref1[x];
        for (y in rasterColumn) {
          raster = rasterColumn[y];
          this.removeRaster(raster, x, y);
        }
      }
    };

    Rasterizer.prototype.rasterize = function(items, excludeItems) {
      var bounds, item, p, pk, viewPosition, viewSize, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      if (excludeItems == null) {
        excludeItems = false;
      }
      if (this.drawAllMode) {
        return;
      }
      if (RItem.prototype.isPrototypeOf(items)) {
        items = [items];
      }
      bounds = items.first().getDrawingBounds();
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        bounds = bounds.unite(item.getDrawingBounds());
      }
      if (bounds.area > 1.5 * view.bounds.area) {
        this.drawAll();
        return;
      }
      _ref = g.path;
      for (pk in _ref) {
        p = _ref[pk];
        if ((p.drawing == null) && p.getDrawingBounds().intersects(bounds)) {
          p.draw();
        }
      }
      _ref1 = g.path;
      for (pk in _ref1) {
        p = _ref1[pk];
        p.group.visible = true;
      }
      if (excludeItems) {
        for (_j = 0, _len1 = items.length; _j < _len1; _j++) {
          item = items[_j];
          item.group.visible = false;
        }
      }
      viewSize = view.viewSize;
      viewPosition = view.center;
      view.viewSize = bounds.size;
      view.center = bounds.center;
      view.update();
      this.drawView(bounds);
      view.center = viewPosition;
      view.viewSize = viewSize;
      _ref2 = g.paths;
      for (pk in _ref2) {
        p = _ref2[pk];
        p.group.visible = false;
      }
      if (excludeItems) {
        for (_k = 0, _len2 = items.length; _k < _len2; _k++) {
          item = items[_k];
          item.group.visible = true;
        }
      }
    };

    Rasterizer.prototype.drawItem = function(item) {
      var raster;
      if (this.drawAllMode) {
        return;
      }
      if (item.getDrawingBounds().area > 1.5 * view.bounds.area) {
        this.drawAll();
        return;
      }
      raster = item.drawing.rasterize();
      this.drawRaster(raster);
      raster.remove();
      item.group.visible = false;
    };

    return Rasterizer;

  })();

  this.Rasterizer = Rasterizer;

}).call(this);

//# sourceMappingURL=rasterizer.map
