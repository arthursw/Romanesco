// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['utils', 'jquery', 'paper'], function(utils) {
    var CanvasTileRasterizer, FastCanvasTileRasterizer, PaperTileRasterizer, Rasterizer, SimpleRasterizer, TileRasterizer, g;
    g = utils.g();
    Rasterizer = (function() {
      Rasterizer.TYPE = 'default';

      Rasterizer.MAX_AREA = 1.5;

      Rasterizer.UNION_RATIO = 1.5;

      function Rasterizer() {
        g.rasterizers[this.constructor.TYPE] = this;
        return;
      }

      Rasterizer.prototype.quantizeBounds = function(bounds, scale) {
        var quantizedBounds;
        if (bounds == null) {
          bounds = view.bounds;
        }
        if (scale == null) {
          scale = g.scale;
        }
        quantizedBounds = {
          t: g.floorToMultiple(bounds.top, scale),
          l: g.floorToMultiple(bounds.left, scale),
          b: g.floorToMultiple(bounds.bottom, scale),
          r: g.floorToMultiple(bounds.right, scale)
        };
        return quantizedBounds;
      };

      Rasterizer.prototype.rasterize = function(items, excludeItems) {};

      Rasterizer.prototype.unload = function(limit) {};

      Rasterizer.prototype.load = function(rasters, qZoom) {};

      Rasterizer.prototype.move = function() {};

      Rasterizer.prototype.loadItem = function(item) {
        item.draw();
      };

      Rasterizer.prototype.selectItem = function(item) {};

      Rasterizer.prototype.deselectItem = function(item) {};

      Rasterizer.prototype.rasterizeRectangle = function(rectangle) {};

      Rasterizer.prototype.addAreaToUpdate = function(area) {};

      Rasterizer.prototype.setQZoomToUpdate = function(qZoom) {};

      Rasterizer.prototype.rasterizeAreasToUpdate = function() {};

      Rasterizer.prototype.maxArea = function() {
        return view.bounds.area * this.constructor.MAX_AREA;
      };

      Rasterizer.prototype.rasterizeView = function() {};

      Rasterizer.prototype.clearRasters = function() {};

      Rasterizer.prototype.drawItems = function(showPath) {
        if (showPath == null) {
          showPath = false;
        }
      };

      Rasterizer.prototype.rasterizeItems = function() {
        var item, pk, _ref;
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          if (typeof item.rasterize === "function") {
            item.rasterize();
          }
        }
      };

      return Rasterizer;

    })();
    g.Rasterizer = Rasterizer;
    SimpleRasterizer = (function(_super) {
      __extends(SimpleRasterizer, _super);

      SimpleRasterizer.TYPE = 'simple';

      function SimpleRasterizer() {
        SimpleRasterizer.__super__.constructor.call(this);
        return;
      }

      SimpleRasterizer.prototype.loadItem = function(item) {
        SimpleRasterizer.__super__.loadItem.call(this, item);
        item.rasterize();
      };

      SimpleRasterizer.prototype.selectItem = function(item) {
        SimpleRasterizer.__super__.selectItem.call(this, item);
      };

      SimpleRasterizer.prototype.deselectItem = function(item) {
        item.rasterize();
        SimpleRasterizer.__super__.deselectItem.call(this, item);
      };

      return SimpleRasterizer;

    })(g.Rasterizer);
    g.SimpleRasterizer = SimpleRasterizer;
    TileRasterizer = (function(_super) {
      __extends(TileRasterizer, _super);

      TileRasterizer.TYPE = 'abstract tile';

      function TileRasterizer() {
        this.rasterizeCallback = __bind(this.rasterizeCallback, this);
        TileRasterizer.__super__.constructor.call(this);
        this.itemsToExclude = [];
        this.areaToRasterize = null;
        this.areasToUpdate = [];
        this.rasters = {};
        this.keepRastersMode = true;
        this.rasterizationDisabled = false;
        this.move();
        return;
      }

      TileRasterizer.prototype.loadItem = function(item) {
        var _ref;
        if (((_ref = item.data) != null ? _ref.animate : void 0) || g.selectedToolNeedsDrawings()) {
          item.draw();
        }
        if (this.keepRastersMode) {
          item.rasterize();
        }
      };

      TileRasterizer.prototype.selectItem = function(item) {
        this.rasterize(item, true);
      };

      TileRasterizer.prototype.deselectItem = function(item) {
        if (this.keepRastersMode) {
          item.rasterize();
        }
        this.rasterize(item);
      };

      TileRasterizer.prototype.rasterLoaded = function(raster) {
        var allRastersAreReady, rasterColumn, x, y, _ref;
        raster.context.clearRect(0, 0, g.scale, g.scale);
        raster.context.drawImage(raster.image, 0, 0);
        raster.ready = true;
        allRastersAreReady = true;
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            allRastersAreReady &= raster.ready;
          }
        }
        if (allRastersAreReady) {
          this.rasterizeAreasToUpdate();
        }
      };

      TileRasterizer.prototype.createRaster = function(x, y, zoom, raster) {
        var _base;
        raster.zoom = zoom;
        raster.ready = true;
        if ((_base = this.rasters)[x] == null) {
          _base[x] = {};
        }
        this.rasters[x][y] = raster;
      };

      TileRasterizer.prototype.getRasterBounds = function(x, y) {
        var size;
        size = this.rasters[x][y].zoom * g.scale;
        return new Rectangle(x, y, size, size);
      };

      TileRasterizer.prototype.removeRaster = function(raster, x, y) {
        delete this.rasters[x][y];
        if (g.isEmpty(this.rasters[x])) {
          delete this.rasters[x];
        }
      };

      TileRasterizer.prototype.unload = function(limit) {
        var qZoom, raster, rasterColumn, rectangle, x, y, _ref;
        qZoom = g.quantizeZoom(1.0 / view.zoom);
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          x = Number(x);
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            y = Number(y);
            rectangle = this.getRasterBounds(x, y);
            if (!limit.intersects(rectangle) || this.rasters[x][y].zoom !== qZoom) {
              this.removeRaster(raster, x, y);
            }
          }
        }
      };

      TileRasterizer.prototype.load = function(rasters, qZoom) {
        var r, raster, x, y, _i, _len, _ref;
        this.move();
        for (_i = 0, _len = rasters.length; _i < _len; _i++) {
          r = rasters[_i];
          x = r.position.x * g.scale;
          y = r.position.y * g.scale;
          raster = (_ref = this.rasters[x]) != null ? _ref[y] : void 0;
          if (raster) {
            raster.ready = false;
            raster.image.src = g.romanescoURL + r.url + '?' + Math.random();
          }
        }
      };

      TileRasterizer.prototype.move = function() {
        var qBounds, qZoom, scale, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
        qZoom = g.quantizeZoom(1.0 / view.zoom);
        scale = g.scale * qZoom;
        qBounds = this.quantizeBounds(view.bounds, scale);
        for (x = _i = _ref = qBounds.l, _ref1 = qBounds.r; scale > 0 ? _i <= _ref1 : _i >= _ref1; x = _i += scale) {
          for (y = _j = _ref2 = qBounds.t, _ref3 = qBounds.b; scale > 0 ? _j <= _ref3 : _j >= _ref3; y = _j += scale) {
            this.createRaster(x, y, qZoom);
          }
        }
      };

      TileRasterizer.prototype.splitAreaToRasterize = function() {
        var area, areaToRasterizeInteger, areas, maxSize;
        maxSize = view.size.multiply(2);
        areaToRasterizeInteger = g.expandRectangleToInteger(this.areaToRasterize);
        area = g.expandRectangleToInteger(new Rectangle(this.areaToRasterize.topLeft, Size.min(maxSize, this.areaToRasterize.size)));
        areas = [area.clone()];
        while (area.right < this.areaToRasterize.right || area.bottom < this.areaToRasterize.bottom) {
          if (area.right < this.areaToRasterize.right) {
            area.x += maxSize.width;
          } else {
            area.x = areaToRasterizeInteger.left;
            area.y += maxSize.height;
          }
          areas.push(area.intersect(areaToRasterizeInteger));
        }
        return areas;
      };

      TileRasterizer.prototype.rasterizeCanvasInRaster = function(x, y, canvas, rectangle, qZoom, clearRasters) {
        var context, destinationRectangle, intersection, rasterRectangle, sourceRectangle, _ref;
        if (clearRasters == null) {
          clearRasters = false;
        }
        if (((_ref = this.rasters[x]) != null ? _ref[y] : void 0) == null) {
          return;
        }
        rasterRectangle = this.getRasterBounds(x, y);
        intersection = rectangle.intersect(rasterRectangle);
        sourceRectangle = new Rectangle(intersection.topLeft.subtract(rectangle.topLeft).divide(qZoom), intersection.size.divide(qZoom));
        destinationRectangle = new Rectangle(intersection.topLeft.subtract(rasterRectangle.topLeft).divide(qZoom), intersection.size.divide(qZoom));
        context = this.rasters[x][y].context;
        if (clearRasters) {
          context.clearRect(destinationRectangle.x, destinationRectangle.y, destinationRectangle.width, destinationRectangle.height);
        }
        context.drawImage(canvas, sourceRectangle.x, sourceRectangle.y, sourceRectangle.width, sourceRectangle.height, destinationRectangle.x, destinationRectangle.y, destinationRectangle.width, destinationRectangle.height);
      };

      TileRasterizer.prototype.rasterizeCanvas = function(canvas, rectangle, clearRasters) {
        var qBounds, qZoom, scale, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
        if (clearRasters == null) {
          clearRasters = false;
        }
        console.log("rasterize: " + rectangle.width + ", " + rectangle.height);
        qZoom = g.quantizeZoom(1.0 / view.zoom);
        scale = g.scale * qZoom;
        qBounds = this.quantizeBounds(rectangle, scale);
        for (x = _i = _ref = qBounds.l, _ref1 = qBounds.r; scale > 0 ? _i <= _ref1 : _i >= _ref1; x = _i += scale) {
          for (y = _j = _ref2 = qBounds.t, _ref3 = qBounds.b; scale > 0 ? _j <= _ref3 : _j >= _ref3; y = _j += scale) {
            this.rasterizeCanvasInRaster(x, y, canvas, rectangle, qZoom, clearRasters);
          }
        }
      };

      TileRasterizer.prototype.rasterizeArea = function(area) {
        view.viewSize = area.size.multiply(view.zoom);
        view.center = area.center;
        view.update();
        this.rasterizeCanvas(g.canvas, area, true);
      };

      TileRasterizer.prototype.rasterizeAreas = function(areas) {
        var area, viewPosition, viewSize, viewZoom, _i, _len;
        viewZoom = view.zoom;
        viewSize = view.viewSize;
        viewPosition = view.center;
        view.zoom = 1.0 / g.quantizeZoom(1.0 / view.zoom);
        for (_i = 0, _len = areas.length; _i < _len; _i++) {
          area = areas[_i];
          this.rasterizeArea(area);
        }
        view.zoom = viewZoom;
        view.viewSize = viewSize;
        view.center = viewPosition;
      };

      TileRasterizer.prototype.rasterizeCallback = function(step) {
        var areas, item, pk, viewOnFrame, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
        console.log("rasterize");
        g.logElapsedTime();
        g.startTimer();
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          item.group.visible = true;
        }
        areas = this.splitAreaToRasterize();
        _ref1 = this.itemsToExclude;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          if ((_ref2 = item.group) != null) {
            _ref2.visible = false;
          }
        }
        g.grid.visible = false;
        g.selectionLayer.visible = false;
        g.carLayer.visible = false;
        viewOnFrame = view.onFrame;
        view.onFrame = null;
        if ((_ref3 = this.rasterLayer) != null) {
          _ref3.visible = false;
        }
        this.rasterizeAreas(areas);
        if ((_ref4 = this.rasterLayer) != null) {
          _ref4.visible = true;
        }
        view.onFrame = viewOnFrame;
        g.carLayer.visible = true;
        g.selectionLayer.visible = true;
        g.grid.visible = true;
        _ref5 = g.items;
        for (pk in _ref5) {
          item = _ref5[pk];
          if (item === g.currentPaths[g.me] || (item.selectionRectangle != null)) {
            continue;
          }
          if ((_ref6 = item.group) != null) {
            _ref6.visible = false;
          }
        }
        _ref7 = this.itemsToExclude;
        for (_j = 0, _len1 = _ref7.length; _j < _len1; _j++) {
          item = _ref7[_j];
          if ((_ref8 = item.group) != null) {
            _ref8.visible = true;
          }
          if (typeof item.showChildren === "function") {
            item.showChildren();
          }
        }
        this.itemsToExclude = [];
        this.areaToRasterize = null;
        g.stopTimer('Time to rasterize path: ');
        g.logElapsedTime();
      };

      TileRasterizer.prototype.rasterize = function(items, excludeItems) {
        var item, _i, _len;
        if (this.rasterizationDisabled) {
          return;
        }
        console.log("ask rasterize" + (excludeItems ? "exclude items" : ""));
        g.logElapsedTime();
        if (!g.isArray(items)) {
          items = [items];
        }
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (this.areaToRasterize == null) {
            this.areaToRasterize = item.getDrawingBounds();
          }
          this.areaToRasterize = this.areaToRasterize.unite(item.getDrawingBounds());
          if (excludeItems) {
            g.pushIfAbsent(this.itemsToExclude, item);
          }
        }
        g.callNextFrame(this.rasterizeCallback, 'rasterize');
      };

      TileRasterizer.prototype.rasterizeRectangle = function(rectangle) {
        this.drawItems();
        if (this.areaToRasterize == null) {
          this.areaToRasterize = rectangle;
        } else {
          this.areaToRasterize = this.areaToRasterize.unite(rectangle);
        }
        g.callNextFrame(this.rasterizeCallback, 'rasterize');
      };

      TileRasterizer.prototype.addAreaToUpdate = function(area) {
        this.areasToUpdate.push(area);
      };

      TileRasterizer.prototype.setQZoomToUpdate = function(qZoom) {
        this.areasToUpdateQZoom = qZoom;
      };

      TileRasterizer.prototype.rasterizeAreasToUpdate = function() {
        var area, previousAreaToRasterize, previousItemsToExclude, previousZoom, _i, _len, _ref;
        if (this.areasToUpdate.length === 0) {
          return;
        }
        this.drawItems(true);
        previousItemsToExclude = this.itemsToExclude;
        previousAreaToRasterize = this.areaToRasterize;
        previousZoom = view.zoom;
        view.zoom = 1.0 / this.areasToUpdateQZoom;
        this.itemsToExclude = [];
        _ref = this.areasToUpdate;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          area = _ref[_i];
          this.areaToRasterize = area;
          this.rasterizeCallback();
        }
        this.areasToUpdate = [];
        this.itemsToExclude = previousItemsToExclude;
        this.areaToRasterize = previousAreaToRasterize;
        view.zoom = previousZoom;
      };

      TileRasterizer.prototype.clearRasters = function() {
        var raster, rasterColumn, x, y, _ref;
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            raster.context.clearRect(0, 0, g.scale, g.scale);
          }
        }
      };

      TileRasterizer.prototype.drawItems = function(showPath) {
        var item, pk, _ref;
        if (showPath == null) {
          showPath = false;
        }
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          if (item.drawing == null) {
            if (typeof item.draw === "function") {
              item.draw();
            }
          }
          item.group.visible = showPath || (item.selectionRectangle != null);
          if (this.keepRastersMode) {
            if (typeof item.rasterize === "function") {
              item.rasterize();
            }
          }
        }
      };

      TileRasterizer.prototype.disableRasterization = function() {
        this.rasterizationDisabled = true;
        this.clearRasters();
        this.drawItems(true);
      };

      TileRasterizer.prototype.enableRasterization = function() {
        this.rasterizationDisabled = false;
        this.rasterizeView();
      };

      TileRasterizer.prototype.rasterizeView = function() {
        this.rasterizeRectangle(view.bounds);
      };

      return TileRasterizer;

    })(g.Rasterizer);
    g.TileRasterizer = TileRasterizer;
    PaperTileRasterizer = (function(_super) {
      __extends(PaperTileRasterizer, _super);

      PaperTileRasterizer.TYPE = 'paper tile';

      function PaperTileRasterizer() {
        this.rasterizeCallback = __bind(this.rasterizeCallback, this);
        this.rasterLayer = new Layer();
        this.rasterLayer.moveBelow(g.mainLayer);
        this.useCanvasMode = true;
        PaperTileRasterizer.__super__.constructor.call(this);
        return;
      }

      PaperTileRasterizer.prototype.createRaster = function(x, y, zoom) {
        var raster, _ref;
        if (((_ref = this.rasters[x]) != null ? _ref[y] : void 0) != null) {
          return;
        }
        raster = new Raster();
        raster.position.x = x + 0.5 * g.scale * zoom;
        raster.position.y = y + 0.5 * g.scale * zoom;
        raster.width = g.scale;
        raster.height = g.scale;
        raster.scale(zoom);
        raster.context = raster.canvas.getContext('2d');
        this.rasterLayer.addChild(raster);
        raster.onLoad = (function(_this) {
          return function() {
            _this.rasterLoaded(_this);
          };
        })(this);
        PaperTileRasterizer.__super__.createRaster.call(this, x, y, zoom, raster);
      };

      PaperTileRasterizer.prototype.rasterizeCallback2 = function() {
        var area, areas, item, pk, position, qBounds, qZoom, raster, rasterRectangle, rasterTopLeft, scale, x, y, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        console.log("rasterize");
        g.logElapsedTime();
        g.startTimer();
        _ref = g.items;
        for (pk in _ref) {
          item = _ref[pk];
          item.group.visible = true;
        }
        areas = this.splitAreaToRasterize();
        _ref1 = this.itemsToExclude;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          item = _ref1[_i];
          if ((_ref2 = item.group) != null) {
            _ref2.visible = false;
          }
        }
        for (_j = 0, _len1 = areas.length; _j < _len1; _j++) {
          area = areas[_j];
          qZoom = g.quantizeZoom(1.0 / view.zoom);
          scale = g.scale * qZoom;
          qBounds = this.quantizeBounds(area, scale);
          for (x = _k = _ref3 = qBounds.l, _ref4 = qBounds.r; scale > 0 ? _k <= _ref4 : _k >= _ref4; x = _k += scale) {
            for (y = _l = _ref5 = qBounds.t, _ref6 = qBounds.b; scale > 0 ? _l <= _ref6 : _l >= _ref6; y = _l += scale) {
              if (((_ref7 = this.rasters[x]) != null ? _ref7[y] : void 0) == null) {
                continue;
              }
              rasterRectangle = this.getRasterBounds(x, y);
              this.rasters[x][y].context.clearRect(0, 0, g.scale, g.scale);
              _ref8 = g.items;
              for (pk in _ref8) {
                item = _ref8[pk];
                if ((_ref9 = item.raster) != null ? _ref9.bounds.intersects(rasterRectangle) : void 0) {
                  raster = this.rasters[x][y];
                  rasterTopLeft = raster.position.subtract(raster.zoom * 0.5 * g.scale);
                  position = item.raster.bounds.topLeft.subtract(rasterTopLeft);
                  this.rasters[x][y].drawImage(item.raster.canvas, position);
                }
              }
            }
          }
        }
        _ref10 = g.items;
        for (pk in _ref10) {
          item = _ref10[pk];
          if (item === g.currentPaths[g.me] || (item.selectionRectangle != null)) {
            continue;
          }
          if ((_ref11 = item.group) != null) {
            _ref11.visible = false;
          }
        }
        _ref12 = this.itemsToExclude;
        for (_m = 0, _len2 = _ref12.length; _m < _len2; _m++) {
          item = _ref12[_m];
          if ((_ref13 = item.group) != null) {
            _ref13.visible = true;
          }
          if (typeof item.showChildren === "function") {
            item.showChildren();
          }
        }
        this.itemsToExclude = [];
        this.areaToRasterize = null;
        g.stopTimer('Time to rasterize path: ');
        g.logElapsedTime();
      };

      PaperTileRasterizer.prototype.rasterizeCallback = function(step) {
        if (this.useCanvasMode) {
          PaperTileRasterizer.__super__.rasterizeCallback.call(this);
        } else {
          this.rasterizeCallback2();
        }
      };

      PaperTileRasterizer.prototype.removeRaster = function(raster, x, y) {
        raster.remove();
        PaperTileRasterizer.__super__.removeRaster.call(this, raster, x, y);
      };

      return PaperTileRasterizer;

    })(g.TileRasterizer);
    g.PaperTileRasterizer = PaperTileRasterizer;
    CanvasTileRasterizer = (function(_super) {
      __extends(CanvasTileRasterizer, _super);

      CanvasTileRasterizer.TYPE = 'canvas tile';

      function CanvasTileRasterizer() {
        CanvasTileRasterizer.__super__.constructor.call(this);
        return;
      }

      CanvasTileRasterizer.prototype.createRaster = function(x, y, zoom) {
        var raster, _ref;
        raster = (_ref = this.rasters[x]) != null ? _ref[y] : void 0;
        if (raster != null) {
          return;
        }
        raster = {};
        raster.canvasJ = $('<canvas hidpi="off" width="' + g.scale + '" height="' + g.scale + '">');
        raster.canvas = raster.canvasJ[0];
        raster.context = raster.canvas.getContext('2d');
        raster.image = new Image();
        raster.image.onload = (function(_this) {
          return function() {
            _this.rasterLoaded(raster);
          };
        })(this);
        $("#rasters").append(raster.canvasJ);
        CanvasTileRasterizer.__super__.createRaster.call(this, x, y, zoom, raster);
      };

      CanvasTileRasterizer.prototype.removeRaster = function(raster, x, y) {
        raster.canvasJ.remove();
        CanvasTileRasterizer.__super__.removeRaster.call(this, raster, x, y);
      };

      CanvasTileRasterizer.prototype.move = function() {
        var css, raster, rasterColumn, scale, viewPos, x, y, _ref;
        CanvasTileRasterizer.__super__.move.call(this);
        _ref = this.rasters;
        for (x in _ref) {
          rasterColumn = _ref[x];
          x = Number(x);
          for (y in rasterColumn) {
            raster = rasterColumn[y];
            y = Number(y);
            viewPos = view.projectToView(new Point(x, y));
            if (view.zoom === 1) {
              raster.canvasJ.css({
                'left': viewPos.x,
                'top': viewPos.y,
                'transform': 'none'
              });
            } else {
              scale = view.zoom * raster.zoom;
              css = 'translate(' + viewPos.x + 'px,' + viewPos.y + 'px)';
              css += ' scale(' + scale + ')';
              raster.canvasJ.css({
                'transform': css,
                'top': 0,
                'left': 0,
                'transform-origin': '0 0'
              });
            }
          }
        }
      };

      return CanvasTileRasterizer;

    })(g.TileRasterizer);
    g.CanvasTileRasterizer = CanvasTileRasterizer;
    FastCanvasTileRasterizer = (function(_super) {
      __extends(FastCanvasTileRasterizer, _super);

      FastCanvasTileRasterizer.TYPE = 'fast canvas tile';

      function FastCanvasTileRasterizer() {
        FastCanvasTileRasterizer.__super__.constructor.call(this);
        return;
      }

      FastCanvasTileRasterizer.prototype.loadItem = function(item) {
        FastCanvasTileRasterizer.__super__.loadItem.call(this, item);
        item.rasterize();
      };

      FastCanvasTileRasterizer.prototype.selectItem = function(item) {
        FastCanvasTileRasterizer.__super__.selectItem.call(this, item);
      };

      FastCanvasTileRasterizer.prototype.deselectItem = function(item) {
        item.rasterize();
        FastCanvasTileRasterizer.__super__.deselectItem.call(this, item);
      };

      return FastCanvasTileRasterizer;

    })(g.CanvasTileRasterizer);
    g.FastCanvasTileRasterizer = FastCanvasTileRasterizer;
    g.initializeRasterizers = function() {
      var rasterizer, type, _ref;
      g.rasterizers = {};
      new g.Rasterizer();
      new g.CanvasTileRasterizer();
      new g.FastCanvasTileRasterizer();
      g.rasterizer = new g.PaperTileRasterizer();
      if (g.parameters == null) {
        g.parameters = {
          renderingMode: {
            values: [],
            "default": g.rasterizer.constructor.TYPE
          }
        };
      }
      _ref = g.rasterizers;
      for (type in _ref) {
        rasterizer = _ref[type];
        g.parameters.renderingMode.values.push(type);
      }
    };
    g.setRasterizerType = function(type) {
      g.unload();
      g.rasterizer = g.rasterizers[type];
      g.load();
    };
    g.hideCanvas = function() {
      g.canvasJ.css({
        opacity: 0
      });
    };
    g.showCanvas = function() {
      g.canvasJ.css({
        opacity: 1
      });
    };
    g.hideRasters = function() {
      $("#rasters").css({
        opacity: 0
      });
    };
    g.showRasters = function() {
      $("#rasters").css({
        opacity: 1
      });
    };
  });

}).call(this);

//# sourceMappingURL=rasterizer.map
