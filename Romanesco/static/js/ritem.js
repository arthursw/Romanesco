// Generated by CoffeeScript 1.7.1
(function() {
  var RItem;

  RItem = (function() {
    RItem.indexToName = {
      0: 'bottomLeft',
      1: 'left',
      2: 'topLeft',
      3: 'top',
      5: 'top',
      6: 'topRight',
      7: 'right',
      8: 'bottomRight',
      9: 'bottom'
    };

    RItem.oppositeName = {
      'top': 'bottom',
      'bottom': 'top',
      'left': 'right',
      'right': 'left',
      'topLeft': 'bottomRight',
      'topRight': 'bottomLeft',
      'bottomRight': 'topLeft',
      'bottomLeft': 'topRight'
    };

    RItem.valueFromName = function(point, name) {
      switch (name) {
        case 'left':
        case 'right':
          return point.x;
        case 'top':
        case 'bottom':
          return point.y;
        default:
          return point;
      }
    };

    RItem.hitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      selected: true,
      tolerance: 5
    };

    function RItem(itemList, sortedItems) {
      this.sortedItems = sortedItems;
      if (RLock.prototype.isPrototypeOf(this)) {
        return;
      }
      this.liJ = $("<li>").text(this.constructor.rname);
      this.liJ.attr("data-pk", this.pk);
      this.liJ.click((function(_this) {
        return function(event) {
          if (!event.shiftKey) {
            g.deselectAll();
          }
          _this.select();
        };
      })(this));
      this.liJ.mouseover((function(_this) {
        return function(event) {
          _this.highlight();
        };
      })(this));
      this.liJ.mouseout((function(_this) {
        return function(event) {
          _this.unhighlight();
        };
      })(this));
      this.liJ.rItem = this;
      itemList.append(this.liJ);
      $("#Items .mCustomScrollbar").mCustomScrollbar("scrollTo", "bottom");
      this.rectangle = null;
      this.rotation = 0;
      this.selectionState = null;
      this.selectionRectangle = null;
      this.group = new Group();
      this.group.name = "group";
      this.group.controller = this;
      return;
    }

    RItem.prototype.prepareHitTest = function(fullySelected, strokeWidth) {
      if (fullySelected == null) {
        fullySelected = true;
      }
    };

    RItem.prototype.finishHitTest = function(fullySelected) {
      if (fullySelected == null) {
        fullySelected = true;
      }
    };

    RItem.prototype.hitTest = function(point, hitOptions) {
      return this.selectionRectangle.hitTest(point);
    };

    RItem.prototype.performHitTest = function(point, hitOptions, fullySelected) {
      var hitResult;
      if (fullySelected == null) {
        fullySelected = true;
      }
      this.prepareHitTest(fullySelected, 1);
      hitResult = this.hitTest(point, hitOptions);
      this.finishHitTest(fullySelected);
      return hitResult;
    };

    RItem.prototype.initSelection = function(event, hitResult, userAction) {
      if (userAction == null) {
        userAction = true;
      }
      this.selectionState = {
        move: true
      };
      if (hitResult == null) {
        return;
      }
      if (hitResult.type === 'segment') {
        if (hitResult.item === this.selectionRectangle) {
          this.selectionState = {};
          if (hitResult.segment.index === 4) {
            this.selectionState = {
              rotation: true
            };
          } else {
            this.selectionState = {
              scale: {
                index: hitResult.segment.index
              }
            };
          }
        }
      }
    };

    RItem.prototype.selectBegin = function(event, userAction) {
      var hitResult;
      if (userAction == null) {
        userAction = true;
      }
      this.changed = null;
      this.selectionState = null;
      if (userAction) {
        if (!this.isSelected()) {
          g.commandManager.add(new SelectCommand([this], true));
        }
        hitResult = this.performHitTest(event.point, this.constructor.hitOptions);
        this.initSelection(event, hitResult, userAction);
        if (this.selectionState.move != null) {
          this.selectCommand = new MoveCommand(this, this.getPosition(), this.getPosition(), false);
        } else if (this.selectionState.scale != null) {
          this.selectCommand = new ScaleCommand(this);
        } else if (this.selectionState.rotation != null) {
          this.selectCommand = new RotationCommand(this);
        }
      }
    };

    RItem.prototype.selectUpdate = function(event, userAction) {
      var center, currentDirection, delta, dx, dy, index, name, newDirection, rectangle, x, y;
      if (userAction == null) {
        userAction = true;
      }
      if (this.selectionState != null) {
        if (this.selectionState.rotation != null) {
          currentDirection = new Point({
            length: 1,
            angle: this.rotation - 90
          });
          newDirection = event.point.subtract(this.selectionRectangle.pivot);
          delta = currentDirection.getDirectedAngle(newDirection);
          this.setRotation(this.rotation + delta, true);
        } else if (this.selectionState.scale != null) {
          rectangle = this.rectangle.clone();
          delta = event.point.subtract(this.rectangle.center);
          x = new Point(1, 0);
          x.angle += this.rotation;
          dx = x.dot(delta);
          y = new Point(0, 1);
          y.angle += this.rotation;
          dy = y.dot(delta);
          index = this.selectionState.scale.index;
          if (!event.modifiers.shift && (index === 0 || index === 2 || index === 6 || index === 8) && rectangle.width > 0 && rectangle.height > 0) {
            if (Math.abs(dx / rectangle.width) > Math.abs(dy / rectangle.height)) {
              dx = g.sign(dx) * Math.abs(rectangle.width * dy / rectangle.height);
            } else {
              dy = g.sign(dy) * Math.abs(rectangle.height * dx / rectangle.width);
            }
          }
          name = this.constructor.indexToName[index];
          center = rectangle.center.clone();
          rectangle[name] = this.constructor.valueFromName(center.add(dx, dy), name);
          if (!g.specialKey(event)) {
            rectangle[this.constructor.oppositeName[name]] = this.constructor.valueFromName(center.subtract(dx, dy), name);
          } else {
            rectangle.center = center.add(rectangle.center.subtract(center).rotate(this.rotation));
          }
          if (rectangle.width < 0) {
            rectangle.width = Math.abs(rectangle.width);
            rectangle.center.x = center.x;
          }
          if (rectangle.height < 0) {
            rectangle.height = Math.abs(rectangle.height);
            rectangle.center.y = center.y;
          }
          this.setRectangle(rectangle, true);
        } else if (this.selectionState.move != null) {
          this.rectangle.x += event.delta.x;
          this.rectangle.y += event.delta.y;
          this.group.position.x += event.delta.x;
          this.group.position.y += event.delta.y;
          this.changed = 'moved';
        }
      }
    };

    RItem.prototype.selectEnd = function(event, userAction) {
      if (userAction == null) {
        userAction = true;
      }
      if (this.changed != null) {
        this.selectCommand.update();
        g.commandManager.add(this.selectCommand);
        this.selectCommand = null;
        this.update('rectangle');
      }
      this.changed = null;
    };

    RItem.prototype.createSelectionRectangle = function(bounds) {
      var _ref;
      if ((_ref = this.selectionRectangle) != null) {
        _ref.remove();
      }
      this.selectionRectangle = new Path.Rectangle(bounds);
      this.group.addChild(this.selectionRectangle);
      this.selectionRectangle.name = "selection rectangle";
      this.selectionRectangle.pivot = bounds.center;
      this.selectionRectangle.insert(1, new Point(bounds.left, bounds.center.y));
      this.selectionRectangle.insert(3, new Point(bounds.center.x, bounds.top));
      this.selectionRectangle.insert(3, new Point(bounds.center.x, bounds.top - 25));
      this.selectionRectangle.insert(3, new Point(bounds.center.x, bounds.top));
      this.selectionRectangle.insert(7, new Point(bounds.right, bounds.center.y));
      this.selectionRectangle.insert(9, new Point(bounds.center.x, bounds.bottom));
      this.selectionRectangle.selected = true;
      this.selectionRectangle.controller = this;
    };

    RItem.prototype.updateSelectionRectangle = function() {
      var bounds;
      bounds = this.rectangle.clone().expand(10);
      this.createSelectionRectangle(bounds);
      this.selectionRectangle.rotation = this.rotation;
    };

    RItem.prototype.setRectangle = function(rectangle) {
      this.rectangle = rectangle;
      this.updateSelectionRectangle();
    };

    RItem.prototype.setRotation = function(rotation) {
      this.rotation = rotation;
      this.selectionRectangle.rotation = rotation;
    };

    RItem.prototype.getData = function() {
      var data;
      data = jQuery.extend({}, this.data);
      data.rectangle = this.rectangle.toJSON();
      data.rotation = this.rotation;
      return data;
    };

    RItem.prototype.getStringifiedData = function() {
      return JSON.stringify(this.getData());
    };

    RItem.prototype.getBounds = function() {
      var bottomLeft, bottomRight, bounds, topLeft, topRight;
      topLeft = this.rectangle.topLeft.subtract(this.rectangle.center);
      topLeft.angle += this.rotation;
      bottomRight = this.rectangle.bottomRight.subtract(this.rectangle.center);
      bottomRight.angle += this.rotation;
      bottomLeft = this.rectangle.bottomLeft.subtract(this.rectangle.center);
      bottomLeft.angle += this.rotation;
      topRight = this.rectangle.topRight.subtract(this.rectangle.center);
      topRight.angle += this.rotation;
      bounds = new Rectangle(topLeft, bottomRight);
      bounds = bounds.include(bottomLeft);
      bounds = bounds.include(topRight);
      return bounds;
    };

    RItem.prototype.highlight = function() {
      var _ref;
      this.highlightRectangle = new Path.Rectangle(this.getBounds());
      this.highlightRectangle.strokeColor = g.selectionBlue;
      this.highlightRectangle.dashArray = [4, 10];
      if ((_ref = this.group) != null) {
        _ref.addChild(this.highlightRectangle);
      }
    };

    RItem.prototype.unhighlight = function() {
      if (this.highlightRectangle == null) {
        return;
      }
      this.highlightRectangle.remove();
      this.highlightRectangle = null;
    };

    RItem.prototype.updateZIndex = function() {
      var found, i, item, _i, _len, _ref;
      if (this.date == null) {
        return;
      }
      if (this.sortedItems.length === 0) {
        this.sortedItems.push(this);
        return;
      }
      found = false;
      _ref = this.sortedItems;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        if (this.date < item.date) {
          this.insertBelow(item, i);
          found = true;
          break;
        }
      }
      if (!found) {
        this.insertAbove(this.sortedItems.last());
      }
    };

    RItem.prototype.insertAbove = function(item, index, update) {
      var nextDate, previousDate;
      if (index == null) {
        index = null;
      }
      if (update == null) {
        update = false;
      }
      if (!index) {
        this.sortedItems.remove(this);
        index = this.sortedItems.indexOf(item) + 1;
      }
      this.sortedItems.splice(index, 0, this);
      this.liJ.insertBefore(item.liJ);
      if (update) {
        if (this.sortedItems[index + 1] == null) {
          this.date = Date.now();
        } else {
          previousDate = this.sortedItems[index - 1].date;
          nextDate = this.sortedItems[index + 1].date;
          this.date = (previousDate + nextDate) / 2;
        }
        this.update('z-index');
      }
    };

    RItem.prototype.insertBelow = function(item, index, update) {
      var nextDate, previousDate;
      if (index == null) {
        index = null;
      }
      if (update == null) {
        update = false;
      }
      if (!index) {
        this.sortedItems.remove(this);
        index = this.sortedItems.indexOf(item);
      }
      this.sortedItems.splice(index, 0, this);
      this.liJ.insertAfter(item.liJ);
      if (update) {
        if (this.sortedItems[index - 1] == null) {
          this.date = this.sortedItems[index + 1].date - 1000;
        } else {
          previousDate = this.sortedItems[index - 1].date;
          nextDate = this.sortedItems[index + 1].date;
          this.date = (previousDate + nextDate) / 2;
        }
        this.update('z-index');
      }
    };

    RItem.prototype.setPK = function() {
      var _ref;
      if ((_ref = this.liJ) != null) {
        _ref.attr("data-pk", this.pk);
      }
    };

    RItem.prototype.isSelected = function() {
      return this.selectionRectangle != null;
    };

    RItem.prototype.select = function(updateOptions) {
      var _ref;
      if (updateOptions == null) {
        updateOptions = true;
      }
      if ((_ref = this.liJ) != null) {
        _ref.addClass('selected');
      }
      if (this.selectionRectangle != null) {
        return false;
      }
      this.selectionState = null;
      this.updateSelectionRectangle(true);
      if (updateOptions) {
        g.updateParameters({
          tool: this.constructor,
          item: this
        }, true);
      }
      g.s = this;
      return true;
    };

    RItem.prototype.deselect = function() {
      var _ref, _ref1;
      if ((_ref = this.liJ) != null) {
        _ref.removeClass('selected');
      }
      if (this.selectionRectangle == null) {
        return false;
      }
      if (!this.lock) {
        g.mainLayer.insertChild(this.zindex, this.group);
      } else {
        this.lock.group.insertChild(this.zindex, this.group);
      }
      if ((_ref1 = this.selectionRectangle) != null) {
        _ref1.remove();
      }
      this.selectionRectangle = null;
    };

    RItem.prototype.remove = function() {
      var _ref, _ref1, _ref2;
      if ((_ref = this.sortedItems) != null) {
        _ref.remove(this);
      }
      if ((_ref1 = this.highlightRectangle) != null) {
        _ref1.remove();
      }
      if ((_ref2 = this.liJ) != null) {
        _ref2.remove();
      }
    };

    return RItem;

  })();

  this.RItem = RItem;

}).call(this);

//# sourceMappingURL=ritem.map
