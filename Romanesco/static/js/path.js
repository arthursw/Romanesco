// Generated by CoffeeScript 1.7.1
(function() {
  var Checkpoint, DynamicBrush, EllipseShape, FaceShape, GeometricLines, GridPath, Meander, PaintBrush, PaintGun, PrecisePath, RPath, RShape, RectangleShape, ShapePath, SpeedPath, SpiralShape, StarShape, StripeAnimation, ThicknessPath,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  RPath = (function() {
    RPath.rname = 'Pen';

    RPath.rdescription = "The classic and basic pen tool";

    RPath.cursorPosition = {
      x: 24,
      y: 0
    };

    RPath.cursorDefault = "crosshair";

    RPath.hitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      selected: true,
      tolerance: 5
    };

    RPath.constructor.secureDistance = 2;

    RPath.parameters = function() {
      var parameters;
      return parameters = {
        'General': {
          align: g.parameters.align,
          distribute: g.parameters.distribute,
          duplicate: g.parameters.duplicate,
          "delete": g.parameters["delete"],
          editTool: {
            type: 'button',
            label: 'Edit tool',
            "default": (function(_this) {
              return function() {
                return g.toolEditor(_this);
              };
            })(this)
          }
        },
        'Style': {
          strokeWidth: $.extend(true, {}, g.parameters.strokeWidth),
          strokeColor: $.extend(true, {}, g.parameters.strokeColor),
          fillColor: $.extend(true, {}, g.parameters.fillColor)
        },
        'Shadow': {
          folderIsClosedByDefault: true,
          shadowOffsetX: {
            type: 'slider',
            label: 'Shadow offset x',
            min: 0,
            max: 25,
            "default": 0
          },
          shadowOffsetY: {
            type: 'slider',
            label: 'Shadow offset y',
            min: 0,
            max: 25,
            "default": 0
          },
          shadowBlur: {
            type: 'slider',
            label: 'Shadow blur',
            min: 0,
            max: 50,
            "default": 0
          },
          shadowColor: {
            type: 'color',
            label: 'Shadow color',
            "default": '#000',
            defaultCheck: false
          }
        }
      };
    };

    function RPath(date, data, pk, points) {
      var controller, folder, name, _i, _len, _ref, _ref1;
      this.date = date != null ? date : null;
      this.data = data != null ? data : null;
      this.pk = pk != null ? pk : null;
      if (points == null) {
        points = null;
      }
      this.update = __bind(this.update, this);
      this.save_callback = __bind(this.save_callback, this);
      this.selectedSegment = null;
      this.id = this.data != null ? this.data.id : Math.random();
      g.paths[this.id] = this;
      g.items[this.id] = this;
      if (this.data == null) {
        this.data = new Object();
        this.data.id = this.id;
        _ref = g.gui.__folders;
        for (name in _ref) {
          folder = _ref[name];
          if (name === 'General') {
            continue;
          }
          _ref1 = folder.__controllers;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            controller = _ref1[_i];
            this.data[controller.property] = controller.rValue();
          }
        }
      }
      if (this.pk != null) {
        this.setPK(this.pk, false);
      }
      if (points != null) {
        this.loadPath(points);
      }
      return;
    }

    RPath.prototype.duplicate = function() {
      var copy;
      copy = new this.constructor(new Date(), this.getData(), null, this.pathOnPlanet());
      copy.save();
      return copy;
    };

    RPath.prototype.pathWidth = function() {
      return this.data.strokeWidth;
    };

    RPath.prototype.getBounds = function() {
      return this.controlPath.strokeBounds;
    };

    RPath.prototype.getDrawingBounds = function() {
      var _ref;
      return (_ref = this.drawing) != null ? _ref.strokeBounds : void 0;
    };

    RPath.prototype.moveBy = function(delta, userAction) {
      this.group.position.x += delta.x;
      this.group.position.y += delta.y;
      if (userAction) {
        g.defferedExecution(this.update, this.getPk());
      }
    };

    RPath.prototype.moveTo = function(position, userAction) {
      var bounds, delta;
      bounds = this.getBounds();
      delta = this.group.position.subtract(bounds.center);
      this.group.position = position.add(delta);
      if (userAction) {
        g.defferedExecution(this.update, this.getPk());
      }
      return position.add(delta);
    };

    RPath.prototype.projectToRaster = function(point) {
      return point.subtract(this.canvasRaster.bounds.topLeft);
    };

    RPath.prototype.prepareHitTest = function(fullySelected, strokeWidth) {
      var _ref;
      if (fullySelected == null) {
        fullySelected = true;
      }
      console.log("prepareHitTest");
      this.hitTestSelected = this.controlPath.selected;
      if (fullySelected) {
        this.hitTestFullySelected = this.controlPath.fullySelected;
        this.controlPath.fullySelected = true;
      } else {
        this.controlPath.selected = true;
      }
      this.hitTestControlPathVisible = this.controlPath.visible;
      this.controlPath.visible = true;
      if ((_ref = this.speedGroup) != null) {
        _ref.selected = true;
      }
      this.hitTestStrokeWidth = this.controlPath.strokeWidth;
      if (strokeWidth) {
        this.controlPath.strokeWidth = strokeWidth;
      }
    };

    RPath.prototype.finishHitTest = function(fullySelected) {
      var _ref;
      if (fullySelected == null) {
        fullySelected = true;
      }
      console.log("finishHitTest");
      if (fullySelected) {
        this.controlPath.fullySelected = this.hitTestFullySelected;
      }
      this.controlPath.selected = this.hitTestSelected;
      this.controlPath.visible = this.hitTestControlPathVisible;
      this.controlPath.strokeWidth = this.hitTestStrokeWidth;
      if ((_ref = this.speedGroup) != null) {
        _ref.selected = false;
      }
    };

    RPath.prototype.hitTest = function(point, hitOptions) {
      return this.selectionRectangle.hitTest(point);
    };

    RPath.prototype.performHitTest = function(point, hitOptions, fullySelected) {
      var hitResult;
      if (fullySelected == null) {
        fullySelected = true;
      }
      this.prepareHitTest(fullySelected, 1);
      hitResult = this.hitTest(point, hitOptions);
      this.finishHitTest(fullySelected);
      return hitResult;
    };

    RPath.prototype.updateSelectionRectangle = function() {
      var bounds, reset, _ref;
      reset = (this.selectionRectangleBounds == null) || this.controlPath.rotation === 0 && this.controlPath.scaling.x === 1 && this.controlPath.scaling.y === 1;
      if (reset) {
        this.selectionRectangleBounds = this.controlPath.bounds.clone();
      }
      bounds = this.selectionRectangleBounds.clone().expand(10 + this.pathWidth());
      if ((_ref = this.selectionRectangle) != null) {
        _ref.remove();
      }
      this.selectionRectangle = new Path.Rectangle(bounds);
      this.group.addChild(this.selectionRectangle);
      this.selectionRectangle.name = "selection rectangle";
      this.selectionRectangle.pivot = this.selectionRectangle.bounds.center;
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top));
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top - 25));
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top));
      if (!reset) {
        this.selectionRectangle.position = this.controlPath.position;
        this.selectionRectangle.rotation = this.controlPath.rotation;
        this.selectionRectangle.scaling = this.controlPath.scaling;
      }
      this.selectionRectangle.selected = true;
      this.selectionRectangle.controller = this;
      this.controlPath.pivot = this.selectionRectangle.pivot;
    };

    RPath.prototype.select = function(updateOptions) {
      if (updateOptions == null) {
        updateOptions = true;
      }
      if (this.controlPath == null) {
        return;
      }
      if (this.selectionRectangle != null) {
        return;
      }
      console.log("select");
      this.selectionRectangleRotation = null;
      this.selectionRectangleScale = null;
      this.updateSelectionRectangle();
      if (g.selectionGroup == null) {
        g.selectionGroup = new Group();
      }
      g.selectionGroup.name = 'selection group';
      g.selectionGroup.addChild(this.group);
      if (updateOptions) {
        g.updateParameters({
          tool: this.constructor,
          item: this
        }, true);
      }
      g.s = this;
    };

    RPath.prototype.deselect = function() {
      var _ref;
      console.log("deselect");
      if (this.selectionRectangle == null) {
        return;
      }
      if ((_ref = this.selectionRectangle) != null) {
        _ref.remove();
      }
      this.selectionRectangle = null;
      this.controlPath.visible = false;
      this.selectedSegment = null;
      this.rasterize();
    };

    RPath.prototype.rasterize = function() {};

    RPath.prototype.hitTestAndInitSelection = function(event, userAction) {
      var hitResult;
      hitResult = this.performHitTest(event.point, this.constructor.hitOptions);
      if (hitResult == null) {
        return null;
      }
      return this.initSelection(event, hitResult, userAction);
    };

    RPath.prototype.initSelection = function(event, hitResult, userAction) {
      var change;
      if (userAction == null) {
        userAction = true;
      }
      change = 'move';
      if (hitResult.type === 'segment') {
        if (hitResult.item === this.controlPath) {
          this.selectedSegment = hitResult.segment;
          change = 'segment';
        } else if (hitResult.item === this.selectionRectangle) {
          if (hitResult.segment.index >= 2 && hitResult.segment.index <= 4) {
            this.selectionRectangleRotation = event.point.subtract(this.selectionRectangle.bounds.center);
            change = 'rotation';
          } else {
            this.selectionRectangleScale = event.point.subtract(this.selectionRectangle.bounds.center).length;
            change = 'scale';
          }
        }
      }
      return change;
    };

    RPath.prototype.selectBegin = function(event, userAction) {
      var change, _ref;
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectBegin");
      this.changed = null;
      if (this.selectedSegment != null) {
        this.selectedSegment = null;
      }
      if (this.selectedHandle != null) {
        this.selectedHandle = null;
      }
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      this.selectionRectangleRotation = null;
      this.selectionRectangleScale = null;
      if (userAction) {
        this.select();
      }
      change = this.hitTestAndInitSelection(event, userAction);
      if (g.fastMode && change !== 'move') {
        g.hideOthers(this);
      }
      return change;
    };

    RPath.prototype.selectUpdate = function(event, userAction) {
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectUpdate");
    };

    RPath.prototype.selectEnd = function(event, userAction) {
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectEnd");
      this.selectionRectangleRotation = null;
      this.selectionRectangleScale = null;
      if (userAction && (this.changed != null)) {
        this.update('point');
      }
      this.changed = null;
      if (g.fastMode) {
        g.showAll(this);
      }
    };

    RPath.prototype.doubleClick = function(event, userAction) {
      if (userAction == null) {
        userAction = true;
      }
    };

    RPath.prototype.loadPath = function(points) {
      var i, point, _i, _len;
      for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
        point = points[i];
        if (i === 0) {
          this.createBegin(point, null, true);
        } else {
          this.createUpdate(point, null, true);
        }
      }
      if (points.length > 0) {
        this.createEnd(points.last(), null, true);
      }
      this.draw(null, true);
    };

    RPath.prototype.parameterChanged = function(update) {
      if (update == null) {
        update = true;
      }
      if (!this.drawing) {
        g.updateView();
      }
      if (this.previousBoundingBox == null) {
        this.previousBoundingBox = this.getDrawingBounds();
      }
      this.draw();
      if (update) {
        g.defferedExecution(this.update, this.getPk());
      }
    };

    RPath.prototype.addPath = function(path) {
      if (path == null) {
        path = new Path();
      }
      path.name = 'group path';
      path.controller = this;
      path.strokeColor = this.data.strokeColor;
      path.strokeWidth = this.data.strokeWidth;
      path.fillColor = this.data.fillColor;
      path.shadowOffset = new Point(this.data.shadowOffsetX, this.data.shadowOffsetY);
      path.shadowBlur = this.data.shadowBlur;
      path.shadowColor = this.data.shadowColor;
      this.drawing.addChild(path);
      return path;
    };

    RPath.prototype.initializeDrawing = function(createCanvas) {
      var bounds, canvas, position, _ref, _ref1, _ref2;
      if (createCanvas == null) {
        createCanvas = false;
      }
      if ((_ref = this.raster) != null) {
        _ref.remove();
      }
      this.raster = null;
      this.controlPath.strokeWidth = this.pathWidth();
      if ((_ref1 = this.drawing) != null) {
        _ref1.remove();
      }
      this.drawing = new Group();
      this.drawing.name = "drawing";
      this.drawing.strokeColor = this.data.strokeColor;
      this.drawing.strokeWidth = this.data.strokeWidth;
      this.drawing.fillColor = this.data.fillColor;
      this.drawing.insertBelow(this.controlPath);
      this.drawing.controlPath = this.controlPath;
      this.drawing.controller = this;
      this.group.addChild(this.drawing);
      if (createCanvas) {
        canvas = document.createElement("canvas");
        if (this.controlPath.length <= 1) {
          canvas.width = view.size.width;
          canvas.height = view.size.height;
          position = view.center;
        } else {
          bounds = this.getBounds();
          canvas.width = bounds.width;
          canvas.height = bounds.height;
          position = bounds.center;
        }
        if ((_ref2 = this.canvasRaster) != null) {
          _ref2.remove();
        }
        this.canvasRaster = new Raster(canvas, position);
        this.drawing.addChild(this.canvasRaster);
        this.context = this.canvasRaster.canvas.getContext("2d");
        this.context.strokeStyle = this.data.strokeColor;
        this.context.fillStyle = this.data.fillColor;
        this.context.lineWidth = this.data.strokeWidth;
      }
    };

    RPath.prototype.setAnimated = function(animated) {
      if (animated) {
        this.registerAnimation();
      } else {
        this.deregisterAnimation();
      }
    };

    RPath.prototype.registerAnimation = function() {
      var i;
      i = g.animatedItems.indexOf(this);
      if (i < 0) {
        g.animatedItems.push(this);
      }
    };

    RPath.prototype.deregisterAnimation = function() {
      var i;
      i = g.animatedItems.indexOf(this);
      if (i >= 0) {
        g.animatedItems.splice(i, 1);
      }
    };

    RPath.prototype.draw = function(simplified, loading) {
      if (simplified == null) {
        simplified = fasle;
      }
      if (loading == null) {
        loading = fasle;
      }
    };

    RPath.prototype.initialize = function() {};

    RPath.prototype.createBegin = function(point, event) {};

    RPath.prototype.createUpdate = function(point, event) {};

    RPath.prototype.createEnd = function(point, event) {
      this.initialize();
    };

    RPath.prototype.updateZIndex = function() {
      var i, path, _i, _len, _ref;
      if (this.date != null) {
        if (g.sortedPaths.length === 0) {
          g.sortedPaths.push(this);
        }
        _ref = g.sortedPaths;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          path = _ref[i];
          if (this.date > path.date) {
            g.sortedPaths.splice(i + 1, 0, this);
            this.insertAbove(path);
          }
        }
      }
    };

    RPath.prototype.insertAbove = function(path) {
      var _ref;
      this.controlPath.insertAbove(path.controlPath);
      if ((_ref = this.drawing) != null) {
        _ref.insertBelow(this.controlPath);
      }
    };

    RPath.prototype.getData = function() {
      return this.data;
    };

    RPath.prototype.getStringifiedData = function() {
      return JSON.stringify(this.getData());
    };

    RPath.prototype.planet = function() {
      return projectToPlanet(this.controlPath.segments[0].point);
    };

    RPath.prototype.prepareUpdate = function() {
      var p0, path;
      path = this.controlPath;
      if (path.segments.length < 2) {
        p0 = path.segments[0].point;
        path.add(new Point(p0.x + 1, p0.y));
      }
      if (g.pathOverlapsTwoPlanets(path)) {
        romanesco_alert("You can not create nor update a line in between two planets, this is not yet supported.", "info");
        return false;
      }
      return true;
    };

    RPath.prototype.save = function() {
      if (this.controlPath == null) {
        return;
      }
      if (!this.prepareUpdate()) {
        return;
      }
      Dajaxice.draw.savePath(this.save_callback, {
        'points': this.pathOnPlanet(),
        'pID': this.id,
        'planet': this.planet(),
        'object_type': this.constructor.rname,
        'data': this.getStringifiedData(),
        'bounds': this.getBounds()
      });
    };

    RPath.prototype.save_callback = function(result) {
      var _ref;
      g.checkError(result);
      if (result.pk == null) {
        return;
      }
      this.setPK(result.pk);
      if (!((_ref = this.data) != null ? _ref.animate : void 0)) {
        g.rasterizeArea(this.getDrawingBounds());
      }
    };

    RPath.prototype.update = function(type) {
      var rectangle, selectionHighlightVisible, speedGroupVisible, union, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      console.log("update: " + this.pk);
      if (this.pk == null) {
        return;
      }
      if (!this.prepareUpdate()) {
        return;
      }
      Dajaxice.draw.updatePath(this.updatePath_callback, {
        'pk': this.pk,
        'points': this.pathOnPlanet(),
        'planet': this.planet(),
        'data': this.getStringifiedData(),
        'bounds': this.getBounds()
      });
      if (!((_ref = this.data) != null ? _ref.animate : void 0)) {
        if (this.drawing == null) {
          this.draw();
        }
        selectionHighlightVisible = (_ref1 = this.selectionHighlight) != null ? _ref1.visible : void 0;
        if ((_ref2 = this.selectionHighlight) != null) {
          _ref2.visible = false;
        }
        speedGroupVisible = (_ref3 = this.speedGroup) != null ? _ref3.visible : void 0;
        if ((_ref4 = this.speedGroup) != null) {
          _ref4.visible = false;
        }
        rectangle = this.getDrawingBounds();
        if (this.previousBoundingBox != null) {
          union = rectangle.unite(this.previousBoundingBox);
          if (rectangle.intersects(this.previousBoundingBox) && union.area < this.previousBoundingBox.area * 2) {
            g.rasterizeArea(union);
          } else {
            g.rasterizeArea(rectangle);
            g.rasterizeArea(this.previousBoundingBox);
          }
          this.previousBoundingBox = null;
        } else {
          g.rasterizeArea(rectangle);
        }
        if ((_ref5 = this.selectionHighlight) != null) {
          _ref5.visible = selectionHighlightVisible;
        }
        if ((_ref6 = this.speedGroup) != null) {
          _ref6.visible = speedGroupVisible;
        }
      }
      this.changed = null;
    };

    RPath.prototype.updatePath_callback = function(result) {
      g.checkError(result);
    };

    RPath.prototype.getPk = function() {
      if (this.pk != null) {
        return this.pk;
      } else {
        return this.id;
      }
    };

    RPath.prototype.setPK = function(pk, updateRoom) {
      if (updateRoom == null) {
        updateRoom = true;
      }
      this.pk = pk;
      g.paths[pk] = this;
      g.items[pk] = this;
      delete g.paths[this.id];
      delete g.items[this.id];
      if (updateRoom) {
        g.chatSocket.emit("setPathPK", g.me, this.id, this.pk);
      }
    };

    RPath.prototype.remove = function() {
      this.deselect();
      this.deregisterAnimation();
      this.group.remove();
      this.controlPath = null;
      this.drawing = null;
      if (this.raster == null) {
        this.raster = null;
      }
      if (this.canvasRaster == null) {
        this.canvasRaster = null;
      }
      this.group = null;
      g.sortedPaths.remove(this);
      if (this.pk != null) {
        delete g.paths[this.pk];
        delete g.items[this.pk];
      } else {
        delete g.items[this.id];
        delete g.paths[this.id];
      }
    };

    RPath.prototype["delete"] = function() {
      var bounds;
      this.group.visible = false;
      bounds = this.getDrawingBounds();
      this.remove();
      g.updateView();
      g.rasterizeArea(bounds);
      if (this.pk == null) {
        return;
      }
      console.log(this.pk);
      Dajaxice.draw.deletePath(this.deletePath_callback, {
        pk: this.pk
      });
      this.pk = null;
    };

    RPath.prototype.deletePath_callback = function(result) {
      if (g.checkError(result)) {
        g.chatSocket.emit("delete path", result.pk);
      }
    };

    RPath.prototype.pathOnPlanet = function(controlSegments) {
      var p, planet, points, segment, _i, _len;
      if (controlSegments == null) {
        controlSegments = this.controlPath.segments;
      }
      points = [];
      planet = this.planet();
      for (_i = 0, _len = controlSegments.length; _i < _len; _i++) {
        segment = controlSegments[_i];
        p = projectToPosOnPlanet(segment.point, planet);
        points.push(pointToArray(p));
      }
      return points;
    };

    return RPath;

  })();

  this.RPath = RPath;

  PrecisePath = (function(_super) {
    __extends(PrecisePath, _super);

    PrecisePath.rname = 'Precise path';

    PrecisePath.rdescription = "This path offers precise controls, one can modify points along with their handles and their type.";

    PrecisePath.iconUrl = 'static/images/icons/inverted/editCurve.png';

    PrecisePath.iconAlt = 'edit curve';

    PrecisePath.hitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      selected: true,
      curves: true,
      handles: true,
      tolerance: 5
    };

    PrecisePath.secureStep = 25;

    PrecisePath.parameters = function() {
      var parameters;
      parameters = PrecisePath.__super__.constructor.parameters.call(this);
      parameters['General'].polygonMode = {
        type: 'checkbox',
        label: 'Polygon mode',
        "default": g.polygonMode,
        onChange: function(value) {
          return g.polygonMode = value;
        }
      };
      parameters['Edit curve'] = {
        smooth: {
          type: 'checkbox',
          label: 'Smooth',
          "default": false
        },
        pointType: {
          type: 'dropdown',
          label: 'Point type',
          values: ['smooth', 'corner', 'point'],
          "default": 'smooth',
          addController: true,
          onChange: function(value) {
            var item, _i, _len, _ref;
            _ref = g.selectedItems();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              if (typeof item.changeSelectedPoint === "function") {
                item.changeSelectedPoint(true, value);
              }
            }
          }
        },
        deletePoint: {
          type: 'button',
          label: 'Delete point',
          "default": function() {
            var item, _i, _len, _ref;
            _ref = g.selectedItems();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              if (typeof item.deleteSelectedPoint === "function") {
                item.deleteSelectedPoint();
              }
            }
          }
        },
        simplify: {
          type: 'button',
          label: 'Simplify',
          "default": function() {
            var item, _i, _len, _ref, _ref1;
            _ref = g.selectedItems();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              if ((_ref1 = item.controlPath) != null) {
                _ref1.simplify();
              }
              item.draw();
              item.update();
            }
          }
        }
      };
      return parameters;
    };

    function PrecisePath(date, data, pk, points) {
      this.date = date != null ? date : null;
      this.data = data != null ? data : null;
      this.pk = pk != null ? pk : null;
      if (points == null) {
        points = null;
      }
      PrecisePath.__super__.constructor.call(this, this.date, this.data, this.pk, points);
      this.data.polygonMode = g.polygonMode;
      return;
    }

    PrecisePath.prototype.loadPath = function(points) {
      var distanceMax, flattenedPath, i, index, point, recordedPoint, resultingPoint, time, _i, _j, _len, _ref;
      this.createBegin(posOnPlanetToProject(this.data.points[0], this.data.planet), null, true);
      _ref = this.data.points;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = _i += 4) {
        point = _ref[i];
        if (i > 0) {
          this.controlPath.add(posOnPlanetToProject(point, this.data.planet));
        }
        this.controlPath.lastSegment.handleIn = new Point(this.data.points[i + 1]);
        this.controlPath.lastSegment.handleOut = new Point(this.data.points[i + 2]);
        this.controlPath.lastSegment.rtype = this.data.points[i + 3];
      }
      if (points.length === 2) {
        this.controlPath.add(points[1]);
      }
      this.createEnd(posOnPlanetToProject(this.data.points[this.data.points.length - 4], this.data.planet), null, true);
      time = Date.now();
      flattenedPath = this.controlPath.copyTo(project);
      flattenedPath.flatten(this.constructor.secureStep);
      distanceMax = this.constructor.secureDistance * this.constructor.secureDistance;
      for (i = _j = 1; _j <= 10; i = ++_j) {
        index = Math.floor(Math.random() * points.length);
        recordedPoint = new Point(points[index]);
        resultingPoint = flattenedPath.segments[index].point;
        if (recordedPoint.getDistance(resultingPoint, true) > distanceMax) {
          flattenedPath.strokeColor = 'red';
          view.center = flattenedPath.bounds.center;
          console.log("Error: invalid path");
          return;
        }
      }
      flattenedPath.remove();
      console.log("Time to secure the path: " + ((Date.now() - time) / 1000) + " sec.");
    };

    PrecisePath.prototype.hitTest = function(point, hitOptions) {
      var hitResult, _ref, _ref1;
      if ((_ref = this.speedGroup) != null ? _ref.visible : void 0) {
        hitResult = (_ref1 = this.handleGroup) != null ? _ref1.hitTest(point) : void 0;
      }
      if (hitResult == null) {
        hitResult = this.selectionRectangle.hitTest(point);
      }
      if (hitResult == null) {
        hitResult = this.controlPath.hitTest(point, hitOptions);
      }
      return hitResult;
    };

    PrecisePath.prototype.initializeDrawing = function(createCanvas) {
      var _base;
      if (createCanvas == null) {
        createCanvas = false;
      }
      if ((_base = this.data).step == null) {
        _base.step = 20;
      }
      this.drawingOffset = 0;
      PrecisePath.__super__.initializeDrawing.call(this, createCanvas);
    };

    PrecisePath.prototype.drawBegin = function(createCanvas) {
      if (createCanvas == null) {
        createCanvas = false;
      }
      console.log("drawBegin");
      this.initializeDrawing(createCanvas);
      this.path = this.addPath();
      this.path.segments = this.controlPath.segments;
      this.path.selected = false;
    };

    PrecisePath.prototype.drawUpdate = function(offset, step) {
      console.log("drawUpdate");
      this.path.segments = this.controlPath.segments;
      this.path.selected = false;
    };

    PrecisePath.prototype.drawEnd = function() {
      this.path.segments = this.controlPath.segments;
      this.path.selected = false;
    };

    PrecisePath.prototype.checkUpdateDrawing = function(segment) {
      var controlPathOffset, step;
      step = this.data.step;
      controlPathOffset = segment.location.offset;
      if (this.drawingOffset + step > controlPathOffset) {
        this.drawUpdate(controlPathOffset, false);
      } else {
        while (this.drawingOffset + step < controlPathOffset) {
          this.drawingOffset += step;
          this.drawUpdate(this.drawingOffset, true);
        }
      }
    };

    PrecisePath.prototype.initializeControlPath = function(point) {
      this.group = new Group();
      this.group.name = "group";
      this.group.controller = this;
      this.controlPath = new Path();
      this.group.addChild(this.controlPath);
      this.controlPath.name = "controlPath";
      this.controlPath.controller = this;
      this.controlPath.strokeWidth = this.pathWidth();
      this.controlPath.strokeColor = g.selectionBlue;
      this.controlPath.strokeColor.alpha = 0.25;
      this.controlPath.strokeCap = 'round';
      this.controlPath.visible = false;
      this.controlPath.add(point);
    };

    PrecisePath.prototype.createBegin = function(point, event, loading) {
      if (loading == null) {
        loading = false;
      }
      PrecisePath.__super__.createBegin.call(this);
      if (loading) {
        this.initializeControlPath(point);
      } else {
        if (RLock.intersectPoint(point)) {
          return;
        }
        if (!this.data.polygonMode) {
          this.initializeControlPath(point);
          this.drawBegin();
        } else {
          if (this.controlPath == null) {
            this.initializeControlPath(point);
            this.controlPath.add(point);
            this.drawBegin();
          } else {
            this.controlPath.add(point);
          }
          this.controlPath.lastSegment.rtype = 'point';
        }
      }
    };

    PrecisePath.prototype.createUpdate = function(point, event, loading) {
      var lastSegment, previousSegment;
      if (loading == null) {
        loading = false;
      }
      if (!this.data.polygonMode) {
        if (this.inLockedArea) {
          return;
        }
        if (RLock.intersectPoint(point)) {
          this.inLockedArea = true;
          this.save();
          return;
        }
        this.controlPath.add(point);
        if (!loading) {
          this.checkUpdateDrawing(this.controlPath.lastSegment);
        }
      } else {
        lastSegment = this.controlPath.lastSegment;
        previousSegment = lastSegment.previous;
        previousSegment.rtype = 'smooth';
        previousSegment.handleOut = point.subtract(previousSegment.point);
        if (lastSegment !== this.controlPath.firstSegment) {
          previousSegment.handleIn = previousSegment.handleOut.multiply(-1);
        }
        lastSegment.handleIn = lastSegment.handleOut = null;
        lastSegment.point = point;
        this.draw(true);
      }
    };

    PrecisePath.prototype.createMove = function(event) {
      this.controlPath.lastSegment.point = event.point;
      this.draw(true);
    };

    PrecisePath.prototype.createEnd = function(point, event, loading) {
      if (loading == null) {
        loading = false;
      }
      if (this.data.polygonMode) {
        if (loading) {
          this.finishPath(loading);
        }
      } else {
        this.inLockedArea = false;
        if (!loading && this.controlPath.segments.length >= 2) {
          this.controlPath.simplify();
        }
        this.finishPath(loading);
      }
      PrecisePath.__super__.createEnd.call(this);
    };

    PrecisePath.prototype.finishPath = function(loading) {
      if (loading == null) {
        loading = false;
      }
      if (this.data.polygonMode && !loading) {
        this.controlPath.lastSegment.remove();
        this.controlPath.lastSegment.handleOut = null;
      }
      if (this.controlPath.segments.length < 2) {
        this.remove();
        return;
      }
      if (this.data.smooth) {
        this.controlPath.smooth();
      }
      if (!loading) {
        this.drawEnd();
        this.drawingOffset = 0;
      }
      this.draw(false, loading);
      this.rasterize();
    };

    PrecisePath.prototype.simplifiedModeOn = function() {
      var folder, folderName, name, parameter, _ref;
      this.previousData = {};
      _ref = this.constructor.parameters();
      for (folderName in _ref) {
        folder = _ref[folderName];
        for (name in folder) {
          parameter = folder[name];
          if ((parameter.simplified != null) && (this.data[name] != null)) {
            this.previousData[name] = this.data[name];
            this.data[name] = parameter.simplified;
          }
        }
      }
    };

    PrecisePath.prototype.simplifiedModeOff = function() {
      var folder, folderName, name, parameter, _ref;
      _ref = this.constructor.parameters();
      for (folderName in _ref) {
        folder = _ref[folderName];
        for (name in folder) {
          parameter = folder[name];
          if ((parameter.simplified != null) && (this.data[name] != null) && (this.previousData[name] != null)) {
            this.data[name] = this.previousData[name];
            delete this.previousData[name];
          }
        }
      }
    };

    PrecisePath.prototype.draw = function(simplified, loading) {
      var controlPathLength, error, nIteration, nf, offset, process, reminder, step, _ref;
      if (simplified == null) {
        simplified = false;
      }
      if (loading == null) {
        loading = false;
      }
      if (loading && !((_ref = this.data) != null ? _ref.animate : void 0)) {
        return;
      }
      if (this.controlPath.segments.length < 2) {
        return;
      }
      if (simplified) {
        this.simplifiedModeOn();
      }
      step = this.data.step;
      controlPathLength = this.controlPath.length;
      nf = controlPathLength / step;
      nIteration = Math.floor(nf);
      reminder = nf - nIteration;
      offset = reminder * step / 2;
      this.drawingOffset = 0;
      process = (function(_this) {
        return function() {
          var i, segment, _i, _len, _ref1;
          _this.drawBegin();
          _ref1 = _this.controlPath.segments;
          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
            segment = _ref1[i];
            if (i === 0) {
              continue;
            }
            _this.checkUpdateDrawing(segment, true);
          }
          _this.drawEnd();
        };
      })(this);
      if (!g.catchErrors) {
        process();
      } else {
        try {
          process();
        } catch (_error) {
          error = _error;
          console.error(error.stack);
          console.error(error);
          throw error;
        }
      }
      if (simplified) {
        this.simplifiedModeOff();
      } else {
        this.rasterize();
      }
    };

    PrecisePath.prototype.pathOnPlanet = function() {
      var flatennedPath;
      flatennedPath = this.controlPath.copyTo(project);
      flatennedPath.flatten(this.constructor.secureStep);
      flatennedPath.remove();
      return PrecisePath.__super__.pathOnPlanet.call(this, flatennedPath.segments);
    };

    PrecisePath.prototype.getData = function() {
      var segment, _i, _len, _ref;
      this.data.planet = projectToPlanet(this.controlPath.segments[0].point);
      this.data.points = [];
      _ref = this.controlPath.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        this.data.points.push(projectToPosOnPlanet(segment.point));
        this.data.points.push(g.pointToObj(segment.handleIn));
        this.data.points.push(g.pointToObj(segment.handleOut));
        this.data.points.push(segment.rtype);
      }
      return this.data;
    };

    PrecisePath.prototype.select = function(updateOptions) {
      if (updateOptions == null) {
        updateOptions = true;
      }
      if (this.controlPath == null) {
        return;
      }
      if (this.selectionRectangle != null) {
        return;
      }
      this.index = this.controlPath.index;
      this.controlPath.bringToFront();
      this.controlPath.selected = true;
      PrecisePath.__super__.select.call(this, updateOptions);
      if (!this.data.smooth) {
        this.controlPath.fullySelected = true;
      }
    };

    PrecisePath.prototype.deselect = function() {
      var _ref;
      this.controlPath.selected = false;
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      PrecisePath.__super__.deselect.call(this);
    };

    PrecisePath.prototype.highlightSelectedPoint = function() {
      var offset, point, _base, _ref, _ref1;
      if (!this.controlPath.selected) {
        return;
      }
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      if (this.selectedSegment == null) {
        return;
      }
      point = this.selectedSegment.point;
      if ((_base = this.selectedSegment).rtype == null) {
        _base.rtype = 'smooth';
      }
      switch (this.selectedSegment.rtype) {
        case 'smooth':
          this.selectionHighlight = new Path.Circle(point, 5);
          break;
        case 'corner':
          offset = new Point(5, 5);
          this.selectionHighlight = new Path.Rectangle(point.subtract(offset), point.add(offset));
          break;
        case 'point':
          this.selectionHighlight = new Path.RegularPolygon(point, 3, 5);
      }
      this.selectionHighlight.name = 'selection highlight';
      this.selectionHighlight.controller = this;
      this.selectionHighlight.strokeColor = g.selectionBlue;
      this.selectionHighlight.strokeWidth = 1;
      this.group.addChild(this.selectionHighlight);
      if (((_ref1 = this.parameterControllers) != null ? _ref1.pointType : void 0) != null) {
        g.setControllerValue(this.parameterControllers.pointType, null, this.selectedSegment.rtype, this);
      }
    };

    PrecisePath.prototype.initSelection = function(event, hitResult, userAction) {
      var change, specialKey, _ref;
      if (userAction == null) {
        userAction = true;
      }
      specialKey = g.specialKey(event);
      this.selectedSegment = null;
      this.selectedHandle = null;
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      change = 'move';
      if (hitResult.type === 'segment') {
        if (specialKey) {
          hitResult.segment.remove();
          this.changed = change = 'deleted point';
        } else {
          if (hitResult.item === this.controlPath) {
            this.selectedSegment = hitResult.segment;
            change = 'segment';
          } else if (hitResult.item === this.selectionRectangle) {
            if (hitResult.segment.index >= 2 && hitResult.segment.index <= 4) {
              this.selectionRectangleRotation = 0;
              change = 'rotation';
            } else {
              this.selectionRectangleScale = event.point.subtract(this.selectionRectangle.bounds.center).length / this.controlPath.scaling.x;
              change = 'scale';
            }
          }
        }
      }
      if (!this.data.smooth) {
        if (hitResult.type === "handle-in") {
          this.selectedHandle = hitResult.segment.handleIn;
          this.selectedSegment = hitResult.segment;
          change = 'handle-in';
        } else if (hitResult.type === "handle-out") {
          this.selectedHandle = hitResult.segment.handleOut;
          this.selectedSegment = hitResult.segment;
          change = 'handle-out';
        }
      }
      if (userAction) {
        this.highlightSelectedPoint();
      }
      return change;
    };

    PrecisePath.prototype.selectUpdate = function(event, userAction) {
      var ratio, rotation, scaling, _ref;
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectUpdate");
      if (this.previousBoundingBox == null) {
        this.previousBoundingBox = this.getDrawingBounds();
      }
      if (!this.drawing) {
        g.updateView();
      }
      if (this.selectedHandle != null) {
        this.selectedHandle.x += event.delta.x;
        this.selectedHandle.y += event.delta.y;
        if (this.selectedSegment.rtype === 'smooth' || (this.selectedSegment.rtype == null)) {
          if (this.selectedHandle === this.selectedSegment.handleOut && !this.selectedSegment.handleIn.isZero()) {
            this.selectedSegment.handleIn = !event.modifiers.shift ? this.selectedSegment.handleOut.normalize().multiply(-this.selectedSegment.handleIn.length) : this.selectedSegment.handleOut.multiply(-1);
          }
          if (this.selectedHandle === this.selectedSegment.handleIn && !this.selectedSegment.handleOut.isZero()) {
            this.selectedSegment.handleOut = !event.modifiers.shift ? this.selectedSegment.handleIn.normalize().multiply(-this.selectedSegment.handleOut.length) : this.selectedSegment.handleIn.multiply(-1);
          }
        }
        this.updateSelectionRectangle();
        this.draw(true);
        this.changed = 'moved handle';
      } else if (this.selectedSegment != null) {
        this.selectedSegment.point.x += event.delta.x;
        this.selectedSegment.point.y += event.delta.y;
        this.updateSelectionRectangle();
        this.draw(true);
        this.changed = 'moved point';
      } else if (this.selectionRectangleRotation != null) {
        rotation = event.point.subtract(this.selectionRectangle.bounds.center).angle + 90;
        this.controlPath.rotation = rotation;
        this.selectionRectangle.rotation = rotation;
        this.draw(true);
        this.changed = 'rotated';
      } else if (this.selectionRectangleScale != null) {
        ratio = event.point.subtract(this.selectionRectangle.bounds.center).length / this.selectionRectangleScale;
        scaling = new Point(ratio, ratio);
        this.controlPath.scaling = scaling;
        this.selectionRectangle.scaling = scaling;
        this.draw(true);
        this.changed = 'scaled';
      } else {
        this.group.position.x += event.delta.x;
        this.group.position.y += event.delta.y;
        this.updateSelectionRectangle();
        if (!this.drawing) {
          this.draw(false);
        }
        this.changed = 'moved';
      }
      console.log(this.changed);
      if (userAction || (this.selectionRectangle != null)) {
        if ((_ref = this.selectionHighlight) != null) {
          _ref.position = this.selectedSegment.point;
        }
      }
    };

    PrecisePath.prototype.selectEnd = function(event, userAction) {
      var _ref;
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectEnd");
      if (userAction || (this.selectionRectangle != null)) {
        if ((_ref = this.selectionHighlight) != null) {
          _ref.position = this.selectedSegment.point;
        }
      }
      this.selectedHandle = null;
      if (this.data.smooth) {
        this.controlPath.smooth();
      }
      if ((this.changed != null) && this.changed !== 'moved') {
        this.draw();
      }
      PrecisePath.__super__.selectEnd.call(this, event, userAction);
    };

    PrecisePath.prototype.smoothPoint = function(segment, offset) {
      var tangent;
      segment.rtype = 'smooth';
      segment.linear = false;
      if (offset == null) {
        offset = segment.location.offset;
      }
      tangent = segment.path.getTangentAt(offset);
      if (segment.previous != null) {
        segment.handleIn = tangent.multiply(-0.25);
      }
      if (segment.next != null) {
        segment.handleOut = tangent.multiply(+0.25);
      }
    };

    PrecisePath.prototype.doubleClick = function(event, userAction) {
      var hitCurve, hitResult, location, point, segment, specialKey;
      if (userAction == null) {
        userAction = true;
      }
      specialKey = g.specialKey(event);
      point = userAction ? view.viewToProject(new Point(event.pageX, event.pageY)) : event.point;
      hitResult = this.performHitTest(point, this.constructor.hitOptions);
      if (hitResult == null) {
        return;
      }
      hitCurve = hitResult.type === 'stroke' || hitResult.type === 'curve';
      if (hitResult.type === 'segment') {
        segment = hitResult.segment;
        this.selectedSegment = segment;
        switch (segment.rtype) {
          case 'smooth':
          case null:
          case void 0:
            segment.rtype = 'corner';
            break;
          case 'corner':
            segment.rtype = 'point';
            segment.linear = true;
            this.draw();
            break;
          case 'point':
            this.deletePoint(segment);
            break;
          default:
            console.log("segment.rtype not known.");
        }
      } else if (hitCurve && !specialKey) {
        location = hitResult.location;
        segment = hitResult.item.insert(location.index + 1, point);
        if (userAction && !this.data.smooth) {
          segment.selected = true;
        }
        this.selectedSegment = segment;
        this.smoothPoint(segment, location.offset);
      }
      if (userAction) {
        this.highlightSelectedPoint();
      }
      if (hitResult.type === 'segment' || (hitCurve && !specialKey)) {
        if (this.data.smooth) {
          this.controlPath.smooth();
        }
        if (userAction) {
          this.update('point');
        }
      }
    };

    PrecisePath.prototype.deletePoint = function(segment) {
      if (!segment) {
        return;
      }
      this.selectedSegment = segment.next != null ? segment.next : segment.previous;
      if (this.selectedSegment) {
        this.selectionHighlight.position = this.selectedSegment.point;
      }
      segment.remove();
      if (this.controlPath.segments.length <= 1) {
        this["delete"]();
        return;
      }
      if (this.data.smooth) {
        this.controlPath.smooth();
      }
      this.draw();
      view.draw();
    };

    PrecisePath.prototype.deleteSelectedPoint = function(userAction) {
      if (userAction == null) {
        userAction = true;
      }
      this.deletePoint(this.selectedSegment);
      if ((g.me != null) && userAction) {
        g.chatSocket.emit("parameter change", g.me, this.pk, "deleteSelectedPoint", null, "rFunction");
      }
    };

    PrecisePath.prototype.changeSelectedPoint = function(userAction, value) {
      if (userAction == null) {
        userAction = true;
      }
      if (this.selectedSegment == null) {
        return;
      }
      if (this.data.smooth) {
        return;
      }
      this.selectedSegment.rtype = value;
      switch (value) {
        case 'corner':
          if (this.selectedSegment.linear = true) {
            this.selectedSegment.linear = false;
            this.selectedSegment.handleIn = this.selectedSegment.previous.point.subtract(this.selectedSegment.point).multiply(0.5);
            this.selectedSegment.handleOut = this.selectedSegment.next.point.subtract(this.selectedSegment.point).multiply(0.5);
          }
          break;
        case 'point':
          this.selectedSegment.linear = true;
          break;
        case 'smooth':
          this.smoothPoint(this.selectedSegment);
      }
      this.highlightSelectedPoint();
      if ((g.me != null) && userAction) {
        g.chatSocket.emit("parameter change", g.me, this.pk, "changeSelectedPoint", value, "rFunction");
      }
    };

    PrecisePath.prototype.parameterChanged = function(update) {
      var segment, _i, _len, _ref;
      if (update == null) {
        update = true;
      }
      switch (this.changed) {
        case 'smooth':
          if (this.data.smooth) {
            this.controlPath.smooth();
            this.controlPath.fullySelected = false;
            this.controlPath.selected = true;
            _ref = this.controlPath.segments;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              segment = _ref[_i];
              segment.rtype = 'smooth';
            }
          } else {
            this.controlPath.fullySelected = true;
          }
      }
      return PrecisePath.__super__.parameterChanged.call(this, update);
    };

    PrecisePath.prototype.remove = function() {
      var _ref, _ref1;
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      if ((_ref1 = this.canvasRaster) != null) {
        _ref1.remove();
      }
      this.canvasRaster = null;
      return PrecisePath.__super__.remove.call(this);
    };

    return PrecisePath;

  })(RPath);

  this.PrecisePath = PrecisePath;

  this.pathClasses = [];

  this.pathClasses.push(this.PrecisePath);

  SpeedPath = (function(_super) {
    __extends(SpeedPath, _super);

    function SpeedPath() {
      return SpeedPath.__super__.constructor.apply(this, arguments);
    }

    SpeedPath.rname = 'Speed path';

    SpeedPath.rdescription = "This path offers speed.";

    SpeedPath.iconUrl = null;

    SpeedPath.iconAlt = null;

    SpeedPath.maxSpeed = 200;

    SpeedPath.speedStep = 20;

    SpeedPath.secureStep = 25;

    SpeedPath.parameters = function() {
      var parameters;
      parameters = SpeedPath.__super__.constructor.parameters.call(this);
      parameters['Edit curve'].showSpeed = {
        type: 'checkbox',
        label: 'Show speed',
        value: true
      };
      return parameters;
    };

    SpeedPath.prototype.initializeDrawing = function(createCanvas) {
      if (createCanvas == null) {
        createCanvas = false;
      }
      this.speedOffset = 0;
      SpeedPath.__super__.initializeDrawing.call(this, createCanvas);
    };

    SpeedPath.prototype.loadPath = function(points) {
      if (this.data == null) {
        this.data = {};
      }
      this.speeds = this.data.speeds || [];
      SpeedPath.__super__.loadPath.call(this, points);
    };

    SpeedPath.prototype.checkUpdateDrawing = function(segment, isDrawingEverything) {
      var controlPathOffset, currentSpeed, f, previousControlPathOffset, previousSpeed, speed, step;
      if (isDrawingEverything == null) {
        isDrawingEverything = false;
      }
      if (isDrawingEverything) {
        SpeedPath.__super__.checkUpdateDrawing.call(this, segment);
        return;
      }
      step = this.data.step;
      controlPathOffset = segment.location.offset;
      previousControlPathOffset = segment.previous != null ? segment.previous.location.offset : 0;
      previousSpeed = this.speeds.length > 0 ? this.speeds.pop() : 0;
      currentSpeed = controlPathOffset - previousControlPathOffset;
      while (this.speedOffset + this.constructor.speedStep < controlPathOffset) {
        this.speedOffset += this.constructor.speedStep;
        f = (this.speedOffset - previousControlPathOffset) / currentSpeed;
        speed = previousSpeed * (1 - f) + currentSpeed * f;
        this.speeds.push(Math.min(speed, this.constructor.maxSpeed));
      }
      this.speeds.push(Math.min(currentSpeed, this.constructor.maxSpeed));
      SpeedPath.__super__.checkUpdateDrawing.call(this, segment);
    };

    SpeedPath.prototype.createBegin = function(point, event, loading) {
      if (loading == null) {
        loading = false;
      }
      if (!loading) {
        this.speeds = (this.data.polygonMode ? [this.constructor.maxSpeed / 3] : []);
      }
      SpeedPath.__super__.createBegin.call(this, point, event, loading);
    };

    SpeedPath.prototype.createEnd = function(point, event, loading) {
      if (loading == null) {
        loading = false;
      }
      SpeedPath.__super__.createEnd.call(this, point, event, loading);
    };

    SpeedPath.prototype.computeSpeed = function() {
      var controlPathLength, currentAverageSpeed, currentOffset, distance, distances, f, i, interpolation, nextOffset, offset, point, pointOffset, previousDistance, previousOffset, previousPointOffset, previousSpeed, segment, speed, step, _i, _j, _len, _len1, _ref;
      step = this.constructor.speedStep;
      distances = [];
      controlPathLength = this.controlPath.length;
      currentOffset = step;
      segment = this.controlPath.firstSegment;
      distance = segment.point.getDistance(segment.next.point);
      distances.push({
        speed: distance,
        offset: 0
      });
      previousDistance = 0;
      pointOffset = 0;
      previousPointOffset = 0;
      _ref = this.controlPath.segments;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        segment = _ref[i];
        if (i === 0) {
          continue;
        }
        point = segment.point;
        previousDistance = distance;
        distance = point.getDistance(segment.previous.point);
        previousPointOffset = pointOffset;
        pointOffset += distance;
        while (pointOffset > currentOffset) {
          f = (currentOffset - previousPointOffset) / distance;
          interpolation = previousDistance * (1 - f) + distance * f;
          distances.push({
            speed: interpolation,
            offset: currentOffset
          });
          currentOffset += step;
        }
        distances.push({
          speed: distance,
          offset: pointOffset
        });
      }
      distances.push({
        speed: distance,
        offset: currentOffset
      });
      this.speeds = [];
      nextOffset = step;
      speed = distances.first().speed;
      previousSpeed = speed;
      this.speeds.push(speed);
      offset = 0;
      previousOffset = offset;
      currentAverageSpeed = 0;
      for (i = _j = 0, _len1 = distances.length; _j < _len1; i = ++_j) {
        distance = distances[i];
        if (i === 0) {
          continue;
        }
        previousSpeed = speed;
        speed = distance.speed;
        previousOffset = offset;
        offset = distance.offset;
        currentAverageSpeed += ((speed + previousSpeed) / 2.0) * (offset - previousOffset) / step;
        if (offset === nextOffset) {
          this.speeds.push(Math.min(currentAverageSpeed, this.constructor.maxSpeed));
          currentAverageSpeed = 0;
          nextOffset += step;
        }
      }
    };

    SpeedPath.prototype.showSpeed = function() {
      var _ref, _ref1;
      if ((_ref = this.speedGroup) != null) {
        _ref.visible = this.data.showSpeed;
      }
      if ((this.speeds == null) || !this.data.showSpeed) {
        return;
      }
      if ((_ref1 = this.speedGroup) != null) {
        _ref1.bringToFront();
      }
    };

    SpeedPath.prototype.updateSpeed = function() {
      var alreadyExists, controlPathLength, handle, handlePoint, i, j, normal, normalNormalized, o, offset, point, s, speed, speedCurve, speedHandle, speedHandles, speedHandlesLengthM1, step, _i, _j, _len, _ref, _ref1, _ref2;
      if ((_ref = this.speedGroup) != null) {
        _ref.visible = this.data.showSpeed;
      }
      if ((this.speeds == null) || !this.data.showSpeed) {
        return;
      }
      step = this.constructor.speedStep;
      alreadyExists = this.speedGroup != null;
      if (alreadyExists) {
        this.speedGroup.bringToFront();
        speedCurve = this.speedGroup.firstChild;
      } else {
        this.speedGroup = new Group();
        this.speedGroup.name = "speed group";
        this.speedGroup.strokeWidth = 1;
        this.speedGroup.strokeColor = selectionBlue;
        this.speedGroup.controller = this;
        this.group.addChild(this.speedGroup);
        speedCurve = new Path();
        speedCurve.name = "speed curve";
        speedCurve.strokeWidth = 1;
        speedCurve.strokeColor = selectionBlue;
        speedCurve.controller = this;
        this.speedGroup.addChild(speedCurve);
        this.handleGroup = new Group();
        this.handleGroup.name = "speed handle group";
        this.speedGroup.addChild(this.handleGroup);
      }
      speedHandles = this.handleGroup.children;
      offset = 0;
      controlPathLength = this.controlPath.length;
      while ((this.speeds.length - 1) * step < controlPathLength) {
        this.speeds.push(this.speeds.last());
      }
      i = 0;
      _ref1 = this.speeds;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        speed = _ref1[i];
        offset = i > 0 ? i * step : 0.1;
        o = offset < controlPathLength ? offset : controlPathLength - 0.1;
        point = this.controlPath.getPointAt(o);
        normalNormalized = this.controlPath.getNormalAt(o).normalize();
        normal = normalNormalized.multiply(this.speeds[i]);
        handlePoint = point.add(normal);
        if (alreadyExists && i < speedCurve.segments.length) {
          speedCurve.segments[i].point = handlePoint;
          speedHandles[i].position = handlePoint;
          speedHandles[i].rsegment.firstSegment.point = point;
          speedHandles[i].rsegment.lastSegment.point = handlePoint;
          speedHandles[i].rnormal = normalNormalized;
        } else {
          speedCurve.add(handlePoint);
          s = new Path();
          s.name = 'speed segment';
          s.strokeWidth = 1;
          s.strokeColor = selectionBlue;
          s.add(point);
          s.add(handlePoint);
          s.controller = this;
          this.speedGroup.addChild(s);
          handle = new Path.Rectangle(handlePoint.subtract(2), 4);
          handle.name = 'speed handle';
          handle.strokeWidth = 1;
          handle.strokeColor = selectionBlue;
          handle.fillColor = 'white';
          handle.rnormal = normalNormalized;
          handle.rindex = i;
          handle.rsegment = s;
          handle.controller = this;
          this.handleGroup.addChild(handle);
        }
        if (offset > controlPathLength) {
          break;
        }
      }
      if (offset > controlPathLength && i + 1 <= speedHandles.length - 1) {
        speedHandlesLengthM1 = speedHandles.length - 1;
        for (j = _j = _ref2 = i + 1; _ref2 <= speedHandlesLengthM1 ? _j <= speedHandlesLengthM1 : _j >= speedHandlesLengthM1; j = _ref2 <= speedHandlesLengthM1 ? ++_j : --_j) {
          speedHandle = this.handleGroup.lastChild;
          speedHandle.rsegment.remove();
          speedHandle.remove();
          speedCurve.lastSegment.remove();
        }
      }
    };

    SpeedPath.prototype.speedAt = function(offset) {
      var f, i;
      f = offset % this.constructor.speedStep;
      i = (offset - f) / this.constructor.speedStep;
      f /= this.constructor.speedStep;
      if (this.speeds != null) {
        if (i < this.speeds.length - 1) {
          return this.speeds[i] * (1 - f) + this.speeds[i + 1] * f;
        } else {
          return this.speeds.last();
        }
      } else {
        this.constructor.maxSpeed / 2;
      }
    };

    SpeedPath.prototype.draw = function(simplified, loading) {
      if (simplified == null) {
        simplified = false;
      }
      if (loading == null) {
        loading = false;
      }
      this.speedOffset = 0;
      SpeedPath.__super__.draw.call(this, simplified, loading);
      if (this.controlPath.selected) {
        this.updateSpeed();
      }
    };

    SpeedPath.prototype.getData = function() {
      var data;
      data = jQuery.extend({}, SpeedPath.__super__.getData.call(this));
      data.speeds = (this.speeds != null) && (this.handleGroup != null) ? this.speeds.slice(0, this.handleGroup.children.length + 1) : this.speeds;
      return data;
    };

    SpeedPath.prototype.select = function(updateOptions) {
      var _ref;
      if (updateOptions == null) {
        updateOptions = true;
      }
      if (this.selectionRectangle != null) {
        return;
      }
      SpeedPath.__super__.select.call(this, updateOptions);
      this.showSpeed();
      if (this.data.showSpeed) {
        if (this.speedGroup == null) {
          this.updateSpeed();
        }
        if ((_ref = this.speedGroup) != null) {
          _ref.visible = true;
        }
      }
    };

    SpeedPath.prototype.deselect = function() {
      var _ref;
      if ((_ref = this.speedGroup) != null) {
        _ref.visible = false;
      }
      SpeedPath.__super__.deselect.call(this);
    };

    SpeedPath.prototype.initSelection = function(event, hitResult, userAction) {
      var change, _ref;
      if (userAction == null) {
        userAction = true;
      }
      if ((_ref = this.speedSelectionHighlight) != null) {
        _ref.remove();
      }
      this.speedSelectionHighlight = null;
      if (hitResult.item.name === "speed handle") {
        this.selectedSpeedHandle = hitResult.item;
        change = 'speed handle';
        return change;
      }
      return SpeedPath.__super__.initSelection.call(this, event, hitResult, userAction);
    };

    SpeedPath.prototype.selectUpdate = function(event, userAction) {
      var delta, handle, handlePosition, handleToPoint, handlei, i, index, influence, influenceFactor, max, maxSpeed, n, newHandleToPoint, projection, projectionLength, sign, _i, _ref, _ref1;
      if (userAction == null) {
        userAction = true;
      }
      if (this.previousBoundingBox == null) {
        this.previousBoundingBox = this.getDrawingBounds();
      }
      if (!this.drawing) {
        g.updateView();
      }
      if (this.selectedSpeedHandle == null) {
        SpeedPath.__super__.selectUpdate.call(this, event, userAction);
      } else {
        if ((_ref = this.speedSelectionHighlight) != null) {
          _ref.remove();
        }
        maxSpeed = this.constructor.maxSpeed;
        this.speedSelectionHighlight = new Path();
        this.speedSelectionHighlight.name = 'speed selection highlight';
        this.speedSelectionHighlight.strokeWidth = 1;
        this.speedSelectionHighlight.strokeColor = 'blue';
        this.speedGroup.addChild(this.speedSelectionHighlight);
        handle = this.selectedSpeedHandle;
        handlePosition = handle.bounds.center;
        handleToPoint = event.point.subtract(handlePosition);
        projection = handleToPoint.project(handle.rnormal);
        projectionLength = projection.length;
        sign = Math.sign(projection.x) === Math.sign(handle.rnormal.x) && Math.sign(projection.y) === Math.sign(handle.rnormal.y);
        sign = sign ? 1 : -1;
        this.speeds[handle.rindex] += sign * projectionLength;
        if (this.speeds[handle.rindex] < 0) {
          this.speeds[handle.rindex] = 0;
        } else if (this.speeds[handle.rindex] > maxSpeed) {
          this.speeds[handle.rindex] = maxSpeed;
        }
        newHandleToPoint = event.point.subtract(handle.position.add(projection));
        influenceFactor = newHandleToPoint.length / (this.constructor.speedStep * 3);
        max = g.gaussian(0, influenceFactor, 0);
        i = 1;
        influence = 1;
        while (influence > 0.1 && i < 20) {
          influence = g.gaussian(0, influenceFactor, i) / max;
          delta = projectionLength * influence;
          for (n = _i = -1; _i <= 1; n = _i += 2) {
            index = handle.rindex + n * i;
            if (index >= 0 && index < this.handleGroup.children.length) {
              handlei = this.handleGroup.children[index];
              this.speeds[index] += sign * delta;
              if (this.speeds[index] < 0) {
                this.speeds[index] = 0;
              } else if (this.speeds[index] > maxSpeed) {
                this.speeds[index] = maxSpeed;
              }
            }
          }
          i++;
        }
        this.speedSelectionHighlight.strokeColor.hue -= Math.min(240 * (influenceFactor / 10), 240);
        this.speedSelectionHighlight.add(handle.position.add(projection));
        this.speedSelectionHighlight.add(event.point);
        this.draw(true);
        this.changed = 'speed handle moved';
        if (userAction || (this.selectionRectangle != null)) {
          if ((_ref1 = this.selectionHighlight) != null) {
            _ref1.position = this.selectedSegment.point;
          }
        }
      }
    };

    SpeedPath.prototype.selectEnd = function(event, userAction) {
      var _ref;
      if (userAction == null) {
        userAction = true;
      }
      this.selectedSpeedHandle = null;
      if ((_ref = this.speedSelectionHighlight) != null) {
        _ref.remove();
      }
      this.speedSelectionHighlight = null;
      SpeedPath.__super__.selectEnd.call(this, event, userAction);
    };

    SpeedPath.prototype.remove = function() {
      var _ref;
      if ((_ref = this.speedGroup) != null) {
        _ref.remove();
      }
      this.speedGroup = null;
      SpeedPath.__super__.remove.call(this);
    };

    return SpeedPath;

  })(PrecisePath);

  this.SpeedPath = SpeedPath;

  ThicknessPath = (function(_super) {
    __extends(ThicknessPath, _super);

    function ThicknessPath() {
      return ThicknessPath.__super__.constructor.apply(this, arguments);
    }

    ThicknessPath.rname = 'Thickness path';

    ThicknessPath.rdescription = "The stroke width is function of the drawing speed: the faster the wider.";

    ThicknessPath.iconUrl = 'static/images/icons/inverted/rollerBrush.png';

    ThicknessPath.iconAlt = 'roller brush';

    ThicknessPath.parameters = function() {
      var parameters;
      parameters = ThicknessPath.__super__.constructor.parameters.call(this);
      parameters['Style'].strokeWidth["default"] = 0;
      parameters['Style'].strokeColor.defaultCheck = false;
      parameters['Style'].fillColor.defaultCheck = true;
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 30,
        max: 300,
        "default": 30,
        simplified: 30,
        step: 1
      };
      parameters['Parameters'].trackWidth = {
        type: 'slider',
        label: 'Track width',
        min: 1,
        max: 10,
        "default": 2
      };
      return parameters;
    };

    ThicknessPath.prototype.pathWidth = function() {
      return this.constructor.maxSpeed * this.data.trackWidth / 2;
    };

    ThicknessPath.prototype.drawBegin = function() {
      this.initializeDrawing(false);
      this.path = this.addPath();
      this.path.add(this.controlPath.firstSegment.point);
    };

    ThicknessPath.prototype.drawUpdate = function(offset, step) {
      var bottom, delta, normal, point, speed, top;
      point = this.controlPath.getPointAt(offset);
      normal = this.controlPath.getNormalAt(offset).normalize();
      if (!step) {
        if (this.path.segments.length <= 1) {
          return;
        }
        this.path.firstSegment.point = point;
        return;
      }
      speed = this.speedAt(offset);
      delta = normal.multiply(speed * this.data.trackWidth / 2);
      top = point.add(delta);
      bottom = point.subtract(delta);
      this.path.firstSegment.remove();
      this.path.add(top);
      this.path.insert(0, bottom);
      this.path.insert(0, point);
      this.path.smooth();
    };

    ThicknessPath.prototype.drawEnd = function() {
      this.path.add(this.controlPath.lastSegment.point);
      this.path.closed = true;
      this.path.smooth();
      this.path.selected = false;
    };

    return ThicknessPath;

  })(SpeedPath);

  this.ThicknessPath = ThicknessPath;

  this.pathClasses.push(this.ThicknessPath);

  Meander = (function(_super) {
    __extends(Meander, _super);

    function Meander() {
      return Meander.__super__.constructor.apply(this, arguments);
    }

    Meander.rname = 'Meander';

    Meander.rdescription = 'As Karl Kerenyi pointed out, "the meander is the figure of a labyrinth in linear form". \nA meander or meandros (Greek: ) is a decorative border constructed from a continuous line, shaped into a repeated motif.\nSuch a design is also called the Greek fret or Greek key design, although these are modern designations.\n(source: http://en.wikipedia.org/wiki/Meander_(art))';

    Meander.iconUrl = 'static/images/icons/inverted/squareSpiral.png';

    Meander.iconAlt = 'square spiral';

    Meander.parameters = function() {
      var parameters;
      parameters = Meander.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 10,
        max: 100,
        "default": 20,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].thickness = {
        type: 'slider',
        label: 'Thickness',
        min: 1,
        max: 30,
        "default": 5,
        step: 1
      };
      parameters['Parameters'].rsmooth = {
        type: 'checkbox',
        label: 'Smooth',
        "default": false
      };
      return parameters;
    };

    Meander.prototype.pathWidth = function() {
      return 3 * (this.data.thickness + this.data.step + 2 * this.data.strokeWidth);
    };

    Meander.prototype.drawBegin = function() {
      this.initializeDrawing(false);
      this.line = this.addPath();
      this.spiral = this.addPath();
    };

    Meander.prototype.drawUpdate = function(offset, step) {
      var normal, p1, p2, p3, p4, p5, p6, p7, p8, p9, point, tangent;
      if (!step) {
        return;
      }
      point = this.controlPath.getPointAt(offset);
      normal = this.controlPath.getNormalAt(offset).normalize();
      tangent = normal.rotate(90);
      this.line.add(point);
      this.spiral.add(point.add(normal.multiply(this.data.thickness)));
      p1 = point.add(normal.multiply(this.data.step));
      this.spiral.add(p1);
      p2 = p1.add(tangent.multiply(this.data.step - this.data.thickness));
      this.spiral.add(p2);
      p3 = p2.add(normal.multiply(-(this.data.step - 2 * this.data.thickness)));
      this.spiral.add(p3);
      p4 = p3.add(tangent.multiply(-(this.data.step - 3 * this.data.thickness)));
      this.spiral.add(p4);
      p5 = p4.add(normal.multiply(this.data.thickness));
      this.spiral.add(p5);
      p6 = p5.add(tangent.multiply(this.data.step - 4 * this.data.thickness));
      this.spiral.add(p6);
      p7 = p6.add(normal.multiply(this.data.step - 4 * this.data.thickness));
      this.spiral.add(p7);
      p8 = p7.add(tangent.multiply(-(this.data.step - 3 * this.data.thickness)));
      this.spiral.add(p8);
      p9 = p8.add(normal.multiply(-(this.data.step - 2 * this.data.thickness)));
      this.spiral.add(p9);
    };

    Meander.prototype.drawEnd = function() {
      if (this.data.rsmooth) {
        this.spiral.smooth();
        this.line.smooth();
      }
    };

    return Meander;

  })(PrecisePath);

  this.Meander = Meander;

  this.pathClasses.push(this.Meander);

  GridPath = (function(_super) {
    __extends(GridPath, _super);

    function GridPath() {
      return GridPath.__super__.constructor.apply(this, arguments);
    }

    GridPath.rname = 'Grid path';

    GridPath.rdescription = "Draws a grid along the path, the thickness of the grid being function of the speed of the drawing.";

    GridPath.parameters = function() {
      var parameters;
      parameters = GridPath.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 5,
        max: 100,
        "default": 20,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].minWidth = {
        type: 'slider',
        label: 'Min width',
        min: 1,
        max: 100,
        "default": 5
      };
      parameters['Parameters'].maxWidth = {
        type: 'slider',
        label: 'Max width',
        min: 1,
        max: 250,
        "default": 200
      };
      parameters['Parameters'].minSpeed = {
        type: 'slider',
        label: 'Min speed',
        min: 1,
        max: 250,
        "default": 1
      };
      parameters['Parameters'].maxSpeed = {
        type: 'slider',
        label: 'Max speed',
        min: 1,
        max: 250,
        "default": 200
      };
      parameters['Parameters'].nLines = {
        type: 'slider',
        label: 'N lines',
        min: 1,
        max: 5,
        "default": 2,
        simplified: 2,
        step: 1
      };
      parameters['Parameters'].symmetric = {
        type: 'dropdown',
        label: 'Symmetry',
        values: ['symmetric', 'top', 'bottom'],
        "default": 'symmetric'
      };
      parameters['Parameters'].speedForWidth = {
        type: 'checkbox',
        label: 'Speed for width',
        "default": true
      };
      parameters['Parameters'].speedForLength = {
        type: 'checkbox',
        label: 'Speed for length',
        "default": false
      };
      parameters['Parameters'].orthoLines = {
        type: 'checkbox',
        label: 'Orthogonal lines',
        "default": true
      };
      parameters['Parameters'].lengthLines = {
        type: 'checkbox',
        label: 'Length lines',
        "default": true
      };
      return parameters;
    };

    GridPath.prototype.drawBegin = function() {
      var i, nLines, _i;
      this.initializeDrawing(false);
      if (this.data.lengthLines) {
        this.lines = [];
        nLines = this.data.nLines;
        if (this.data.symmetric === 'symmetric') {
          nLines *= 2;
        }
        for (i = _i = 1; 1 <= nLines ? _i <= nLines : _i >= nLines; i = 1 <= nLines ? ++_i : --_i) {
          this.lines.push(this.addPath());
        }
      }
      this.lastOffset = 0;
    };

    GridPath.prototype.drawUpdate = function(offset, step) {
      var addPoint, midOffset, speed, stepOffset;
      if (!step) {
        return;
      }
      console.log("drawUpdate");
      speed = this.speedAt(offset);
      addPoint = (function(_this) {
        return function(offset, speed) {
          var delta, divisor, i, line, normal, path, point, width, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
          point = _this.controlPath.getPointAt(offset);
          normal = _this.controlPath.getNormalAt(offset).normalize();
          if (_this.data.speedForWidth) {
            width = _this.data.minWidth + (_this.data.maxWidth - _this.data.minWidth) * speed / _this.constructor.maxSpeed;
          } else {
            width = _this.data.minWidth;
          }
          if (_this.data.lengthLines) {
            divisor = _this.data.nLines > 1 ? _this.data.nLines - 1 : 1;
            if (_this.data.symmetric === 'symmetric') {
              _ref = _this.lines;
              for (i = _i = 0, _len = _ref.length; _i < _len; i = _i += 2) {
                line = _ref[i];
                _this.lines[i + 0].add(point.add(normal.multiply(i * width * 0.5 / divisor)));
                _this.lines[i + 1].add(point.add(normal.multiply(-i * width * 0.5 / divisor)));
              }
            } else {
              if (_this.data.symmetric === 'top') {
                _ref1 = _this.lines;
                for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                  line = _ref1[i];
                  line.add(point.add(normal.multiply(i * width / divisor)));
                }
              } else if (_this.data.symmetric === 'bottom') {
                _ref2 = _this.lines;
                for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
                  line = _ref2[i];
                  line.add(point.add(normal.multiply(-i * width / divisor)));
                }
              }
            }
          }
          if (_this.data.orthoLines) {
            path = _this.addPath();
            delta = normal.multiply(width);
            switch (_this.data.symmetric) {
              case 'symmetric':
                path.add(point.add(delta));
                path.add(point.subtract(delta));
                break;
              case 'top':
                path.add(point.add(delta));
                path.add(point);
                break;
              case 'bottom':
                path.add(point.subtract(delta));
                path.add(point);
            }
          }
        };
      })(this);
      if (!this.data.speedForLength) {
        addPoint(offset, speed);
      } else {
        speed = this.data.minSpeed + (speed / this.constructor.maxSpeed) * (this.data.maxSpeed - this.data.minSpeed);
        stepOffset = offset - this.lastOffset;
        if (stepOffset > speed) {
          midOffset = (offset + this.lastOffset) / 2;
          addPoint(midOffset, speed);
          this.lastOffset = offset;
        }
      }
    };

    GridPath.prototype.drawEnd = function() {};

    return GridPath;

  })(SpeedPath);

  this.GridPath = GridPath;

  this.pathClasses.push(this.GridPath);

  GeometricLines = (function(_super) {
    __extends(GeometricLines, _super);

    function GeometricLines() {
      return GeometricLines.__super__.constructor.apply(this, arguments);
    }

    GeometricLines.rname = 'Geometric lines';

    GeometricLines.rdescription = "Draws a line between pair of points which are close enough.";

    GeometricLines.iconUrl = 'static/images/icons/inverted/links.png';

    GeometricLines.iconAlt = 'links';

    GeometricLines.parameters = function() {
      var parameters;
      parameters = GeometricLines.__super__.constructor.parameters.call(this);
      parameters['Style'].strokeColor.defaultFunction = function() {
        return "rgba(39, 158, 224, 0.21)";
      };
      delete parameters['Style'].fillColor;
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 5,
        max: 100,
        "default": 11,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].distance = {
        type: 'slider',
        label: 'Distance',
        min: 5,
        max: 250,
        "default": 150,
        simplified: 100
      };
      return parameters;
    };

    GeometricLines.prototype.drawBegin = function() {
      this.initializeDrawing(true);
      this.points = [];
    };

    GeometricLines.prototype.drawUpdate = function(offset, step) {
      var distMax, normal, point, pt, _i, _len, _ref;
      if (!step) {
        return;
      }
      point = this.controlPath.getPointAt(offset);
      normal = this.controlPath.getNormalAt(offset).normalize();
      point = this.projectToRaster(point);
      this.points.push(point);
      distMax = this.data.distance * this.data.distance;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pt = _ref[_i];
        if (point.getDistance(pt, true) < distMax) {
          this.context.beginPath();
          this.context.moveTo(point.x, point.y);
          this.context.lineTo(pt.x, pt.y);
          this.context.stroke();
        }
      }
    };

    GeometricLines.prototype.drawEnd = function() {};

    return GeometricLines;

  })(PrecisePath);

  this.GeometricLines = GeometricLines;

  this.pathClasses.push(this.GeometricLines);

  PaintBrush = (function(_super) {
    __extends(PaintBrush, _super);

    function PaintBrush() {
      return PaintBrush.__super__.constructor.apply(this, arguments);
    }

    PaintBrush.rname = 'Paint brush';

    PaintBrush.rdescription = "Paints a thick stroke with customable blur effects.";

    PaintBrush.iconUrl = 'static/images/icons/inverted/brush.png';

    PaintBrush.iconAlt = 'brush';

    PaintBrush.parameters = function() {
      var parameters;
      parameters = PaintBrush.__super__.constructor.parameters.call(this);
      delete parameters['Style'].fillColor;
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 1,
        max: 100,
        "default": 11,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].size = {
        type: 'slider',
        label: 'Size',
        min: 1,
        max: 100,
        "default": 10
      };
      parameters['Parameters'].blur = {
        type: 'slider',
        label: 'Blur',
        min: 0,
        max: 100,
        "default": 20
      };
      return parameters;
    };

    PaintBrush.prototype.pathWidth = function() {
      return 2 * this.data.size;
    };

    PaintBrush.prototype.drawBegin = function() {
      var point;
      this.initializeDrawing(true);
      point = this.controlPath.firstSegment.point;
      point = this.projectToRaster(point);
      this.context.moveTo(point.x, point.y);
    };

    PaintBrush.prototype.drawUpdate = function(offset, step) {
      var endColor, innerRadius, midColor, normal, outerRadius, point, radialGradient;
      if (!step) {
        return;
      }
      point = this.controlPath.getPointAt(offset);
      normal = this.controlPath.getNormalAt(offset).normalize();
      point = this.projectToRaster(point);
      innerRadius = this.data.size * (1 - this.data.blur / 100);
      outerRadius = this.data.size;
      radialGradient = this.context.createRadialGradient(point.x, point.y, innerRadius, point.x, point.y, outerRadius);
      midColor = new Color(this.data.strokeColor);
      midColor.alpha = 0.5;
      endColor = new Color(this.data.strokeColor);
      endColor.alpha = 0;
      radialGradient.addColorStop(0, this.data.strokeColor);
      radialGradient.addColorStop(0.5, midColor.toCSS());
      radialGradient.addColorStop(1, endColor.toCSS());
      this.context.fillStyle = radialGradient;
      this.context.fillRect(point.x - outerRadius, point.y - outerRadius, 2 * outerRadius, 2 * outerRadius);
    };

    PaintBrush.prototype.drawEnd = function() {};

    return PaintBrush;

  })(PrecisePath);

  this.PaintBrush = PaintBrush;

  this.pathClasses.push(this.PaintBrush);

  PaintGun = (function(_super) {
    __extends(PaintGun, _super);

    function PaintGun() {
      return PaintGun.__super__.constructor.apply(this, arguments);
    }

    PaintGun.rname = 'Paint gun';

    PaintGun.rdescription = "The stroke width is function of the drawing speed: the faster the wider.";

    PaintGun.parameters = function() {
      var parameters;
      parameters = PaintGun.__super__.constructor.parameters.call(this);
      delete parameters['Style'].fillColor;
      parameters['Edit curve'].showSpeed.value = false;
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 1,
        max: 100,
        "default": 11,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].trackWidth = {
        type: 'slider',
        label: 'Track width',
        min: 0.1,
        max: 3,
        "default": 0.25
      };
      parameters['Parameters'].roundEnd = {
        type: 'checkbox',
        label: 'Round end',
        "default": false
      };
      parameters['Parameters'].inverseThickness = {
        type: 'checkbox',
        label: 'Inverse thickness',
        "default": false
      };
      return parameters;
    };

    PaintGun.prototype.pathWidth = function() {
      return this.data.trackWidth * this.speeds.max();
    };

    PaintGun.prototype.drawBegin = function() {
      var point;
      this.initializeDrawing(true);
      point = this.controlPath.firstSegment.point;
      point = this.projectToRaster(point);
      this.context.moveTo(point.x, point.y);
      this.previousTop = point;
      this.previousBottom = point;
      this.previousMidTop = point;
      this.previousMidBottom = point;
      this.maxSpeed = this.speeds.length > 0 ? this.speeds.max() / 1.5 : this.constructor.maxSpeed / 6;
    };

    PaintGun.prototype.drawStep = function(offset, step, end) {
      var bottom, delta, midBottom, midTop, normal, point, speed, top;
      if (end == null) {
        end = false;
      }
      point = this.controlPath.getPointAt(offset);
      normal = this.controlPath.getNormalAt(offset).normalize();
      speed = this.speedAt(offset);
      point = this.projectToRaster(point);
      if (!this.data.inverseThickness) {
        delta = normal.multiply(speed * this.data.trackWidth / 2);
      } else {
        delta = normal.multiply(Math.max(this.maxSpeed - speed, 0) * this.data.trackWidth / 2);
      }
      top = point.add(delta);
      bottom = point.subtract(delta);
      if (!end) {
        midTop = this.previousTop.add(top).multiply(0.5);
        midBottom = this.previousBottom.add(bottom).multiply(0.5);
      } else {
        midTop = top;
        midBottom = bottom;
      }
      this.context.fillStyle = this.data.strokeColor;
      this.context.beginPath();
      this.context.moveTo(this.previousMidTop.x, this.previousMidTop.y);
      this.context.lineTo(this.previousMidBottom.x, this.previousMidBottom.y);
      this.context.quadraticCurveTo(this.previousBottom.x, this.previousBottom.y, midBottom.x, midBottom.y);
      this.context.lineTo(midTop.x, midTop.y);
      this.context.quadraticCurveTo(this.previousTop.x, this.previousTop.y, this.previousMidTop.x, this.previousMidTop.y);
      this.context.fill();
      this.context.stroke();
      if (step) {
        this.previousTop = top;
        this.previousBottom = bottom;
        this.previousMidTop = midTop;
        this.previousMidBottom = midBottom;
      }
    };

    PaintGun.prototype.drawUpdate = function(offset, step) {
      this.drawStep(offset, step);
    };

    PaintGun.prototype.drawEnd = function() {
      var point;
      this.drawStep(this.controlPath.length, false, true);
      if (this.data.roundEnd) {
        point = this.controlPath.lastSegment.point;
        point = this.projectToRaster(point);
        this.context.beginPath();
        this.context.fillStyle = this.data.strokeColor;
        this.context.arc(point.x, point.y, this.speeds.last() * this.data.trackWidth / 2, 0, 2 * Math.PI);
        this.context.fill();
      }
    };

    return PaintGun;

  })(SpeedPath);

  this.PaintGun = PaintGun;

  this.pathClasses.push(this.PaintGun);

  DynamicBrush = (function(_super) {
    __extends(DynamicBrush, _super);

    function DynamicBrush() {
      this.drawStep = __bind(this.drawStep, this);
      return DynamicBrush.__super__.constructor.apply(this, arguments);
    }

    DynamicBrush.rname = 'Dynamic brush';

    DynamicBrush.rdescription = "The stroke width is function of the drawing speed: the faster the wider.";

    DynamicBrush.parameters = function() {
      var parameters;
      parameters = DynamicBrush.__super__.constructor.parameters.call(this);
      delete parameters['Style'].fillColor;
      parameters['Edit curve'].showSpeed.value = false;
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].trackWidth = {
        type: 'slider',
        label: 'Track width',
        min: 0.1,
        max: 2.0,
        "default": 0.5
      };
      parameters['Parameters'].mass = {
        type: 'slider',
        label: 'Mass',
        min: 1,
        max: 200,
        "default": 80
      };
      parameters['Parameters'].drag = {
        type: 'slider',
        label: 'Drag',
        min: 0,
        max: 1.0,
        "default": 0.175
      };
      parameters['Parameters'].roundEnd = {
        type: 'checkbox',
        label: 'Round end',
        "default": false
      };
      parameters['Parameters'].inverseThickness = {
        type: 'checkbox',
        label: 'Inverse thickness',
        "default": false
      };
      parameters['Parameters'].fixedAngle = {
        type: 'checkbox',
        label: 'Fixed angle',
        "default": false
      };
      parameters['Parameters'].angle = {
        type: 'slider',
        label: 'Angle',
        min: 0,
        max: 360,
        "default": 0
      };
      return parameters;
    };

    DynamicBrush.prototype.pathWidth = function() {
      return this.data.trackWidth * this.speeds.max();
    };

    DynamicBrush.prototype.drawBegin = function() {
      var point;
      this.initializeDrawing(true);
      point = this.controlPath.firstSegment.point;
      this.point = this.projectToRaster(point);
      this.currentPosition = this.point;
      this.lastPosition = this.currentPosition;
      this.velocity = new Point();
      this.timerId = setTimer(this.drawStep, 5);
    };

    DynamicBrush.prototype.updateForce = function() {
      var acceleration, force;
      force = this.point.subtract(this.currentPosition);
      if (force.length < 0.000001) {
        return false;
      }
      acceleration = force.divide(this.data.mass);
      this.velocity = this.velocity.add(acceleration);
      if (this.velocity.length < 0.000001) {
        return false;
      }
      this.velocity = this.velocity.multiply(1.0 - this.data.drag);
      this.lastPosition = this.currentPosition;
      this.currentPosition = this.currentPosition.add(this.velocity);
      return true;
    };

    DynamicBrush.prototype.drawStep = function() {
      var a, b, c, d, delta, width;
      if (!this.updateForce()) {
        return;
      }
      width = (0.04 - this.velocity.length) * this.data.trackWidth;
      delta = new Point(-this.velocity.y, this.velocity.x);
      delta.normalize();
      a = this.previousPosition.add(this.previousDelta);
      b = this.previousPosition.subtract(this.previousDelta);
      c = this.currentPosition.subtract(delta);
      d = this.currentPosition.add(delta);
      this.context.beginPath();
      this.context.moveTo(a.x, a.y);
      this.context.lineTo(b.x, b.y);
      this.context.stroke();
      this.context.lineTo(c.x, c.y);
      this.context.lineTo(d.x, d.y);
      this.context.fill();
      this.previousDelta = delta;
    };

    DynamicBrush.prototype.drawUpdate = function(offset, step) {
      var point;
      point = this.controlPath.getPointAt(offset);
      this.point = this.projectToRaster(point);
    };

    DynamicBrush.prototype.drawEnd = function() {
      clearTimer(this.timerId);
    };

    return DynamicBrush;

  })(SpeedPath);

  this.DynamicBrush = DynamicBrush;

  this.pathClasses.push(this.DynamicBrush);

  ShapePath = (function(_super) {
    __extends(ShapePath, _super);

    function ShapePath() {
      return ShapePath.__super__.constructor.apply(this, arguments);
    }

    ShapePath.rname = 'Shape path';

    ShapePath.rdescription = "Draws rectangles or ellipses along the path. The size of the shapes is function of the drawing speed.";

    ShapePath.parameters = function() {
      var parameters;
      parameters = ShapePath.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 5,
        max: 100,
        "default": 20,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].ellipse = {
        type: 'checkbox',
        label: 'Ellipse',
        "default": false
      };
      parameters['Parameters'].minWidth = {
        type: 'slider',
        label: 'Min width',
        min: 1,
        max: 250,
        "default": 1
      };
      parameters['Parameters'].maxWidth = {
        type: 'slider',
        label: 'Max width',
        min: 1,
        max: 250,
        "default": 200
      };
      parameters['Parameters'].speedForLength = {
        type: 'checkbox',
        label: 'Speed for length',
        "default": false
      };
      parameters['Parameters'].minSpeed = {
        type: 'slider',
        label: 'Min speed',
        min: 1,
        max: 250,
        "default": 1
      };
      parameters['Parameters'].maxSpeed = {
        type: 'slider',
        label: 'Max speed',
        min: 1,
        max: 250,
        "default": 200
      };
      return parameters;
    };

    ShapePath.prototype.drawBegin = function() {
      this.initializeDrawing(false);
      this.lastOffset = 0;
    };

    ShapePath.prototype.drawUpdate = function(offset, step) {
      var addShape, midOffset, speed, stepOffset;
      if (!step) {
        return;
      }
      console.log("drawUpdate");
      speed = this.speedAt(offset);
      addShape = (function(_this) {
        return function(offset, height, speed) {
          var normal, point, rectangle, shape, width;
          point = _this.controlPath.getPointAt(offset);
          normal = _this.controlPath.getNormalAt(offset);
          width = _this.data.minWidth + (_this.data.maxWidth - _this.data.minWidth) * speed / _this.constructor.maxSpeed;
          rectangle = new Rectangle(point.subtract(new Point(width / 2, height / 2)), new Size(width, height));
          if (!_this.data.ellipse) {
            shape = _this.addPath(new Path.Rectangle(rectangle));
          } else {
            shape = _this.addPath(new Path.Ellipse(rectangle));
          }
          shape.rotation = normal.angle;
        };
      })(this);
      if (!this.data.speedForLength) {
        addShape(offset, this.data.step, speed);
      } else {
        speed = this.data.minSpeed + (speed / this.constructor.maxSpeed) * (this.data.maxSpeed - this.data.minSpeed);
        stepOffset = offset - this.lastOffset;
        if (stepOffset > speed) {
          midOffset = (offset + this.lastOffset) / 2;
          addShape(midOffset, stepOffset, speed);
          this.lastOffset = offset;
        }
      }
    };

    ShapePath.prototype.drawEnd = function() {};

    return ShapePath;

  })(SpeedPath);

  this.ShapePath = ShapePath;

  this.pathClasses.push(this.ShapePath);

  RShape = (function(_super) {
    __extends(RShape, _super);

    function RShape() {
      return RShape.__super__.constructor.apply(this, arguments);
    }

    RShape.Shape = paper.Path.Rectangle;

    RShape.rname = 'Shape';

    RShape.rdescription = "Base shape class";

    RShape.squareByDefault = true;

    RShape.centerByDefault = false;

    RShape.prototype.prepareHitTest = function(fullySelected, strokeWidth) {
      if (fullySelected == null) {
        fullySelected = true;
      }
      this.controlPath.fillColor = 'red';
      return RShape.__super__.prepareHitTest.call(this, fullySelected, strokeWidth);
    };

    RShape.prototype.finishHitTest = function(fullySelected) {
      if (fullySelected == null) {
        fullySelected = true;
      }
      this.controlPath.fillColor = null;
      return RShape.__super__.finishHitTest.call(this, fullySelected);
    };

    RShape.prototype.loadPath = function(points) {
      var distanceMax, i, point, _i, _len;
      if (this.data.rectangle == null) {
        console.log('Error loading shape ' + this.pk + ': invalid rectangle.');
      }
      this.rectangle = this.data.rectangle != null ? new Rectangle(this.data.rectangle.x, this.data.rectangle.y, this.data.rectangle.width, this.data.rectangle.height) : new Rectangle();
      this.initializeControlPath(this.rectangle.topLeft, this.rectangle.bottomRight, false, false, true);
      this.draw(null, true);
      this.controlPath.rotation = this.data.rotation;
      this.initialize();
      distanceMax = this.constructor.secureDistance * this.constructor.secureDistance;
      for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
        point = points[i];
        this.controlPath.segments[i].point === point;
        if (this.controlPath.segments[i].point.getDistance(point, true) > distanceMax) {
          this.controlPath.strokeColor = 'red';
          view.center = this.controlPath.bounds.center;
          console.log("Error: invalid shape!");
          return;
        }
      }
    };

    RShape.prototype.moveBy = function(delta) {
      this.rectangle.center.x += delta.x;
      this.rectangle.center.y += delta.y;
      RShape.__super__.moveBy.call(this, delta);
    };

    RShape.prototype.moveTo = function(position) {
      this.rectangle.center = position;
      RShape.__super__.moveTo.call(this, position);
    };

    RShape.prototype.updateSelectionRectangle = function() {
      var bounds, _ref;
      bounds = this.rectangle.clone().expand(10 + this.pathWidth());
      if ((_ref = this.selectionRectangle) != null) {
        _ref.remove();
      }
      this.selectionRectangle = new Path.Rectangle(bounds);
      this.group.addChild(this.selectionRectangle);
      this.selectionRectangle.name = 'selection rectangle';
      this.selectionRectangle.pivot = this.selectionRectangle.bounds.center;
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top));
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top - 25));
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top));
      this.selectionRectangle.rotation = this.data.rotation;
      this.selectionRectangle.selected = true;
      this.selectionRectangle.controller = this;
      this.controlPath.pivot = this.selectionRectangle.pivot;
    };

    RShape.prototype.selectUpdate = function(event, userAction) {
      var delta, direction, length, _ref, _ref1;
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectUpdate");
      if (this.previousBoundingBox == null) {
        this.previousBoundingBox = this.getDrawingBounds();
      }
      if (!this.drawing) {
        g.updateView();
      }
      if (this.selectionRectangleRotation != null) {
        direction = event.point.subtract(this.selectionRectangle.bounds.center);
        delta = this.selectionRectangleRotation.getDirectedAngle(direction);
        this.selectionRectangleRotation = direction;
        this.data.rotation += delta;
        this.selectionRectangle.rotation += delta;
        if ((_ref = this.raster) != null) {
          _ref.rotation += delta;
        }
        this.changed = 'rotated';
        this.draw();
      } else if (this.selectionRectangleScale != null) {
        length = event.point.subtract(this.selectionRectangle.bounds.center).length;
        delta = length / this.selectionRectangleScale;
        this.selectionRectangleScale = length;
        this.rectangle = this.rectangle.scale(delta);
        this.selectionRectangle.scale(delta);
        if ((_ref1 = this.raster) != null) {
          _ref1.scale(delta);
        }
        this.changed = 'scaled';
        this.draw();
      } else {
        this.group.position.x += event.delta.x;
        this.group.position.y += event.delta.y;
        this.rectangle.x += event.delta.x;
        this.rectangle.y += event.delta.y;
        if (!this.drawing) {
          this.draw(false);
        }
        this.changed = 'moved';
      }
    };

    RShape.prototype.pathWidth = function() {
      return this.data.strokeWidth;
    };

    RShape.prototype.createShape = function() {
      this.shape = this.addPath(new this.constructor.Shape(this.rectangle));
    };

    RShape.prototype.draw = function(simplified, loading) {
      var error, process, _ref;
      if (simplified == null) {
        simplified = false;
      }
      if (loading == null) {
        loading = false;
      }
      if (loading && !((_ref = this.data) != null ? _ref.animate : void 0)) {
        return;
      }
      process = (function(_this) {
        return function() {
          _this.initializeDrawing();
          _this.createShape();
          _this.drawing.rotation = _this.data.rotation;
          _this.rasterize();
        };
      })(this);
      if (!g.catchErrors) {
        process();
      } else {
        try {
          process();
        } catch (_error) {
          error = _error;
          console.error(error.stack);
          console.error(error);
          throw error;
        }
      }
    };

    RShape.prototype.initializeControlPath = function(pointA, pointB, shift, specialKey, load) {
      var center, createFromCenter, delta, height, min, square, width, _base, _ref;
      this.group = new Group();
      this.group.name = "group";
      this.group.controller = this;
      if (load) {
        this.rectangle = new Rectangle(pointA, pointB);
      } else {
        square = this.constructor.squareByDefault ? !shift : shift;
        createFromCenter = this.constructor.centerByDefault ? !specialKey : specialKey;
        if (createFromCenter) {
          delta = pointB.subtract(pointA);
          this.rectangle = new Rectangle(pointA.subtract(delta), pointB);
          if (square) {
            center = this.rectangle.center;
            if (this.rectangle.width > this.rectangle.height) {
              this.rectangle.width = this.rectangle.height;
            } else {
              this.rectangle.height = this.rectangle.width;
            }
            this.rectangle.center = center;
          }
        } else {
          if (!square) {
            this.rectangle = new Rectangle(pointA, pointB);
          } else {
            width = pointA.x - pointB.x;
            height = pointA.y - pointB.y;
            min = Math.min(Math.abs(width), Math.abs(height));
            this.rectangle = new Rectangle(pointA, pointA.subtract(g.sign(width) * min, g.sign(height) * min));
          }
        }
      }
      if ((_ref = this.controlPath) != null) {
        _ref.remove();
      }
      this.controlPath = new Path.Rectangle(this.rectangle);
      this.group.addChild(this.controlPath);
      this.controlPath.name = "controlPath";
      this.controlPath.controller = this;
      this.controlPath.strokeWidth = this.pathWidth();
      this.controlPath.strokeColor = g.selectionBlue;
      this.controlPath.strokeColor.alpha = 0.25;
      this.controlPath.strokeCap = 'round';
      this.controlPath.visible = false;
      if ((_base = this.data).rotation == null) {
        _base.rotation = 0;
      }
    };

    RShape.prototype.createBegin = function(point, event, loading) {
      var _ref;
      RShape.__super__.createBegin.call(this);
      this.downPoint = point;
      this.initializeControlPath(this.downPoint, point, event != null ? (_ref = event.modifiers) != null ? _ref.shift : void 0 : void 0, g.specialKey(event));
      if (!loading) {
        this.draw();
      }
    };

    RShape.prototype.createUpdate = function(point, event, loading) {
      var _ref;
      this.initializeControlPath(this.downPoint, point, event != null ? (_ref = event.modifiers) != null ? _ref.shift : void 0 : void 0, g.specialKey(event));
      if (!loading) {
        this.draw();
      }
    };

    RShape.prototype.createEnd = function(point, event, loading) {
      var _ref;
      this.initializeControlPath(this.downPoint, point, event != null ? (_ref = event.modifiers) != null ? _ref.shift : void 0 : void 0, g.specialKey(event));
      this.draw(null, loading);
      RShape.__super__.createEnd.call(this);
    };

    RShape.prototype.getData = function() {
      var data;
      data = jQuery.extend({}, this.data);
      data.rectangle = {
        x: this.rectangle.x,
        y: this.rectangle.y,
        width: this.rectangle.width,
        height: this.rectangle.height
      };
      return data;
    };

    return RShape;

  })(RPath);

  this.RShape = RShape;

  RectangleShape = (function(_super) {
    __extends(RectangleShape, _super);

    function RectangleShape() {
      return RectangleShape.__super__.constructor.apply(this, arguments);
    }

    RectangleShape.Shape = paper.Path.Rectangle;

    RectangleShape.rname = 'Rectangle';

    RectangleShape.rdescription = "Simple rectangle, square by default (use shift key to draw a rectangle) which can have rounded corners.\nUse special key (command on a mac, control otherwise) to center the shape on the first point.";

    RectangleShape.iconUrl = 'static/images/icons/inverted/rectangle.png';

    RectangleShape.iconAlt = 'rectangle';

    RectangleShape.parameters = function() {
      var parameters;
      parameters = RectangleShape.__super__.constructor.parameters.call(this);
      if (parameters['Style'] == null) {
        parameters['Style'] = {};
      }
      parameters['Style'].cornerRadius = {
        type: 'slider',
        label: 'Corner radius',
        min: 0,
        max: 100,
        "default": 0
      };
      return parameters;
    };

    RectangleShape.prototype.createShape = function() {
      this.shape = this.addPath(new this.constructor.Shape(this.rectangle, this.data.cornerRadius));
    };

    return RectangleShape;

  })(RShape);

  this.RectangleShape = RectangleShape;

  this.pathClasses.push(this.RectangleShape);

  EllipseShape = (function(_super) {
    __extends(EllipseShape, _super);

    function EllipseShape() {
      return EllipseShape.__super__.constructor.apply(this, arguments);
    }

    EllipseShape.Shape = paper.Path.Ellipse;

    EllipseShape.rname = 'Ellipse';

    EllipseShape.rdescription = "Simple ellipse, circle by default (use shift key to draw an ellipse).\nUse special key (command on a mac, control otherwise) to avoid the shape to be centered on the first point.";

    EllipseShape.iconUrl = 'static/images/icons/inverted/circle.png';

    EllipseShape.iconAlt = 'circle';

    EllipseShape.squareByDefault = true;

    EllipseShape.centerByDefault = true;

    return EllipseShape;

  })(RShape);

  this.EllipseShape = EllipseShape;

  this.pathClasses.push(this.EllipseShape);

  StarShape = (function(_super) {
    __extends(StarShape, _super);

    function StarShape() {
      this.onFrame = __bind(this.onFrame, this);
      return StarShape.__super__.constructor.apply(this, arguments);
    }

    StarShape.Shape = paper.Path.Star;

    StarShape.rname = 'Star';

    StarShape.rdescription = "Draws a star which can be animated (the color changes and it rotates).";

    StarShape.iconUrl = 'static/images/icons/inverted/star.png';

    StarShape.iconAlt = 'star';

    StarShape.parameters = function() {
      var parameters;
      parameters = StarShape.__super__.constructor.parameters.call(this);
      if (parameters['Style'] == null) {
        parameters['Style'] = {};
      }
      parameters['Style'].nPoints = {
        type: 'slider',
        label: 'N points',
        min: 1,
        max: 100,
        "default": 5,
        step: 2
      };
      parameters['Style'].internalRadius = {
        type: 'slider',
        label: 'Internal radius',
        min: -200,
        max: 100,
        "default": 37
      };
      parameters['Style'].rsmooth = {
        type: 'checkbox',
        label: 'Smooth',
        "default": false
      };
      parameters['Style'].animate = {
        type: 'checkbox',
        label: 'Animate',
        "default": false
      };
      return parameters;
    };

    StarShape.prototype.initialize = function() {
      this.setAnimated(this.data.animate);
    };

    StarShape.prototype.createShape = function() {
      var externalRadius, internalRadius, rectangle;
      rectangle = this.rectangle;
      if (this.data.internalRadius > -100) {
        externalRadius = rectangle.width / 2;
        internalRadius = externalRadius * this.data.internalRadius / 100;
      } else {
        internalRadius = rectangle.width / 2;
        externalRadius = internalRadius * 100 / this.data.internalRadius;
      }
      this.shape = this.addPath(new this.constructor.Shape(rectangle.center, this.data.nPoints, externalRadius, internalRadius));
      if (this.data.rsmooth) {
        this.shape.smooth();
      }
    };

    StarShape.prototype.onFrame = function(event) {
      this.shape.strokeColor.hue += 1;
      this.shape.rotation += 1;
    };

    return StarShape;

  })(RShape);

  this.StarShape = StarShape;

  this.pathClasses.push(this.StarShape);

  SpiralShape = (function(_super) {
    __extends(SpiralShape, _super);

    function SpiralShape() {
      this.onFrame = __bind(this.onFrame, this);
      return SpiralShape.__super__.constructor.apply(this, arguments);
    }

    SpiralShape.Shape = paper.Path.Ellipse;

    SpiralShape.rname = 'Spiral';

    SpiralShape.rdescription = "The spiral shape can have an intern radius, and a custom number of sides.";

    SpiralShape.iconUrl = 'static/images/icons/inverted/spiral.png';

    SpiralShape.iconAlt = 'spiral';

    SpiralShape.parameters = function() {
      var parameters;
      parameters = SpiralShape.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].minRadius = {
        type: 'slider',
        label: 'Minimum radius',
        min: 0,
        max: 100,
        "default": 0
      };
      parameters['Parameters'].nTurns = {
        type: 'slider',
        label: 'Number of turns',
        min: 1,
        max: 50,
        "default": 10
      };
      parameters['Parameters'].nSides = {
        type: 'slider',
        label: 'Sides',
        min: 3,
        max: 100,
        "default": 50
      };
      parameters['Parameters'].animate = {
        type: 'checkbox',
        label: 'Animate',
        "default": false
      };
      parameters['Parameters'].rotationSpeed = {
        type: 'slider',
        label: 'Rotation speed',
        min: -10,
        max: 10,
        "default": 1
      };
      return parameters;
    };

    SpiralShape.prototype.initialize = function() {
      this.setAnimated(this.data.animate);
    };

    SpiralShape.prototype.createShape = function() {
      var angle, angleStep, c, hh, hw, i, radiusStepX, radiusStepY, rectangle, spiralHeight, spiralWidth, step, _i, _j, _ref, _ref1;
      this.shape = this.addPath();
      rectangle = this.rectangle;
      hw = rectangle.width / 2;
      hh = rectangle.height / 2;
      c = rectangle.center;
      angle = 0;
      angleStep = 360.0 / this.data.nSides;
      spiralWidth = hw - hw * this.data.minRadius / 100.0;
      spiralHeight = hh - hh * this.data.minRadius / 100.0;
      radiusStepX = (spiralWidth / this.data.nTurns) / this.data.nSides;
      radiusStepY = (spiralHeight / this.data.nTurns) / this.data.nSides;
      for (i = _i = 0, _ref = this.data.nTurns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (step = _j = 0, _ref1 = this.data.nSides - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; step = 0 <= _ref1 ? ++_j : --_j) {
          this.shape.add(new Point(c.x + hw * Math.cos(angle), c.y + hh * Math.sin(angle)));
          angle += 2.0 * Math.PI * angleStep / 360.0;
          hw -= radiusStepX;
          hh -= radiusStepY;
        }
      }
      this.shape.add(new Point(c.x + hw * Math.cos(angle), c.y + hh * Math.sin(angle)));
      this.shape.pivot = this.rectangle.center;
    };

    SpiralShape.prototype.onFrame = function(event) {
      this.shape.strokeColor.hue += 1;
      this.shape.rotation += this.data.rotationSpeed;
    };

    return SpiralShape;

  })(RShape);

  this.SpiralShape = SpiralShape;

  this.pathClasses.push(this.SpiralShape);

  FaceShape = (function(_super) {
    __extends(FaceShape, _super);

    function FaceShape() {
      return FaceShape.__super__.constructor.apply(this, arguments);
    }

    FaceShape.Shape = paper.Path.Rectangle;

    FaceShape.rname = 'Face generator';

    FaceShape.rdescription = "Face generator, inspired by weird faces study by Matthias Drfelt aka mokafolio.";

    FaceShape.parameters = function() {
      var parameters;
      parameters = FaceShape.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].minRadius = {
        type: 'slider',
        label: 'Minimum radius',
        min: 0,
        max: 100,
        "default": 0
      };
      parameters['Parameters'].nTurns = {
        type: 'slider',
        label: 'Number of turns',
        min: 1,
        max: 50,
        "default": 10
      };
      parameters['Parameters'].nSides = {
        type: 'slider',
        label: 'Sides',
        min: 3,
        max: 100,
        "default": 50
      };
      return parameters;
    };

    FaceShape.prototype.createShape = function() {
      var center, deltaX, eyeLeft, eyeRight, height, i, noze, nozeLeft, nozeRight, nozeShape, position, rangeRandC, rangeRandMM, segment, size, width, x, y, _i, _j, _len, _ref, _ref1;
      this.headShape = this.addPath(new Path.Ellipse(this.rectangle.expand(-20, -10)));
      this.headShape.flatten(50);
      _ref = this.headShape.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        segment.point.x += Math.random() * 20;
        segment.point.y += Math.random() * 5;
        segment.handleIn += Math.random() * 5;
        segment.handleOut += Math.random() * 5;
      }
      this.headShape.smooth();
      nozeShape = Math.random();
      center = this.rectangle.center;
      width = this.rectangle.width;
      height = this.rectangle.height;
      rangeRandMM = function(min, max) {
        return min + (max - min) * Math.random();
      };
      rangeRandC = function(center, amplitude) {
        return center + amplitude * (Math.random() - 0.5);
      };
      if (nozeShape < 0.333) {
        deltaX = 0.1 * width + Math.random() * 10;
        x = center.x - deltaX;
        y = center.y + rangeRandC(0, 5);
        position = center.add(x, y);
        size = new Size(Math.random() * 5, Math.random() * 5);
        nozeLeft = this.addPath(new Path.Ellipse(position, size));
        position += 2 * deltaX;
        size = new Size(Math.random() * 5, Math.random() * 5);
        nozeRight = this.addPath(new Path.Ellipse(position, size));
      } else if (nozeShape < 0.666) {
        noze = this.addPath();
        noze.add(center);
        noze.add(center.add(Math.random() * 15, Math.random() * 5));
        noze.add(center.add(0, rangeRandMM(5, 10)));
        noze.smooth();
      } else {
        noze = this.addPath();
        noze.add(center);
        noze.add(center.add(-Math.random() * 15, Math.random() * 5));
        noze.add(center.add(0, rangeRandMM(15, 20)));
        noze.smooth();
      }
      deltaX = rangeRandC(0, 0.1 * width);
      x = center.x - deltaX;
      y = this.rectangle.top + width / 3 + rangeRandC(0, 10);
      position = new Point(x, y);
      size = new Size(Math.max(Math.random() * 30, deltaX), Math.random() * 30);
      eyeLeft = this.addPath(new Path.Ellipse(position, size));
      position.x += 2 * deltaX;
      eyeRight = this.addPath(new Path.Ellipse(position, size));
      eyeRight.position.x += rangeRandC(0, 5);
      eyeLeft.position.x += rangeRandC(0, 5);
      for (i = _j = 1, _ref1 = eyeLeft.segments.length - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        eyeLeft.segments[i].point.x += Math.random() * 3;
        eyeLeft.segments[i].point.y += Math.random() * 3;
        eyeRight.segments[i].point.x += Math.random() * 3;
        eyeRight.segments[i].point.y += Math.random() * 3;
      }
    };

    return FaceShape;

  })(RShape);

  this.FaceShape = FaceShape;

  this.pathClasses.push(this.FaceShape);

  Checkpoint = (function(_super) {
    __extends(Checkpoint, _super);

    function Checkpoint() {
      return Checkpoint.__super__.constructor.apply(this, arguments);
    }

    Checkpoint.Shape = paper.Path.Rectangle;

    Checkpoint.rname = 'Checkpoint';

    Checkpoint.rdescription = "Draw checkpoints on a video game area to create a race (the players must go through each checkpoint as fast as possible, with the car tool).";

    Checkpoint.squareByDefault = false;

    Checkpoint.parameters = function() {
      return {};
    };

    Checkpoint.prototype.initialize = function() {
      var _base;
      this.game = g.gameAt(this.rectangle.center);
      if (this.game != null) {
        if (this.game.checkpoints.indexOf(this) < 0) {
          this.game.checkpoints.push(this);
        }
        if ((_base = this.data).checkpointNumber == null) {
          _base.checkpointNumber = this.game.checkpoints.indexOf(this);
        }
      }
    };

    Checkpoint.prototype.createShape = function() {
      this.data.strokeColor = 'rgb(150,30,30)';
      this.data.fillColor = null;
      this.shape = this.addPath(new Path.Rectangle(this.rectangle));
      this.text = this.addPath(new PointText(this.rectangle.center.add(0, 4)));
      this.text.content = this.data.checkpointNumber != null ? 'Checkpoint ' + this.data.checkpointNumber : 'Checkpoint';
      this.text.justification = 'center';
    };

    Checkpoint.prototype.contains = function(point) {
      var delta;
      delta = point.subtract(this.rectangle.center);
      delta.rotation = -this.data.rotation;
      return this.rectangle.contains(this.rectangle.center.add(delta));
    };

    Checkpoint.prototype.remove = function() {
      var _ref;
      if ((_ref = this.game) != null) {
        _ref.checkpoints.remove(this);
      }
      Checkpoint.__super__.remove.call(this);
    };

    return Checkpoint;

  })(RShape);

  this.Checkpoint = Checkpoint;

  this.pathClasses.push(this.Checkpoint);

  StripeAnimation = (function(_super) {
    __extends(StripeAnimation, _super);

    function StripeAnimation() {
      this.onFrame = __bind(this.onFrame, this);
      this.rasterOnLoad = __bind(this.rasterOnLoad, this);
      return StripeAnimation.__super__.constructor.apply(this, arguments);
    }

    StripeAnimation.Shape = paper.Path.Rectangle;

    StripeAnimation.rname = 'Stripe animation';

    StripeAnimation.rdescription = "Creates a stripe animation from a set sequence of image.";

    StripeAnimation.squareByDefault = false;

    StripeAnimation.parameters = function() {
      var parameters;
      parameters = StripeAnimation.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].stripeWidth = {
        type: 'slider',
        label: 'Stripe width',
        min: 1,
        max: 100,
        "default": 3
      };
      return parameters;
    };

    StripeAnimation.prototype.initialize = function() {
      var modalAddImageButtonJ, modalBodyJ, modalContentJ, modalInputJ;
      this.data.animate = true;
      this.setAnimated(this.data.animate);
      this.modalJ = $('#customModal');
      modalBodyJ = this.modalJ.find('.modal-body');
      modalBodyJ.empty();
      modalInputJ = $("<input id=\"stripeAnimationModalURL\" type=\"url\" class=\"url form-control submit-shortcut\" placeholder=\"http://\">");
      modalAddImageButtonJ = $("<button type=\"button\" class=\"btn btn-default\">Add image</button>");
      modalContentJ = $("<div class=\"form-group url-group\">\n                <label for=\"stripeAnimationModalURL\">Add your images</label>\n            </div>");
      modalContentJ.append(modalInputJ.clone()).append(modalInputJ.clone()).append(modalAddImageButtonJ);
      modalBodyJ.append(modalContentJ);
      modalAddImageButtonJ.click(function(event) {
        modalAddImageButtonJ.before(modalInputJ.clone());
      });
      this.modalJ.modal('show');
      this.modalJ.find('.btn-primary').click((function(_this) {
        return function(event) {
          return _this.modalSubmit();
        };
      })(this));
    };

    StripeAnimation.prototype.modalSubmit = function() {
      var input, inputs, raster, _i, _len;
      inputs = this.modalJ.find("input.url");
      this.nRasterToLoad = inputs.length;
      this.nRasterLoaded = 0;
      this.rasters = [];
      for (_i = 0, _len = inputs.length; _i < _len; _i++) {
        input = inputs[_i];
        raster = new Raster(input.value);
        raster.onLoad = this.rasterOnLoad;
        this.rasters.push(raster);
      }
    };

    StripeAnimation.prototype.rasterOnLoad = function() {
      var black, i, n, nStripes, raster, size, stripeData, stripesContext, transparent, w, width, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2;
      this.nRasterLoaded++;
      if (this.nRasterLoaded < this.nRasterToLoad) {
        return;
      }
      this.minSize = new Size();
      _ref = this.rasters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        raster = _ref[_i];
        if (this.minSize.width === 0 || raster.width < this.minSize.width) {
          this.minSize.width = raster.width;
        }
        if (this.minSize.height === 0 || raster.height < this.minSize.height) {
          this.minSize.height = raster.height;
        }
      }
      _ref1 = this.rasters;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        raster = _ref1[_j];
        raster.size = this.minSize;
      }
      size = this.rasters[0].size;
      this.result = new Raster();
      this.result.position = this.rectangle.center;
      this.result.size = size;
      this.result.name = 'stripe animation raster';
      this.result.controller = this;
      this.drawing.addChild(this.result);
      this.stripes = new Raster();
      this.stripes.size = new Size(size.width * 3, size.height);
      this.stripes.position = this.rectangle.center;
      this.stripes.name = 'stripe mask raster';
      this.stripes.controller = this;
      this.drawing.addChild(this.stripes);
      n = this.rasters.length;
      width = this.data.stripeWidth;
      black = new Color(0, 0, 0);
      transparent = new Color(0, 0, 0, 0);
      nStripes = Math.floor(size.width / width);
      for (i = _k = 0; 0 <= nStripes ? _k <= nStripes : _k >= nStripes; i = 0 <= nStripes ? ++_k : --_k) {
        w = Math.min(width, size.width - (i + 1) * width);
        stripeData = this.rasters[i % n].getImageData(new Rectangle(i * width, 0, w, size.height));
        this.result.setImageData(stripeData, new Point(i * width, 0));
      }
      stripesContext = this.stripes.canvas.getContext("2d");
      for (i = _l = 0, _ref2 = 3 * nStripes - 1; 0 <= _ref2 ? _l <= _ref2 : _l >= _ref2; i = 0 <= _ref2 ? ++_l : --_l) {
        w = Math.min(width, 3 * size.width - (i + 1) * width);
        stripesContext.fillStyle = i % n === 0 ? "rgb(0, 0, 0)" : "rgba(0, 0, 0, 0)";
        stripesContext.fillRect(i * width, 0, w, size.height);
      }
    };

    StripeAnimation.prototype.createShape = function() {};

    StripeAnimation.prototype.onFrame = function(event) {
      if (this.stripes == null) {
        return;
      }
      this.stripes.position.x -= 1;
      if (this.stripes.bounds.center.x < this.rectangle.left) {
        this.stripes.bounds.center.x = this.rectangle.right;
      }
    };

    return StripeAnimation;

  })(RShape);

  this.StripeAnimation = StripeAnimation;

  this.pathClasses.push(this.StripeAnimation);

}).call(this);

//# sourceMappingURL=path.map
