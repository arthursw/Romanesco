// Generated by CoffeeScript 1.7.1
(function() {
  var Checkpoint, EllipseShape, FaceShape, FuzzyPath, PrecisePath, RPath, RShape, RectangleShape, RollerPath, ShapePath, SketchPath, SpeedPath, SpiralPath, SpiralShape, StarShape,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  RPath = (function() {
    RPath.rname = 'Pen';

    RPath.rdescription = "The classic and basic pen tool";

    RPath.cursorPosition = {
      x: 24,
      y: 0
    };

    RPath.cursorDefault = "crosshair";

    RPath.hitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      selected: true,
      tolerance: 5
    };

    RPath.constructor.secureDistance = 2;

    RPath.parameters = function() {
      var parameters;
      return parameters = {
        'General': {
          align: g.parameters.align,
          distribute: g.parameters.distribute,
          duplicate: g.parameters.duplicate,
          "delete": g.parameters["delete"],
          editTool: {
            type: 'button',
            label: 'Edit tool',
            "default": (function(_this) {
              return function() {
                return g.toolEditor(_this);
              };
            })(this)
          }
        },
        'Style': {
          strokeWidth: $.extend(true, {}, g.parameters.strokeWidth),
          strokeColor: $.extend(true, {}, g.parameters.strokeColor),
          fillColor: $.extend(true, {}, g.parameters.fillColor)
        }
      };
    };

    function RPath(date, data, pk, points) {
      var controller, folder, name, _i, _len, _ref, _ref1;
      this.date = date != null ? date : null;
      this.data = data != null ? data : null;
      this.pk = pk != null ? pk : null;
      if (points == null) {
        points = null;
      }
      this.update = __bind(this.update, this);
      this.save_callback = __bind(this.save_callback, this);
      this.selectedSegment = null;
      this.id = this.data != null ? this.data.id : Math.random();
      g.paths[this.id] = this;
      if (this.data == null) {
        this.data = new Object();
        this.data.id = this.id;
        _ref = g.gui.__folders;
        for (name in _ref) {
          folder = _ref[name];
          if (name === 'General') {
            continue;
          }
          _ref1 = folder.__controllers;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            controller = _ref1[_i];
            this.data[controller.property] = controller.rValue();
          }
        }
      }
      if (this.pk != null) {
        this.setPK(this.pk, false);
      }
      if (points != null) {
        this.loadPath(points);
      }
    }

    RPath.prototype.duplicate = function() {
      var copy;
      copy = new this.constructor(new Date(), this.getData(), null, this.pathOnPlanet());
      copy.save();
      return copy;
    };

    RPath.prototype.pathWidth = function() {
      return this.data.strokeWidth;
    };

    RPath.prototype.getBounds = function() {
      return this.controlPath.strokeBounds;
    };

    RPath.prototype.moveBy = function(delta, userAction) {
      this.group.position.x += delta.x;
      this.group.position.y += delta.y;
      if (userAction) {
        g.defferedExecution(this.update, this.getPk());
      }
    };

    RPath.prototype.moveTo = function(position, userAction) {
      var bounds, delta;
      bounds = this.getBounds();
      delta = this.group.position.subtract(bounds.center);
      this.group.position = position.add(delta);
      if (userAction) {
        g.defferedExecution(this.update, this.getPk());
      }
      return position.add(delta);
    };

    RPath.prototype.projectToRaster = function(point) {
      return point.subtract(this.canvasRaster.bounds.topLeft);
    };

    RPath.prototype.prepareHitTest = function(fullySelected, strokeWidth) {
      var _ref, _ref1;
      if (fullySelected == null) {
        fullySelected = true;
      }
      console.log("prepareHitTest");
      this.hitTestSelected = this.controlPath.selected;
      if (fullySelected) {
        this.hitTestFullySelected = this.controlPath.fullySelected;
        this.controlPath.fullySelected = true;
      } else {
        this.controlPath.selected = true;
      }
      this.hitTestControlPathVisible = this.controlPath.visible;
      this.controlPath.visible = true;
      this.hitTestGroupVisible = this.drawing.visible;
      this.drawing.visible = true;
      this.hitTestStrokeWidth = this.controlPath.strokeWidth;
      if (strokeWidth) {
        this.controlPath.strokeWidth = strokeWidth;
      }
      if ((_ref = this.raster) != null) {
        _ref.visible = false;
      }
      return (_ref1 = this.canvasRaster) != null ? _ref1.visible = false : void 0;
    };

    RPath.prototype.finishHitTest = function(fullySelected) {
      var _ref, _ref1;
      if (fullySelected == null) {
        fullySelected = true;
      }
      console.log("finishHitTest");
      if (fullySelected) {
        this.controlPath.fullySelected = this.hitTestFullySelected;
      }
      this.controlPath.selected = this.hitTestSelected;
      this.controlPath.visible = this.hitTestControlPathVisible;
      this.drawing.visible = this.hitTestGroupVisible;
      this.controlPath.strokeWidth = this.hitTestStrokeWidth;
      if ((_ref = this.raster) != null) {
        _ref.visible = true;
      }
      return (_ref1 = this.canvasRaster) != null ? _ref1.visible = true : void 0;
    };

    RPath.prototype.hitTest = function(point, hitOptions) {
      return this.selectionRectangle.hitTest(point);
    };

    RPath.prototype.performeHitTest = function(point, hitOptions, fullySelected) {
      var hitResult;
      if (fullySelected == null) {
        fullySelected = true;
      }
      this.prepareHitTest(fullySelected, 1);
      hitResult = this.hitTest(point, hitOptions);
      this.finishHitTest(fullySelected);
      return hitResult;
    };

    RPath.prototype.updateSelectionRectangle = function() {
      var bounds, reset, _ref;
      reset = (this.selectionRectangleBounds == null) || this.controlPath.rotation === 0 && this.controlPath.scaling.x === 1 && this.controlPath.scaling.y === 1;
      if (reset) {
        this.selectionRectangleBounds = this.controlPath.bounds.clone();
      }
      bounds = this.selectionRectangleBounds.clone().expand(10 + this.pathWidth() / 2);
      if ((_ref = this.selectionRectangle) != null) {
        _ref.remove();
      }
      this.selectionRectangle = new Path.Rectangle(bounds);
      this.group.addChild(this.selectionRectangle);
      this.selectionRectangle.name = "selection rectangle";
      this.selectionRectangle.pivot = this.selectionRectangle.bounds.center;
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top));
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top - 25));
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top));
      if (!reset) {
        this.selectionRectangle.position = this.controlPath.position;
        this.selectionRectangle.rotation = this.controlPath.rotation;
        this.selectionRectangle.scaling = this.controlPath.scaling;
      }
      this.selectionRectangle.selected = true;
      this.selectionRectangle.controller = this;
      return this.controlPath.pivot = this.selectionRectangle.pivot;
    };

    RPath.prototype.select = function(updateOptions) {
      if (updateOptions == null) {
        updateOptions = true;
      }
      if (this.controlPath == null) {
        return;
      }
      if (this.selectionRectangle != null) {
        return;
      }
      console.log("select");
      this.selectionRectangleRotation = null;
      this.selectionRectangleScale = null;
      this.updateSelectionRectangle();
      if (g.selectionGroup == null) {
        g.selectionGroup = new Group();
      }
      g.selectionGroup.name = 'selection group';
      g.selectionGroup.addChild(this.group);
      if (updateOptions) {
        g.updateParameters({
          tool: this.constructor,
          item: this
        }, true);
      }
      return g.s = this;
    };

    RPath.prototype.deselect = function() {
      var _ref;
      console.log("deselect");
      if (this.selectionRectangle == null) {
        return;
      }
      if ((_ref = this.selectionRectangle) != null) {
        _ref.remove();
      }
      this.selectionRectangle = null;
      return this.rasterize();
    };

    RPath.prototype.rasterize = function() {};

    RPath.prototype.hitTestAndInitSelection = function(event, userAction) {
      var hitResult;
      hitResult = this.performeHitTest(event.point, this.constructor.hitOptions);
      if (hitResult == null) {
        return null;
      }
      return this.initSelection(event, hitResult, userAction);
    };

    RPath.prototype.initSelection = function(event, hitResult, userAction) {
      var change;
      if (userAction == null) {
        userAction = true;
      }
      change = 'move';
      if (hitResult.type === 'segment') {
        if (hitResult.item === this.controlPath) {
          this.selectedSegment = hitResult.segment;
          change = 'segment';
        } else if (hitResult.item === this.selectionRectangle) {
          if (hitResult.segment.index >= 2 && hitResult.segment.index <= 4) {
            this.selectionRectangleRotation = event.point.subtract(this.selectionRectangle.bounds.center);
            change = 'rotation';
          } else {
            this.selectionRectangleScale = event.point.subtract(this.selectionRectangle.bounds.center).length;
            change = 'scale';
          }
        }
      }
      return change;
    };

    RPath.prototype.selectBegin = function(event, userAction) {
      var change, _ref;
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectBegin");
      this.changed = null;
      if (this.selectedSegment != null) {
        this.selectedSegment = null;
      }
      if (this.selectedHandle != null) {
        this.selectedHandle = null;
      }
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      this.selectionRectangleRotation = null;
      this.selectionRectangleScale = null;
      if (userAction) {
        this.select();
      }
      change = this.hitTestAndInitSelection(event, userAction);
      if (g.fastMode && change !== 'move') {
        g.hideOthers(this);
      }
      return change;
    };

    RPath.prototype.selectUpdate = function(event, userAction) {
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectUpdate");
    };

    RPath.prototype.selectEnd = function(event, userAction) {
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectEnd");
      this.selectionRectangleRotation = null;
      this.selectionRectangleScale = null;
      if (userAction && (this.changed != null)) {
        this.update('point');
      }
      this.changed = null;
      if (g.fastMode) {
        return g.showAll(this);
      }
    };

    RPath.prototype.doubleClick = function(event, userAction) {
      if (userAction == null) {
        userAction = true;
      }
    };

    RPath.prototype.loadPath = function(points) {
      var i, point, _i, _len;
      for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
        point = points[i];
        if (i === 0) {
          this.createBegin(point, null, true);
        } else {
          this.createUpdate(point, null, true);
        }
      }
      if (points.length > 0) {
        this.createEnd(points.last(), null, true);
      }
      return this.draw();
    };

    RPath.prototype.parameterChanged = function(update) {
      if (update == null) {
        update = true;
      }
      this.draw();
      if (update) {
        return g.defferedExecution(this.update, this.getPk());
      }
    };

    RPath.prototype.addPath = function(path) {
      if (path == null) {
        path = new Path();
      }
      path.name = 'group path';
      path.controller = this;
      path.strokeColor = this.data.strokeColor;
      path.strokeWidth = this.data.strokeWidth;
      path.fillColor = this.data.fillColor;
      this.drawing.addChild(path);
      return path;
    };

    RPath.prototype.initializeDrawing = function(createCanvas) {
      var canvas, position, _ref, _ref1, _ref2;
      if (createCanvas == null) {
        createCanvas = false;
      }
      if ((_ref = this.raster) != null) {
        _ref.remove();
      }
      this.raster = null;
      this.controlPath.strokeWidth = this.pathWidth();
      if ((_ref1 = this.drawing) != null) {
        _ref1.remove();
      }
      this.drawing = new Group();
      this.drawing.name = "drawing";
      this.drawing.strokeColor = this.data.strokeColor;
      this.drawing.strokeWidth = this.data.strokeWidth;
      this.drawing.fillColor = this.data.fillColor;
      this.drawing.insertBelow(this.controlPath);
      this.drawing.controlPath = this.controlPath;
      this.drawing.controller = this;
      this.group.addChild(this.drawing);
      if (createCanvas) {
        canvas = document.createElement("canvas");
        if (this.controlPath.length <= 1) {
          canvas.width = view.size.width;
          canvas.height = view.size.height;
          position = view.center;
        } else {
          canvas.width = this.controlPath.strokeBounds.width;
          canvas.height = this.controlPath.strokeBounds.height;
          position = this.controlPath.strokeBounds.center;
        }
        if ((_ref2 = this.canvasRaster) != null) {
          _ref2.remove();
        }
        this.canvasRaster = new Raster(canvas, position);
        this.group.addChild(this.canvasRaster);
        this.context = this.canvasRaster.canvas.getContext("2d");
        this.context.strokeStyle = this.data.strokeColor;
        this.context.fillStyle = this.data.fillColor;
        this.context.lineWidth = this.data.strokeWidth;
      }
    };

    RPath.prototype.initializeAnimation = function(animate) {
      if (animate) {
        if (g.animatedItems.indexOf(this) < 0) {
          g.animatedItems.push(this);
        }
      } else {
        if (g.animatedItems.indexOf(this) >= 0) {
          g.animatedItems.splice(this, 1);
        }
      }
    };

    RPath.prototype.draw = function() {};

    RPath.prototype.initialize = function() {};

    RPath.prototype.createBegin = function(event, point) {};

    RPath.prototype.createUpdate = function(point, event) {};

    RPath.prototype.createEnd = function(event, point) {
      this.initialize();
    };

    RPath.prototype.updateZIndex = function() {
      var i, path, _i, _len, _ref, _results;
      if (this.date != null) {
        if (g.sortedPaths.length === 0) {
          g.sortedPaths.push(this);
        }
        _ref = g.sortedPaths;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          path = _ref[i];
          if (this.date > path.date) {
            g.sortedPaths.splice(i + 1, 0, this);
            _results.push(this.insertAbove(path));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    RPath.prototype.insertAbove = function(path) {
      this.controlPath.insertAbove(path.controlPath);
      return this.drawing.insertBelow(this.controlPath);
    };

    RPath.prototype.getData = function() {
      return this.data;
    };

    RPath.prototype.getStringifiedData = function() {
      return JSON.stringify(this.getData());
    };

    RPath.prototype.planet = function() {
      return projectToPlanet(this.controlPath.segments[0].point);
    };

    RPath.prototype.prepareUpdate = function() {
      var p0, path;
      path = this.controlPath;
      if (path.segments.length < 2) {
        p0 = path.segments[0].point;
        path.add(new Point(p0.x + 1, p0.y));
      }
      if (g.pathOverlapsTwoPlanets(path)) {
        romanesco_alert("You can not create nor update a line in between two planets, this is not yet supported.", "info");
        return false;
      }
      return true;
    };

    RPath.prototype.save = function() {
      if (this.controlPath == null) {
        return;
      }
      if (!this.prepareUpdate()) {
        return;
      }
      Dajaxice.draw.savePath(this.save_callback, {
        'points': this.pathOnPlanet(),
        'pID': this.id,
        'planet': this.planet(),
        'object_type': this.constructor.rname,
        'data': this.getStringifiedData()
      });
    };

    RPath.prototype.save_callback = function(result) {
      g.checkError(result);
      return this.setPK(result.pk);
    };

    RPath.prototype.update = function(type) {
      console.log("update: " + this.pk);
      if (this.pk == null) {
        return;
      }
      if (!this.prepareUpdate()) {
        return;
      }
      Dajaxice.draw.updatePath(this.updatePath_callback, {
        'pk': this.pk,
        'points': this.pathOnPlanet(),
        'planet': this.planet(),
        'data': this.getStringifiedData()
      });
      this.changed = null;
    };

    RPath.prototype.updatePath_callback = function(result) {
      g.checkError(result);
    };

    RPath.prototype.getPk = function() {
      if (this.pk != null) {
        return this.pk;
      } else {
        return this.id;
      }
    };

    RPath.prototype.setPK = function(pk, updateRoom) {
      if (updateRoom == null) {
        updateRoom = true;
      }
      this.pk = pk;
      g.paths[pk] = this;
      g.items[pk] = this;
      delete g.paths[this.id];
      if (updateRoom) {
        g.chatSocket.emit("setPathPK", g.me, this.id, this.pk);
      }
    };

    RPath.prototype.remove = function() {
      this.deselect();
      this.group.remove();
      this.controlPath = null;
      this.drawing = null;
      if (this.raster == null) {
        this.raster = null;
      }
      if (this.canvasRaster == null) {
        this.canvasRaster = null;
      }
      this.group = null;
      g.sortedPaths.remove(this);
      if (this.pk != null) {
        delete g.paths[this.pk];
        return delete g.items[this.pk];
      } else {
        return delete g.paths[this.id];
      }
    };

    RPath.prototype["delete"] = function() {
      this.remove();
      if (this.pk == null) {
        return;
      }
      console.log(this.pk);
      Dajaxice.draw.deletePath(this.deletePath_callback, {
        pk: this.pk
      });
      return this.pk = null;
    };

    RPath.prototype.deletePath_callback = function(result) {
      if (g.checkError(result)) {
        return g.chatSocket.emit("delete path", result.pk);
      }
    };

    RPath.prototype.planet = function() {
      return projectToPlanet(this.controlPath.segments[0].point);
    };

    RPath.prototype.pathOnPlanet = function(controlSegments) {
      var p, planet, points, segment, _i, _len;
      if (controlSegments == null) {
        controlSegments = this.controlPath.segments;
      }
      points = [];
      planet = this.planet();
      for (_i = 0, _len = controlSegments.length; _i < _len; _i++) {
        segment = controlSegments[_i];
        p = projectToPosOnPlanet(segment.point, planet);
        points.push(pointToArray(p));
      }
      return points;
    };

    return RPath;

  })();

  this.RPath = RPath;

  PrecisePath = (function(_super) {
    __extends(PrecisePath, _super);

    PrecisePath.rname = 'Precise path';

    PrecisePath.rdescription = "This path offers precise controls, one can modify points along with their handles and their type.";

    PrecisePath.hitOptions = {
      segments: true,
      stroke: true,
      fill: true,
      selected: true,
      curves: true,
      handles: true,
      tolerance: 5
    };

    PrecisePath.secureStep = 25;

    PrecisePath.parameters = function() {
      var parameters;
      parameters = PrecisePath.__super__.constructor.parameters.call(this);
      parameters['General'].polygonMode = {
        type: 'checkbox',
        label: 'Polygon mode',
        "default": g.polygonMode,
        onChange: function(value) {
          return g.polygonMode = value;
        }
      };
      parameters['Edit curve'] = {
        smooth: {
          type: 'checkbox',
          label: 'Smooth',
          "default": false
        },
        pointType: {
          type: 'dropdown',
          label: 'Point type',
          values: ['smooth', 'corner', 'point'],
          "default": 'smooth',
          addController: true,
          onChange: function(value) {
            var item, _i, _len, _ref;
            _ref = g.selectedItems();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              if (typeof item.changeSelectedPoint === "function") {
                item.changeSelectedPoint(true, value);
              }
            }
          }
        },
        deletePoint: {
          type: 'button',
          label: 'Delete point',
          "default": function() {
            var item, _i, _len, _ref;
            _ref = g.selectedItems();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              if (typeof item.deleteSelectedPoint === "function") {
                item.deleteSelectedPoint();
              }
            }
          }
        },
        simplify: {
          type: 'button',
          label: 'Simplify',
          "default": function() {
            var item, _i, _len, _ref, _ref1;
            _ref = g.selectedItems();
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              item = _ref[_i];
              if ((_ref1 = item.controlPath) != null) {
                _ref1.simplify();
              }
              item.draw();
              item.update();
            }
          }
        }
      };
      return parameters;
    };

    function PrecisePath(date, data, pk, points) {
      this.date = date != null ? date : null;
      this.data = data != null ? data : null;
      this.pk = pk != null ? pk : null;
      if (points == null) {
        points = null;
      }
      PrecisePath.__super__.constructor.call(this, this.date, this.data, this.pk, points);
      this.data.polygonMode = g.polygonMode;
    }

    PrecisePath.prototype.loadPath = function(points) {
      var distanceMax, flattenedPath, i, index, point, recordedPoint, resultingPoint, time, _i, _j, _len, _ref;
      this.createBegin(posOnPlanetToProject(this.data.points[0], this.data.planet), null, true);
      _ref = this.data.points;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = _i += 4) {
        point = _ref[i];
        if (i > 0) {
          this.controlPath.add(posOnPlanetToProject(point, this.data.planet));
        }
        this.controlPath.lastSegment.handleIn = new Point(this.data.points[i + 1]);
        this.controlPath.lastSegment.handleOut = new Point(this.data.points[i + 2]);
        this.controlPath.lastSegment.rtype = this.data.points[i + 3];
      }
      if (points.length === 2) {
        this.controlPath.add(points[1]);
      }
      this.createEnd(posOnPlanetToProject(this.data.points[this.data.points.length - 4], this.data.planet), null, true);
      time = Date.now();
      flattenedPath = this.controlPath.copyTo(project);
      flattenedPath.flatten(this.constructor.secureStep);
      distanceMax = this.constructor.secureDistance * this.constructor.secureDistance;
      for (i = _j = 1; _j <= 10; i = ++_j) {
        index = Math.floor(Math.random() * points.length);
        recordedPoint = points[index];
        resultingPoint = flattenedPath.segments[index].point;
        if (recordedPoint.getDistance(resultingPoint, true) > distanceMax) {
          flattenedPath.strokeColor = 'red';
          view.center = flattenedPath.bounds.center;
          console.log("Error: invalid path");
          return;
        }
      }
      flattenedPath.remove();
      return console.log("Time to secure the path: " + ((Date.now() - time) / 1000) + " sec.");
    };

    PrecisePath.prototype.hitTest = function(point, hitOptions) {
      var hitResult, _ref, _ref1;
      if ((_ref = this.speedGroup) != null ? _ref.visible : void 0) {
        hitResult = (_ref1 = this.handleGroup) != null ? _ref1.hitTest(point) : void 0;
      }
      if (hitResult == null) {
        hitResult = this.selectionRectangle.hitTest(point);
      }
      if (hitResult == null) {
        hitResult = this.controlPath.hitTest(point, hitOptions);
      }
      return hitResult;
    };

    PrecisePath.prototype.initializeDrawing = function(createCanvas) {
      var _base;
      if (createCanvas == null) {
        createCanvas = false;
      }
      if ((_base = this.data).step == null) {
        _base.step = 20;
      }
      this.offset = 0;
      PrecisePath.__super__.initializeDrawing.call(this, createCanvas);
    };

    PrecisePath.prototype.drawBegin = function(createCanvas) {
      if (createCanvas == null) {
        createCanvas = false;
      }
      console.log("drawBegin");
      this.initializeDrawing(createCanvas);
      this.path = this.addPath();
      this.path.segments = this.controlPath.segments;
      this.path.selected = false;
    };

    PrecisePath.prototype.drawUpdate = function(offset) {
      console.log("drawUpdate");
      this.path.segments = this.controlPath.segments;
      this.path.selected = false;
    };

    PrecisePath.prototype.drawEnd = function() {
      this.path.segments = this.controlPath.segments;
      this.path.selected = false;
    };

    PrecisePath.prototype.checkUpdateBrush = function(event) {
      var controlPathLength, step;
      step = this.data.step;
      controlPathLength = this.controlPath.length;
      while (this.offset + step < controlPathLength) {
        this.offset += step;
        this.drawUpdate(this.offset);
      }
    };

    PrecisePath.prototype.initializeControlPath = function(point) {
      this.group = new Group();
      this.group.name = "group";
      this.group.controller = this;
      this.controlPath = new Path();
      this.group.addChild(this.controlPath);
      this.controlPath.name = "controlPath";
      this.controlPath.controller = this;
      this.controlPath.strokeWidth = this.pathWidth();
      this.controlPath.strokeColor = 'black';
      this.controlPath.visible = false;
      this.controlPath.add(point);
    };

    PrecisePath.prototype.createBegin = function(point, event, loading) {
      if (loading == null) {
        loading = false;
      }
      PrecisePath.__super__.createBegin.call(this);
      if (loading) {
        this.initializeControlPath(point);
      } else {
        if (RLock.intersectPoint(point)) {
          return;
        }
        if (!this.data.polygonMode) {
          this.initializeControlPath(point);
          this.drawBegin();
        } else {
          if (this.controlPath == null) {
            this.initializeControlPath(point);
            this.controlPath.add(point);
            this.drawBegin();
          } else {
            this.controlPath.add(point);
          }
          this.controlPath.lastSegment.rtype = 'point';
        }
      }
    };

    PrecisePath.prototype.createUpdate = function(point, event, loading) {
      var lastSegment, previousSegment;
      if (loading == null) {
        loading = false;
      }
      if (!this.data.polygonMode) {
        if (this.inLockedArea) {
          return;
        }
        if (RLock.intersectPoint(point)) {
          this.inLockedArea = true;
          this.save();
          return;
        }
        this.controlPath.add(point);
        if (!loading) {
          this.checkUpdateBrush(event);
        }
      } else {
        lastSegment = this.controlPath.lastSegment;
        previousSegment = lastSegment.previous;
        previousSegment.rtype = 'smooth';
        previousSegment.handleOut = point.subtract(previousSegment.point);
        if (lastSegment !== this.controlPath.firstSegment) {
          previousSegment.handleIn = previousSegment.handleOut.multiply(-1);
        }
        lastSegment.handleIn = lastSegment.handleOut = null;
        lastSegment.point = point;
        this.draw(true);
      }
    };

    PrecisePath.prototype.createMove = function(event) {
      this.controlPath.lastSegment.point = event.point;
      this.draw(true);
    };

    PrecisePath.prototype.createEnd = function(point, event, loading) {
      if (loading == null) {
        loading = false;
      }
      if (this.data.polygonMode) {
        if (loading) {
          this.finishPath(loading);
        }
      } else {
        this.inLockedArea = false;
        if (!loading && this.controlPath.segments.length >= 2) {
          if (this.speeds != null) {
            this.computeSpeed();
          }
          this.controlPath.simplify();
          if (this.speeds != null) {
            this.updateSpeed();
          }
        }
        this.finishPath(loading);
      }
      PrecisePath.__super__.createEnd.call(this);
    };

    PrecisePath.prototype.finishPath = function(loading) {
      if (loading == null) {
        loading = false;
      }
      if (this.data.polygonMode && !loading) {
        this.controlPath.lastSegment.remove();
        this.controlPath.lastSegment.handleOut = null;
      }
      if (this.controlPath.segments.length < 2) {
        this.remove();
        return;
      }
      if (this.data.smooth) {
        this.controlPath.smooth();
      }
      if (!loading) {
        this.checkUpdateBrush();
        this.drawEnd();
        this.offset = 0;
      }
      this.draw(false, loading);
      this.rasterize();
    };

    PrecisePath.prototype.simplifiedModeOn = function() {
      var folder, folderName, name, parameter, _ref;
      this.previousData = {};
      _ref = this.constructor.parameters();
      for (folderName in _ref) {
        folder = _ref[folderName];
        for (name in folder) {
          parameter = folder[name];
          if ((parameter.simplified != null) && (this.data[name] != null)) {
            this.previousData[name] = this.data[name];
            this.data[name] = parameter.simplified;
          }
        }
      }
    };

    PrecisePath.prototype.simplifiedModeOff = function() {
      var folder, folderName, name, parameter, _ref;
      _ref = this.constructor.parameters();
      for (folderName in _ref) {
        folder = _ref[folderName];
        for (name in folder) {
          parameter = folder[name];
          if ((parameter.simplified != null) && (this.data[name] != null) && (this.previousData[name] != null)) {
            this.data[name] = this.previousData[name];
            delete this.previousData[name];
          }
        }
      }
    };

    PrecisePath.prototype.draw = function(simplified, loading) {
      var controlPathLength, error, nIteration, nf, offset, reminder, step;
      if (simplified == null) {
        simplified = false;
      }
      if (loading == null) {
        loading = false;
      }
      if (this.controlPath.segments.length < 2) {
        return;
      }
      if (simplified) {
        this.simplifiedModeOn();
      }
      step = this.data.step;
      controlPathLength = this.controlPath.length;
      nf = controlPathLength / step;
      nIteration = Math.floor(nf);
      reminder = nf - nIteration;
      offset = reminder * step / 2;
      try {
        this.drawBegin();
        while (offset < controlPathLength) {
          this.drawUpdate(offset);
          offset += step;
        }
        this.drawEnd();
      } catch (_error) {
        error = _error;
        console.error(error);
        throw error;
      }
      if (simplified) {
        this.simplifiedModeOff();
      } else {
        this.rasterize();
      }
    };

    PrecisePath.prototype.pathOnPlanet = function() {
      var flatennedPath;
      flatennedPath = this.controlPath.copyTo(project);
      flatennedPath.flatten(this.constructor.secureStep);
      flatennedPath.remove();
      return PrecisePath.__super__.pathOnPlanet.call(this, flatennedPath.segments);
    };

    PrecisePath.prototype.getData = function() {
      var segment, _i, _len, _ref;
      this.data.planet = projectToPlanet(this.controlPath.segments[0].point);
      this.data.points = [];
      _ref = this.controlPath.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        this.data.points.push(projectToPosOnPlanet(segment.point));
        this.data.points.push(g.pointToObj(segment.handleIn));
        this.data.points.push(g.pointToObj(segment.handleOut));
        this.data.points.push(segment.rtype);
      }
      return this.data;
    };

    PrecisePath.prototype.select = function(updateOptions) {
      if (updateOptions == null) {
        updateOptions = true;
      }
      if (this.controlPath == null) {
        return;
      }
      if (this.selectionRectangle != null) {
        return;
      }
      this.index = this.controlPath.index;
      this.controlPath.bringToFront();
      this.controlPath.selected = true;
      PrecisePath.__super__.select.call(this, updateOptions);
      if (!this.data.smooth) {
        return this.controlPath.fullySelected = true;
      }
    };

    PrecisePath.prototype.deselect = function() {
      var _ref;
      this.controlPath.selected = false;
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      return PrecisePath.__super__.deselect.call(this);
    };

    PrecisePath.prototype.highlightSelectedPoint = function() {
      var offset, point, _base, _ref, _ref1;
      if (!this.controlPath.selected) {
        return;
      }
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      if (this.selectedSegment == null) {
        return;
      }
      point = this.selectedSegment.point;
      if ((_base = this.selectedSegment).rtype == null) {
        _base.rtype = 'smooth';
      }
      switch (this.selectedSegment.rtype) {
        case 'smooth':
          this.selectionHighlight = new Path.Circle(point, 5);
          break;
        case 'corner':
          offset = new Point(5, 5);
          this.selectionHighlight = new Path.Rectangle(point.subtract(offset), point.add(offset));
          break;
        case 'point':
          this.selectionHighlight = new Path.RegularPolygon(point, 3, 5);
      }
      this.selectionHighlight.name = 'selection highlight';
      this.selectionHighlight.controller = this;
      this.selectionHighlight.strokeColor = g.selectionBlue;
      this.selectionHighlight.strokeWidth = 1;
      this.group.addChild(this.selectionHighlight);
      if (((_ref1 = this.parameterControllers) != null ? _ref1.pointType : void 0) != null) {
        g.setControllerValue(this.parameterControllers.pointType, null, this.selectedSegment.rtype, this);
      }
    };

    PrecisePath.prototype.initSelection = function(event, hitResult, userAction) {
      var change, specialKey, _ref;
      if (userAction == null) {
        userAction = true;
      }
      specialKey = g.specialKey(event);
      this.selectedSegment = null;
      this.selectedHandle = null;
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      change = 'move';
      if (hitResult.type === 'segment') {
        if (specialKey) {
          hitResult.segment.remove();
          this.changed = change = 'deleted point';
        } else {
          if (hitResult.item === this.controlPath) {
            this.selectedSegment = hitResult.segment;
            change = 'segment';
          } else if (hitResult.item === this.selectionRectangle) {
            if (hitResult.segment.index >= 2 && hitResult.segment.index <= 4) {
              this.selectionRectangleRotation = 0;
              change = 'rotation';
            } else {
              this.selectionRectangleScale = event.point.subtract(this.selectionRectangle.bounds.center).length / this.controlPath.scaling.x;
              change = 'scale';
            }
          }
        }
      }
      if (!this.data.smooth) {
        if (hitResult.type === "handle-in") {
          this.selectedHandle = hitResult.segment.handleIn;
          this.selectedSegment = hitResult.segment;
          change = 'handle-in';
        } else if (hitResult.type === "handle-out") {
          this.selectedHandle = hitResult.segment.handleOut;
          this.selectedSegment = hitResult.segment;
          change = 'handle-out';
        }
      }
      if (userAction) {
        this.highlightSelectedPoint();
      }
      return change;
    };

    PrecisePath.prototype.selectUpdate = function(event, userAction) {
      var ratio, rotation, scaling, _ref;
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectUpdate");
      if (this.selectedHandle != null) {
        this.selectedHandle.x += event.delta.x;
        this.selectedHandle.y += event.delta.y;
        if (this.selectedSegment.rtype === 'smooth' || (this.selectedSegment.rtype == null)) {
          if (this.selectedHandle === this.selectedSegment.handleOut && !this.selectedSegment.handleIn.isZero()) {
            this.selectedSegment.handleIn = !event.modifiers.shift ? this.selectedSegment.handleOut.normalize().multiply(-this.selectedSegment.handleIn.length) : this.selectedSegment.handleOut.multiply(-1);
          }
          if (this.selectedHandle === this.selectedSegment.handleIn && !this.selectedSegment.handleOut.isZero()) {
            this.selectedSegment.handleOut = !event.modifiers.shift ? this.selectedSegment.handleIn.normalize().multiply(-this.selectedSegment.handleOut.length) : this.selectedSegment.handleIn.multiply(-1);
          }
        }
        this.updateSelectionRectangle();
        this.draw(true);
        this.changed = 'moved handle';
      } else if (this.selectedSegment != null) {
        this.selectedSegment.point.x += event.delta.x;
        this.selectedSegment.point.y += event.delta.y;
        this.updateSelectionRectangle();
        this.draw(true);
        this.changed = 'moved point';
      } else if (this.selectionRectangleRotation != null) {
        rotation = event.point.subtract(this.selectionRectangle.bounds.center).angle + 90;
        this.controlPath.rotation = rotation;
        this.selectionRectangle.rotation = rotation;
        this.draw(true);
        this.changed = 'rotated';
      } else if (this.selectionRectangleScale != null) {
        ratio = event.point.subtract(this.selectionRectangle.bounds.center).length / this.selectionRectangleScale;
        scaling = new Point(ratio, ratio);
        this.controlPath.scaling = scaling;
        this.selectionRectangle.scaling = scaling;
        this.draw(true);
        this.changed = 'scaled';
      } else {
        this.group.position.x += event.delta.x;
        this.group.position.y += event.delta.y;
        this.updateSelectionRectangle();
        this.changed = 'moved';
      }
      console.log(this.changed);
      if (userAction || (this.selectionRectangle != null)) {
        return (_ref = this.selectionHighlight) != null ? _ref.position = this.selectedSegment.point : void 0;
      }
    };

    PrecisePath.prototype.selectEnd = function(event, userAction) {
      var _ref;
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectEnd");
      if (userAction || (this.selectionRectangle != null)) {
        if ((_ref = this.selectionHighlight) != null) {
          _ref.position = this.selectedSegment.point;
        }
      }
      this.selectedHandle = null;
      if (this.data.smooth) {
        this.controlPath.smooth();
      }
      if ((this.changed != null) && this.changed !== 'moved') {
        this.draw();
      }
      return PrecisePath.__super__.selectEnd.call(this, event, userAction);
    };

    PrecisePath.prototype.smoothPoint = function(segment, offset) {
      var tangent;
      segment.rtype = 'smooth';
      segment.linear = false;
      if (offset == null) {
        offset = segment.location.offset;
      }
      tangent = segment.path.getTangentAt(offset);
      if (segment.previous != null) {
        segment.handleIn = tangent.multiply(-0.25);
      }
      if (segment.next != null) {
        return segment.handleOut = tangent.multiply(+0.25);
      }
    };

    PrecisePath.prototype.doubleClick = function(event, userAction) {
      var hitCurve, hitResult, location, point, segment, specialKey;
      if (userAction == null) {
        userAction = true;
      }
      specialKey = g.specialKey(event);
      point = userAction ? view.viewToProject(new Point(event.pageX, event.pageY)) : event.point;
      hitResult = this.performeHitTest(point, this.constructor.hitOptions);
      if (hitResult == null) {
        return;
      }
      hitCurve = hitResult.type === 'stroke' || hitResult.type === 'curve';
      if (hitResult.type === 'segment') {
        segment = hitResult.segment;
        this.selectedSegment = segment;
        switch (segment.rtype) {
          case 'smooth':
          case null:
          case void 0:
            segment.rtype = 'corner';
            break;
          case 'corner':
            segment.rtype = 'point';
            segment.linear = true;
            this.draw();
            break;
          case 'point':
            this.deletePoint(segment);
            break;
          default:
            console.log("segment.rtype not known.");
        }
      } else if (hitCurve && !specialKey) {
        location = hitResult.location;
        segment = hitResult.item.insert(location.index + 1, point);
        if (userAction && !this.data.smooth) {
          segment.selected = true;
        }
        this.selectedSegment = segment;
        this.smoothPoint(segment, location.offset);
      }
      if (userAction) {
        this.highlightSelectedPoint();
      }
      if (hitResult.type === 'segment' || (hitCurve && !specialKey)) {
        if (this.data.smooth) {
          this.controlPath.smooth();
        }
        if (userAction) {
          this.update('point');
        }
      }
    };

    PrecisePath.prototype.deletePoint = function(segment) {
      if (!segment) {
        return;
      }
      this.selectedSegment = segment.next != null ? segment.next : segment.previous;
      if (this.selectedSegment) {
        this.selectionHighlight.position = this.selectedSegment.point;
      }
      segment.remove();
      if (this.controlPath.segments.length <= 1) {
        this["delete"]();
        return;
      }
      if (this.data.smooth) {
        this.controlPath.smooth();
      }
      this.draw();
      return view.draw();
    };

    PrecisePath.prototype.deleteSelectedPoint = function(userAction) {
      if (userAction == null) {
        userAction = true;
      }
      this.deletePoint(this.selectedSegment);
      if ((g.me != null) && userAction) {
        return g.chatSocket.emit("parameter change", g.me, this.pk, "deleteSelectedPoint", null, "rFunction");
      }
    };

    PrecisePath.prototype.changeSelectedPoint = function(userAction, value) {
      if (userAction == null) {
        userAction = true;
      }
      if (this.selectedSegment == null) {
        return;
      }
      if (this.data.smooth) {
        return;
      }
      this.selectedSegment.rtype = value;
      switch (value) {
        case 'corner':
          if (this.selectedSegment.linear = true) {
            this.selectedSegment.linear = false;
            this.selectedSegment.handleIn = this.selectedSegment.previous.point.subtract(this.selectedSegment.point).multiply(0.5);
            this.selectedSegment.handleOut = this.selectedSegment.next.point.subtract(this.selectedSegment.point).multiply(0.5);
          }
          break;
        case 'point':
          this.selectedSegment.linear = true;
          break;
        case 'smooth':
          this.smoothPoint(this.selectedSegment);
      }
      this.highlightSelectedPoint();
      if ((g.me != null) && userAction) {
        g.chatSocket.emit("parameter change", g.me, this.pk, "changeSelectedPoint", value, "rFunction");
      }
    };

    PrecisePath.prototype.parameterChanged = function(update) {
      var segment, _i, _len, _ref;
      if (update == null) {
        update = true;
      }
      switch (this.changed) {
        case 'smooth':
          if (this.data.smooth) {
            this.controlPath.smooth();
            this.controlPath.fullySelected = false;
            this.controlPath.selected = true;
            _ref = this.controlPath.segments;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              segment = _ref[_i];
              segment.rtype = 'smooth';
            }
          } else {
            this.controlPath.fullySelected = true;
          }
      }
      return PrecisePath.__super__.parameterChanged.call(this, update);
    };

    PrecisePath.prototype.remove = function() {
      var _ref, _ref1;
      if ((_ref = this.selectionHighlight) != null) {
        _ref.remove();
      }
      this.selectionHighlight = null;
      if ((_ref1 = this.canvasRaster) != null) {
        _ref1.remove();
      }
      this.canvasRaster = null;
      return PrecisePath.__super__.remove.call(this);
    };

    return PrecisePath;

  })(RPath);

  this.PrecisePath = PrecisePath;

  SpeedPath = (function(_super) {
    __extends(SpeedPath, _super);

    function SpeedPath() {
      return SpeedPath.__super__.constructor.apply(this, arguments);
    }

    SpeedPath.rname = 'Speed path';

    SpeedPath.rdescription = "This path offers speed.";

    SpeedPath.speedMax = 200;

    SpeedPath.speedStep = 20;

    SpeedPath.secureStep = 25;

    SpeedPath.parameters = function() {
      var parameters;
      parameters = SpeedPath.__super__.constructor.parameters.call(this);
      parameters['Edit curve'].showSpeed = {
        type: 'checkbox',
        label: 'Show speed',
        value: true
      };
      return parameters;
    };

    SpeedPath.prototype.loadPath = function(points) {
      if (this.data == null) {
        this.data = {};
      }
      this.speeds = this.data.speeds || [];
      SpeedPath.__super__.loadPath.call(this, points);
    };

    SpeedPath.prototype.checkUpdateBrush = function(event) {
      var controlPathLength, delta, f, lastSpeed, speed, startOffset, step;
      step = this.data.step;
      controlPathLength = this.controlPath.length;
      if (event != null) {
        delta = event.delta.length;
        startOffset = controlPathLength - delta;
        lastSpeed = this.speeds.last();
      }
      while (this.offset + step < controlPathLength) {
        this.offset += step;
        if (event != null) {
          f = (delta - (this.offset - startOffset)) / delta;
          speed = lastSpeed * (1 - f) + delta * f;
          this.speeds.push(Math.min(speed, this.constructor.speedMax));
        }
        this.drawUpdate(this.offset);
      }
    };

    SpeedPath.prototype.createBegin = function(point, event, loading) {
      if (loading == null) {
        loading = false;
      }
      if (!loading) {
        this.speeds = (g.polygonMode ? [0] : [this.constructor.speedMax / 3]);
      }
      return SpeedPath.__super__.createBegin.call(this, point, event, loading);
    };

    SpeedPath.prototype.createEnd = function(point, event, loading) {
      if (loading == null) {
        loading = false;
      }
      if (!this.data.polygonMode && !loading) {
        this.speeds = [];
      }
      return SpeedPath.__super__.createEnd.call(this, point, event, loading);
    };

    SpeedPath.prototype.computeSpeed = function() {
      var controlPathLength, currentAverageSpeed, currentOffset, distance, distances, f, i, interpolation, nextOffset, offset, point, pointOffset, previousDistance, previousOffset, previousPointOffset, previousSpeed, segment, speed, step, _i, _j, _len, _len1, _ref;
      step = this.constructor.speedStep;
      distances = [];
      controlPathLength = this.controlPath.length;
      currentOffset = step;
      segment = this.controlPath.firstSegment;
      distance = segment.point.getDistance(segment.next.point);
      distances.push({
        speed: distance,
        offset: 0
      });
      previousDistance = 0;
      pointOffset = 0;
      previousPointOffset = 0;
      _ref = this.controlPath.segments;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        segment = _ref[i];
        if (i === 0) {
          continue;
        }
        point = segment.point;
        previousDistance = distance;
        distance = point.getDistance(segment.previous.point);
        previousPointOffset = pointOffset;
        pointOffset += distance;
        while (pointOffset > currentOffset) {
          f = (currentOffset - previousPointOffset) / distance;
          interpolation = previousDistance * (1 - f) + distance * f;
          distances.push({
            speed: interpolation,
            offset: currentOffset
          });
          currentOffset += step;
        }
        distances.push({
          speed: distance,
          offset: pointOffset
        });
      }
      distances.push({
        speed: distance,
        offset: currentOffset
      });
      this.speeds = [];
      nextOffset = step;
      speed = distances.first().speed;
      previousSpeed = speed;
      this.speeds.push(speed);
      offset = 0;
      previousOffset = offset;
      currentAverageSpeed = 0;
      for (i = _j = 0, _len1 = distances.length; _j < _len1; i = ++_j) {
        distance = distances[i];
        if (i === 0) {
          continue;
        }
        previousSpeed = speed;
        speed = distance.speed;
        previousOffset = offset;
        offset = distance.offset;
        currentAverageSpeed += ((speed + previousSpeed) / 2.0) * (offset - previousOffset) / step;
        if (offset === nextOffset) {
          this.speeds.push(Math.min(currentAverageSpeed, this.constructor.speedMax));
          currentAverageSpeed = 0;
          nextOffset += step;
        }
      }
    };

    SpeedPath.prototype.updateSpeed = function() {
      var alreadyExists, controlPathLength, handle, handlePoint, i, j, normal, normalNormalized, o, offset, point, s, speed, speedCurve, speedHandle, speedHandles, speedHandlesLengthM1, step, _i, _j, _len, _ref, _ref1, _ref2;
      if ((_ref = this.speedGroup) != null) {
        _ref.visible = this.data.showSpeed;
      }
      if ((this.speeds == null) || !this.data.showSpeed) {
        return;
      }
      step = this.constructor.speedStep;
      alreadyExists = this.speedGroup != null;
      if (alreadyExists) {
        this.speedGroup.bringToFront();
        speedCurve = this.speedGroup.firstChild;
      } else {
        this.speedGroup = new Group();
        this.speedGroup.name = "speed group";
        this.speedGroup.strokeWidth = 1;
        this.speedGroup.strokeColor = selectionBlue;
        this.speedGroup.controller = this;
        this.group.addChild(this.speedGroup);
        speedCurve = new Path();
        speedCurve.name = "speed curve";
        speedCurve.strokeWidth = 1;
        speedCurve.strokeColor = selectionBlue;
        speedCurve.controller = this;
        this.speedGroup.addChild(speedCurve);
        this.handleGroup = new Group();
        this.handleGroup.name = "speed handle group";
        this.speedGroup.addChild(this.handleGroup);
      }
      speedHandles = this.handleGroup.children;
      offset = 0;
      controlPathLength = this.controlPath.length;
      while ((this.speeds.length - 1) * step < controlPathLength) {
        this.speeds.push(this.speeds.last());
      }
      i = 0;
      _ref1 = this.speeds;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        speed = _ref1[i];
        offset = i > 0 ? i * step : 0.1;
        o = offset < controlPathLength ? offset : controlPathLength - 0.1;
        point = this.controlPath.getPointAt(o);
        normalNormalized = this.controlPath.getNormalAt(o).normalize();
        normal = normalNormalized.multiply(this.speeds[i]);
        handlePoint = point.add(normal);
        if (alreadyExists && i < speedCurve.segments.length) {
          speedCurve.segments[i].point = handlePoint;
          speedHandles[i].position = handlePoint;
          speedHandles[i].rsegment.firstSegment.point = point;
          speedHandles[i].rsegment.lastSegment.point = handlePoint;
          speedHandles[i].rnormal = normalNormalized;
        } else {
          speedCurve.add(handlePoint);
          s = new Path();
          s.name = 'speed segment';
          s.strokeWidth = 1;
          s.strokeColor = selectionBlue;
          s.add(point);
          s.add(handlePoint);
          s.controller = this;
          this.speedGroup.addChild(s);
          handle = new Path.Rectangle(handlePoint.subtract(2), 4);
          handle.name = 'speed handle';
          handle.strokeWidth = 1;
          handle.strokeColor = selectionBlue;
          handle.fillColor = 'white';
          handle.rnormal = normalNormalized;
          handle.rindex = i;
          handle.rsegment = s;
          handle.controller = this;
          this.handleGroup.addChild(handle);
        }
        if (offset > controlPathLength) {
          break;
        }
      }
      if (offset > controlPathLength && i + 1 <= speedHandles.length - 1) {
        speedHandlesLengthM1 = speedHandles.length - 1;
        for (j = _j = _ref2 = i + 1; _ref2 <= speedHandlesLengthM1 ? _j <= speedHandlesLengthM1 : _j >= speedHandlesLengthM1; j = _ref2 <= speedHandlesLengthM1 ? ++_j : --_j) {
          speedHandle = this.handleGroup.lastChild;
          speedHandle.rsegment.remove();
          speedHandle.remove();
          speedCurve.lastSegment.remove();
        }
      }
    };

    SpeedPath.prototype.speedAt = function(offset) {
      var f, i;
      f = offset % this.constructor.speedStep;
      i = (offset - f) / this.constructor.speedStep;
      f /= this.constructor.speedStep;
      if (this.speeds != null) {
        if (i < this.speeds.length - 1) {
          return this.speeds[i] * (1 - f) + this.speeds[i + 1] * f;
        }
        if (i === this.speeds.length - 1) {
          return this.speeds[i];
        }
      } else {
        return this.constructor.speedMax / 2;
      }
    };

    SpeedPath.prototype.draw = function(simplified, loading) {
      if (simplified == null) {
        simplified = false;
      }
      if (loading == null) {
        loading = false;
      }
      SpeedPath.__super__.draw.call(this, simplified, loading);
      if (!loading) {
        this.updateSpeed();
      }
    };

    SpeedPath.prototype.getData = function() {
      var data;
      data = jQuery.extend({}, SpeedPath.__super__.getData.call(this));
      data.speeds = (this.speeds != null) && (this.handleGroup != null) ? this.speeds.slice(0, this.handleGroup.children.length + 1) : this.speeds;
      return data;
    };

    SpeedPath.prototype.select = function(updateOptions) {
      var _ref;
      if (updateOptions == null) {
        updateOptions = true;
      }
      if (this.selectionRectangle != null) {
        return;
      }
      SpeedPath.__super__.select.call(this, updateOptions);
      this.updateSpeed();
      if (this.data.showSpeed) {
        return (_ref = this.speedGroup) != null ? _ref.visible = true : void 0;
      }
    };

    SpeedPath.prototype.deselect = function() {
      var _ref;
      if ((_ref = this.speedGroup) != null) {
        _ref.visible = false;
      }
      return SpeedPath.__super__.deselect.call(this);
    };

    SpeedPath.prototype.initSelection = function(event, hitResult, userAction) {
      var change, _ref;
      if (userAction == null) {
        userAction = true;
      }
      if ((_ref = this.speedSelectionHighlight) != null) {
        _ref.remove();
      }
      this.speedSelectionHighlight = null;
      if (hitResult.item.name === "speed handle") {
        this.selectedSpeedHandle = hitResult.item;
        change = 'speed handle';
        return change;
      }
      return SpeedPath.__super__.initSelection.call(this, event, hitResult, userAction);
    };

    SpeedPath.prototype.selectUpdate = function(event, userAction) {
      var delta, handle, handlePosition, handleToPoint, handlei, i, index, influence, influenceFactor, max, n, newHandleToPoint, projection, projectionLength, sign, speedMax, _i, _ref, _ref1;
      if (userAction == null) {
        userAction = true;
      }
      if (this.selectedSpeedHandle == null) {
        SpeedPath.__super__.selectUpdate.call(this, event, userAction);
      } else {
        if ((_ref = this.speedSelectionHighlight) != null) {
          _ref.remove();
        }
        speedMax = this.constructor.speedMax;
        this.speedSelectionHighlight = new Path();
        this.speedSelectionHighlight.name = 'speed selection highlight';
        this.speedSelectionHighlight.strokeWidth = 1;
        this.speedSelectionHighlight.strokeColor = 'blue';
        this.group.addChild(this.speedSelectionHighlight);
        handle = this.selectedSpeedHandle;
        handlePosition = handle.bounds.center;
        handleToPoint = event.point.subtract(handlePosition);
        projection = handleToPoint.project(handle.rnormal);
        projectionLength = projection.length;
        sign = Math.sign(projection.x) === Math.sign(handle.rnormal.x) && Math.sign(projection.y) === Math.sign(handle.rnormal.y);
        sign = sign ? 1 : -1;
        this.speeds[handle.rindex] += sign * projectionLength;
        if (this.speeds[handle.rindex] < 0) {
          this.speeds[handle.rindex] = 0;
        } else if (this.speeds[handle.rindex] > speedMax) {
          this.speeds[handle.rindex] = speedMax;
        }
        newHandleToPoint = event.point.subtract(handle.position.add(projection));
        influenceFactor = newHandleToPoint.length / (this.constructor.speedStep * 3);
        max = g.gaussian(0, influenceFactor, 0);
        i = 1;
        influence = 1;
        while (influence > 0.1 && i < 20) {
          influence = g.gaussian(0, influenceFactor, i) / max;
          delta = projectionLength * influence;
          for (n = _i = -1; _i <= 1; n = _i += 2) {
            index = handle.rindex + n * i;
            if (index >= 0 && index < this.handleGroup.children.length) {
              handlei = this.handleGroup.children[index];
              this.speeds[index] += sign * delta;
              if (this.speeds[index] < 0) {
                this.speeds[index] = 0;
              } else if (this.speeds[index] > speedMax) {
                this.speeds[index] = speedMax;
              }
            }
          }
          i++;
        }
        this.speedSelectionHighlight.strokeColor.hue -= Math.min(240 * (influenceFactor / 10), 240);
        this.speedSelectionHighlight.add(handle.position.add(projection));
        this.speedSelectionHighlight.add(event.point);
        this.draw(true);
        this.changed = 'speed handle moved';
        if (userAction || (this.selectionRectangle != null)) {
          if ((_ref1 = this.selectionHighlight) != null) {
            _ref1.position = this.selectedSegment.point;
          }
        }
      }
    };

    SpeedPath.prototype.selectEnd = function(event, userAction) {
      var _ref;
      if (userAction == null) {
        userAction = true;
      }
      this.selectedSpeedHandle = null;
      if ((_ref = this.speedSelectionHighlight) != null) {
        _ref.remove();
      }
      this.speedSelectionHighlight = null;
      return SpeedPath.__super__.selectEnd.call(this, event, userAction);
    };

    SpeedPath.prototype.remove = function() {
      var _ref;
      if ((_ref = this.speedGroup) != null) {
        _ref.remove();
      }
      this.speedGroup = null;
      return SpeedPath.__super__.remove.call(this);
    };

    return SpeedPath;

  })(PrecisePath);

  this.SpeedPath = SpeedPath;

  RollerPath = (function(_super) {
    __extends(RollerPath, _super);

    function RollerPath() {
      return RollerPath.__super__.constructor.apply(this, arguments);
    }

    RollerPath.rname = 'Roller brush';

    RollerPath.iconUrl = 'static/images/icons/inverted/rollerBrush.png';

    RollerPath.iconAlt = 'roller brush';

    RollerPath.rdescription = "The stroke width is function of the speed: the faster the wider.";

    RollerPath.parameters = function() {
      var parameters;
      parameters = RollerPath.__super__.constructor.parameters.call(this);
      parameters['Style'].strokeWidth["default"] = 0;
      parameters['Style'].strokeColor.defaultCheck = false;
      parameters['Style'].fillColor.defaultCheck = true;
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 30,
        max: 300,
        "default": 20,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].trackWidth = {
        type: 'slider',
        label: 'Track width',
        min: 1,
        max: 10,
        "default": 2
      };
      return parameters;
    };

    RollerPath.prototype.drawBegin = function() {
      this.initializeDrawing(false);
      this.path = this.addPath();
      this.path.add(this.controlPath.firstSegment.point);
    };

    RollerPath.prototype.drawUpdate = function(offset) {
      var bottom, delta, normal, point, speed, top;
      point = this.controlPath.getPointAt(offset);
      normal = this.controlPath.getNormalAt(offset).normalize();
      speed = this.speedAt(offset);
      delta = normal.multiply(speed * this.data.trackWidth / 2);
      top = point.add(delta);
      bottom = point.subtract(delta);
      this.path.add(top);
      this.path.insert(0, bottom);
    };

    RollerPath.prototype.drawEnd = function() {
      this.path.add(this.controlPath.lastSegment.point);
      this.path.closed = true;
      this.path.smooth();
      this.path.selected = false;
    };

    return RollerPath;

  })(SpeedPath);

  this.RollerPath = RollerPath;

  SpiralPath = (function(_super) {
    __extends(SpiralPath, _super);

    function SpiralPath() {
      return SpiralPath.__super__.constructor.apply(this, arguments);
    }

    SpiralPath.rname = 'Spiral path';

    SpiralPath.rdescription = "Spiral path.";

    SpiralPath.iconUrl = 'static/images/icons/inverted/squareSpiral.png';

    SpiralPath.iconAlt = 'squareSpiral';

    SpiralPath.parameters = function() {
      var parameters;
      parameters = SpiralPath.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 10,
        max: 100,
        "default": 20,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].thickness = {
        type: 'slider',
        label: 'Thickness',
        min: 1,
        max: 30,
        "default": 5,
        step: 1
      };
      parameters['Parameters'].rsmooth = {
        type: 'checkbox',
        label: 'Smooth',
        "default": false
      };
      return parameters;
    };

    SpiralPath.prototype.drawBegin = function() {
      this.initializeDrawing(false);
      this.line = this.addPath();
      this.spiral = this.addPath();
    };

    SpiralPath.prototype.drawUpdate = function(offset) {
      var normal, p1, p2, p3, p4, p5, p6, p7, p8, p9, point, tangent;
      point = this.controlPath.getPointAt(offset);
      normal = this.controlPath.getNormalAt(offset).normalize();
      tangent = normal.rotate(90);
      this.line.add(point);
      this.spiral.add(point.add(normal.multiply(this.data.thickness)));
      p1 = point.add(normal.multiply(this.data.step));
      this.spiral.add(p1);
      p2 = p1.add(tangent.multiply(this.data.step - this.data.thickness));
      this.spiral.add(p2);
      p3 = p2.add(normal.multiply(-(this.data.step - 2 * this.data.thickness)));
      this.spiral.add(p3);
      p4 = p3.add(tangent.multiply(-(this.data.step - 3 * this.data.thickness)));
      this.spiral.add(p4);
      p5 = p4.add(normal.multiply(this.data.thickness));
      this.spiral.add(p5);
      p6 = p5.add(tangent.multiply(this.data.step - 4 * this.data.thickness));
      this.spiral.add(p6);
      p7 = p6.add(normal.multiply(this.data.step - 4 * this.data.thickness));
      this.spiral.add(p7);
      p8 = p7.add(tangent.multiply(-(this.data.step - 3 * this.data.thickness)));
      this.spiral.add(p8);
      p9 = p8.add(normal.multiply(-(this.data.step - 2 * this.data.thickness)));
      this.spiral.add(p9);
    };

    SpiralPath.prototype.drawEnd = function() {
      if (this.data.rsmooth) {
        this.spiral.smooth();
        this.line.smooth();
      }
    };

    return SpiralPath;

  })(PrecisePath);

  this.SpiralPath = SpiralPath;

  FuzzyPath = (function(_super) {
    __extends(FuzzyPath, _super);

    function FuzzyPath() {
      return FuzzyPath.__super__.constructor.apply(this, arguments);
    }

    FuzzyPath.rname = 'Fuzzy brush';

    FuzzyPath.rdescription = "Brush with lines poping out of the path.";

    FuzzyPath.parameters = function() {
      var parameters;
      parameters = FuzzyPath.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 5,
        max: 100,
        "default": 20,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].minWidth = {
        type: 'slider',
        label: 'Min width',
        min: 1,
        max: 100,
        "default": 20
      };
      parameters['Parameters'].maxWidth = {
        type: 'slider',
        label: 'Max width',
        min: 1,
        max: 250,
        "default": 200
      };
      parameters['Parameters'].minSpeed = {
        type: 'slider',
        label: 'Min speed',
        min: 1,
        max: 250,
        "default": 1
      };
      parameters['Parameters'].maxSpeed = {
        type: 'slider',
        label: 'Max speed',
        min: 1,
        max: 250,
        "default": 200
      };
      parameters['Parameters'].nLines = {
        type: 'slider',
        label: 'N lines',
        min: 1,
        max: 5,
        "default": 2,
        simplified: 2,
        step: 1
      };
      parameters['Parameters'].symmetric = {
        type: 'dropdown',
        label: 'Symmetry',
        values: ['symmetric', 'top', 'bottom'],
        "default": 'symmetric'
      };
      parameters['Parameters'].speedForWidth = {
        type: 'checkbox',
        label: 'Speed for width',
        "default": true
      };
      parameters['Parameters'].speedForLength = {
        type: 'checkbox',
        label: 'Speed for length',
        "default": false
      };
      parameters['Parameters'].orthoLines = {
        type: 'checkbox',
        label: 'Orthogonal lines',
        "default": true
      };
      parameters['Parameters'].lengthLines = {
        type: 'checkbox',
        label: 'Length lines',
        "default": true
      };
      return parameters;
    };

    FuzzyPath.prototype.drawBegin = function() {
      var i, nLines, _i;
      this.initializeDrawing(false);
      if (this.data.lengthLines) {
        this.lines = [];
        nLines = this.data.nLines;
        if (this.data.symmetric === 'symmetric') {
          nLines *= 2;
        }
        for (i = _i = 1; 1 <= nLines ? _i <= nLines : _i >= nLines; i = 1 <= nLines ? ++_i : --_i) {
          this.lines.push(this.addPath());
        }
      }
      this.lastOffset = 0;
    };

    FuzzyPath.prototype.drawUpdate = function(offset) {
      var addPoint, midOffset, speed, stepOffset;
      console.log("drawUpdate");
      speed = this.speedAt(offset);
      addPoint = (function(_this) {
        return function(offset, speed) {
          var delta, divisor, i, line, normal, path, point, width, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
          point = _this.controlPath.getPointAt(offset);
          normal = _this.controlPath.getNormalAt(offset).normalize();
          if (_this.data.speedForWidth) {
            width = _this.data.minWidth + (_this.data.maxWidth - _this.data.minWidth) * speed / _this.constructor.speedMax;
          } else {
            width = _this.data.minWidth;
          }
          if (_this.data.lengthLines) {
            divisor = _this.data.nLines > 1 ? _this.data.nLines - 1 : 1;
            if (_this.data.symmetric === 'symmetric') {
              _ref = _this.lines;
              for (i = _i = 0, _len = _ref.length; _i < _len; i = _i += 2) {
                line = _ref[i];
                _this.lines[i + 0].add(point.add(normal.multiply(i * width * 0.5 / divisor)));
                _this.lines[i + 1].add(point.add(normal.multiply(-i * width * 0.5 / divisor)));
              }
            } else {
              if (_this.data.symmetric === 'top') {
                _ref1 = _this.lines;
                for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
                  line = _ref1[i];
                  line.add(point.add(normal.multiply(i * width / divisor)));
                }
              } else if (_this.data.symmetric === 'bottom') {
                _ref2 = _this.lines;
                for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
                  line = _ref2[i];
                  line.add(point.add(normal.multiply(-i * width / divisor)));
                }
              }
            }
          }
          if (_this.data.orthoLines) {
            path = _this.addPath();
            delta = normal.multiply(width);
            switch (_this.data.symmetric) {
              case 'symmetric':
                path.add(point.add(delta));
                path.add(point.subtract(delta));
                break;
              case 'top':
                path.add(point.add(delta));
                path.add(point);
                break;
              case 'bottom':
                path.add(point.subtract(delta));
                path.add(point);
            }
          }
        };
      })(this);
      if (!this.data.speedForLength) {
        addPoint(offset, speed);
      } else {
        speed = this.data.minSpeed + (speed / this.constructor.speedMax) * (this.data.maxSpeed - this.data.minSpeed);
        stepOffset = offset - this.lastOffset;
        if (stepOffset > speed) {
          midOffset = (offset + this.lastOffset) / 2;
          addPoint(midOffset, speed);
          this.lastOffset = offset;
        }
      }
    };

    FuzzyPath.prototype.drawEnd = function() {};

    return FuzzyPath;

  })(SpeedPath);

  this.FuzzyPath = FuzzyPath;

  SketchPath = (function(_super) {
    __extends(SketchPath, _super);

    function SketchPath() {
      return SketchPath.__super__.constructor.apply(this, arguments);
    }

    SketchPath.rname = 'Sketch brush';

    SketchPath.rdescription = "Sketch path.";

    SketchPath.iconUrl = 'static/images/icons/inverted/links.png';

    SketchPath.iconAlt = 'links';

    SketchPath.parameters = function() {
      var parameters;
      parameters = SketchPath.__super__.constructor.parameters.call(this);
      parameters['Style'].strokeColor["default"] = "rgba(0, 0, 0, 0.25)";
      delete parameters['Style'].fillColor;
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 5,
        max: 100,
        "default": 20,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].distance = {
        type: 'slider',
        label: 'Distance',
        min: 5,
        max: 250,
        "default": 100,
        simplified: 100
      };
      return parameters;
    };

    SketchPath.prototype.drawBegin = function() {
      this.initializeDrawing(true);
      this.points = [];
    };

    SketchPath.prototype.drawUpdate = function(offset) {
      var distMax, normal, point, pt, _i, _len, _ref;
      console.log("drawUpdate");
      point = this.controlPath.getPointAt(offset);
      normal = this.controlPath.getNormalAt(offset).normalize();
      point = this.projectToRaster(point);
      this.points.push(point);
      distMax = this.data.distance * this.data.distance;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pt = _ref[_i];
        if (point.getDistance(pt, true) < distMax) {
          this.context.beginPath();
          this.context.moveTo(point.x, point.y);
          this.context.lineTo(pt.x, pt.y);
          this.context.stroke();
        }
      }
    };

    SketchPath.prototype.drawEnd = function() {};

    return SketchPath;

  })(PrecisePath);

  this.SketchPath = SketchPath;

  ShapePath = (function(_super) {
    __extends(ShapePath, _super);

    function ShapePath() {
      return ShapePath.__super__.constructor.apply(this, arguments);
    }

    ShapePath.rname = 'Shape path';

    ShapePath.rdescription = "Places shape along the path.";

    ShapePath.parameters = function() {
      var parameters;
      parameters = ShapePath.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].step = {
        type: 'slider',
        label: 'Step',
        min: 5,
        max: 100,
        "default": 20,
        simplified: 20,
        step: 1
      };
      parameters['Parameters'].minWidth = {
        type: 'slider',
        label: 'Min width',
        min: 1,
        max: 250,
        "default": 1
      };
      parameters['Parameters'].maxWidth = {
        type: 'slider',
        label: 'Max width',
        min: 1,
        max: 250,
        "default": 200
      };
      parameters['Parameters'].speedForLength = {
        type: 'checkbox',
        label: 'Speed for length',
        "default": false
      };
      parameters['Parameters'].minSpeed = {
        type: 'slider',
        label: 'Min speed',
        min: 1,
        max: 250,
        "default": 1
      };
      parameters['Parameters'].maxSpeed = {
        type: 'slider',
        label: 'Max speed',
        min: 1,
        max: 250,
        "default": 200
      };
      return parameters;
    };

    ShapePath.prototype.drawBegin = function() {
      this.initializeDrawing(false);
      this.lastOffset = 0;
    };

    ShapePath.prototype.drawUpdate = function(offset) {
      var addPoint, midOffset, speed, stepOffset;
      console.log("drawUpdate");
      speed = this.speedAt(offset);
      addPoint = (function(_this) {
        return function(offset, height, speed) {
          var normal, point, shape, width;
          point = _this.controlPath.getPointAt(offset);
          normal = _this.controlPath.getNormalAt(offset);
          width = _this.data.minWidth + (_this.data.maxWidth - _this.data.minWidth) * speed / _this.constructor.speedMax;
          shape = _this.addPath(new Path.Rectangle(point.subtract(new Point(width / 2, height / 2)), new Size(width, height)));
          shape.rotation = normal.angle;
        };
      })(this);
      if (!this.data.speedForLength) {
        addPoint(offset, this.data.step, speed);
      } else {
        speed = this.data.minSpeed + (speed / this.constructor.speedMax) * (this.data.maxSpeed - this.data.minSpeed);
        stepOffset = offset - this.lastOffset;
        if (stepOffset > speed) {
          midOffset = (offset + this.lastOffset) / 2;
          addPoint(midOffset, stepOffset, speed);
          this.lastOffset = offset;
        }
      }
    };

    ShapePath.prototype.drawEnd = function() {};

    return ShapePath;

  })(SpeedPath);

  this.ShapePath = ShapePath;

  RShape = (function(_super) {
    __extends(RShape, _super);

    function RShape() {
      return RShape.__super__.constructor.apply(this, arguments);
    }

    RShape.Shape = paper.Path.Rectangle;

    RShape.rname = 'Shape';

    RShape.rdescription = "Base shape class";

    RShape.squareByDefault = true;

    RShape.centerByDefault = false;

    RShape.prototype.loadPath = function(points) {
      var distanceMax, i, point, _i, _len;
      if (this.data.rectangle == null) {
        console.log('Error loading shape ' + this.pk + ': invalid rectangle.');
      }
      this.rectangle = this.data.rectangle != null ? new Rectangle(this.data.rectangle.x, this.data.rectangle.y, this.data.rectangle.width, this.data.rectangle.height) : new Rectangle();
      this.initializeControlPath(this.rectangle.topLeft, this.rectangle.bottomRight, false, false, true);
      this.draw();
      this.controlPath.rotation = this.data.rotation;
      this.initialize();
      distanceMax = this.constructor.secureDistance * this.constructor.secureDistance;
      for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
        point = points[i];
        this.controlPath.segments[i].point === point;
        if (this.controlPath.segments[i].point.getDistance(point, true) > distanceMax) {
          this.controlPath.strokeColor = 'red';
          view.center = this.controlPath.bounds.center;
          console.log("Error: invalid shape!");
          return;
        }
      }
    };

    RShape.prototype.moveBy = function(delta) {
      this.rectangle.center.x += delta.x;
      this.rectangle.center.y += delta.y;
      RShape.__super__.moveBy.call(this, delta);
    };

    RShape.prototype.moveTo = function(position) {
      this.rectangle.center = position;
      RShape.__super__.moveTo.call(this, position);
    };

    RShape.prototype.updateSelectionRectangle = function() {
      var bounds, _ref;
      bounds = this.rectangle.clone().expand(10 + this.pathWidth() / 2);
      if ((_ref = this.selectionRectangle) != null) {
        _ref.remove();
      }
      this.selectionRectangle = new Path.Rectangle(bounds);
      this.group.addChild(this.selectionRectangle);
      this.selectionRectangle.name = 'selection rectangle';
      this.selectionRectangle.pivot = this.selectionRectangle.bounds.center;
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top));
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top - 25));
      this.selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top));
      this.selectionRectangle.rotation = this.data.rotation;
      this.selectionRectangle.selected = true;
      this.selectionRectangle.controller = this;
      return this.controlPath.pivot = this.selectionRectangle.pivot;
    };

    RShape.prototype.selectUpdate = function(event, userAction) {
      var delta, direction, length, _ref, _ref1;
      if (userAction == null) {
        userAction = true;
      }
      console.log("selectUpdate");
      if (this.selectionRectangleRotation != null) {
        direction = event.point.subtract(this.selectionRectangle.bounds.center);
        delta = this.selectionRectangleRotation.getDirectedAngle(direction);
        this.selectionRectangleRotation = direction;
        this.data.rotation += delta;
        this.selectionRectangle.rotation += delta;
        if ((_ref = this.raster) != null) {
          _ref.rotation += delta;
        }
        this.changed = 'rotated';
        return this.draw();
      } else if (this.selectionRectangleScale != null) {
        length = event.point.subtract(this.selectionRectangle.bounds.center).length;
        delta = length / this.selectionRectangleScale;
        this.selectionRectangleScale = length;
        this.rectangle = this.rectangle.scale(delta);
        this.selectionRectangle.scale(delta);
        if ((_ref1 = this.raster) != null) {
          _ref1.scale(delta);
        }
        this.changed = 'scaled';
        return this.draw();
      } else {
        this.group.position.x += event.delta.x;
        this.group.position.y += event.delta.y;
        this.rectangle.x += event.delta.x;
        this.rectangle.y += event.delta.y;
        return this.changed = 'moved';
      }
    };

    RShape.prototype.pathWidth = function() {
      return this.data.strokeWidth;
    };

    RShape.prototype.createShape = function() {
      return this.shape = this.addPath(new this.constructor.Shape(this.rectangle));
    };

    RShape.prototype.draw = function() {
      var error;
      try {
        this.initializeDrawing();
        this.createShape();
        this.drawing.rotation = this.data.rotation;
        return this.rasterize();
      } catch (_error) {
        error = _error;
        console.error(error);
        throw error;
      }
    };

    RShape.prototype.initializeControlPath = function(pointA, pointB, shift, specialKey, load) {
      var center, createFromCenter, delta, height, min, square, width, _base, _ref;
      this.group = new Group();
      this.group.name = "group";
      this.group.controller = this;
      if (load) {
        this.rectangle = new Rectangle(pointA, pointB);
      } else {
        square = this.constructor.squareByDefault ? !shift : shift;
        createFromCenter = this.constructor.centerByDefault ? !specialKey : specialKey;
        if (createFromCenter) {
          delta = pointB.subtract(pointA);
          this.rectangle = new Rectangle(pointA.subtract(delta), pointB);
          if (square) {
            center = this.rectangle.center;
            if (this.rectangle.width > this.rectangle.height) {
              this.rectangle.width = this.rectangle.height;
            } else {
              this.rectangle.height = this.rectangle.width;
            }
            this.rectangle.center = center;
          }
        } else {
          if (!square) {
            this.rectangle = new Rectangle(pointA, pointB);
          } else {
            width = pointA.x - pointB.x;
            height = pointA.y - pointB.y;
            min = Math.min(Math.abs(width), Math.abs(height));
            this.rectangle = new Rectangle(pointA, pointA.subtract(g.sign(width) * min, g.sign(height) * min));
          }
        }
      }
      if ((_ref = this.controlPath) != null) {
        _ref.remove();
      }
      this.controlPath = new Path.Rectangle(this.rectangle);
      this.group.addChild(this.controlPath);
      this.controlPath.name = "controlPath";
      this.controlPath.controller = this;
      this.controlPath.strokeWidth = this.pathWidth();
      this.controlPath.strokeColor = 'black';
      this.controlPath.visible = false;
      if ((_base = this.data).rotation == null) {
        _base.rotation = 0;
      }
    };

    RShape.prototype.createBegin = function(point, event, loading) {
      var _ref;
      RShape.__super__.createBegin.call(this);
      this.downPoint = point;
      this.initializeControlPath(this.downPoint, point, event != null ? (_ref = event.modifiers) != null ? _ref.shift : void 0 : void 0, g.specialKey(event));
      if (!loading) {
        return this.draw();
      }
    };

    RShape.prototype.createUpdate = function(point, event, loading) {
      var _ref, _ref1;
      console.log(" event.modifiers.command");
      console.log(event.modifiers.command);
      console.log(g.specialKey(event));
      console.log(event != null ? (_ref = event.modifiers) != null ? _ref.shift : void 0 : void 0);
      this.initializeControlPath(this.downPoint, point, event != null ? (_ref1 = event.modifiers) != null ? _ref1.shift : void 0 : void 0, g.specialKey(event));
      if (!loading) {
        return this.draw();
      }
    };

    RShape.prototype.createEnd = function(point, event, loading) {
      var _ref;
      this.initializeControlPath(this.downPoint, point, event != null ? (_ref = event.modifiers) != null ? _ref.shift : void 0 : void 0, g.specialKey(event));
      this.draw();
      return RShape.__super__.createEnd.call(this);
    };

    RShape.prototype.getData = function() {
      var data;
      data = jQuery.extend({}, this.data);
      data.rectangle = {
        x: this.rectangle.x,
        y: this.rectangle.y,
        width: this.rectangle.width,
        height: this.rectangle.height
      };
      return data;
    };

    return RShape;

  })(RPath);

  this.RShape = RShape;

  RectangleShape = (function(_super) {
    __extends(RectangleShape, _super);

    function RectangleShape() {
      return RectangleShape.__super__.constructor.apply(this, arguments);
    }

    RectangleShape.Shape = paper.Path.Rectangle;

    RectangleShape.rname = 'Rectangle';

    RectangleShape.rdescription = "Simple rectangle, square by default (use shift key to change to a rectangle). It can have rounded corners.";

    RectangleShape.parameters = function() {
      var parameters;
      parameters = RectangleShape.__super__.constructor.parameters.call(this);
      if (parameters['Style'] == null) {
        parameters['Style'] = {};
      }
      parameters['Style'].cornerRadius = {
        type: 'slider',
        label: 'Corner radius',
        min: 0,
        max: 100,
        "default": 0
      };
      return parameters;
    };

    RectangleShape.prototype.createShape = function() {
      return this.shape = this.addPath(new this.constructor.Shape(this.rectangle, this.data.cornerRadius));
    };

    return RectangleShape;

  })(RShape);

  this.RectangleShape = RectangleShape;

  EllipseShape = (function(_super) {
    __extends(EllipseShape, _super);

    function EllipseShape() {
      return EllipseShape.__super__.constructor.apply(this, arguments);
    }

    EllipseShape.Shape = paper.Path.Ellipse;

    EllipseShape.rname = 'Ellipse';

    EllipseShape.iconUrl = 'static/images/icons/inverted/circle.png';

    EllipseShape.iconAlt = 'circle';

    EllipseShape.rdescription = "Simple ellipse, circle by default (use shift key to change to an ellipse).";

    EllipseShape.squareByDefault = true;

    EllipseShape.centerByDefault = true;

    return EllipseShape;

  })(RShape);

  this.EllipseShape = EllipseShape;

  StarShape = (function(_super) {
    __extends(StarShape, _super);

    function StarShape() {
      this.onFrame = __bind(this.onFrame, this);
      return StarShape.__super__.constructor.apply(this, arguments);
    }

    StarShape.Shape = paper.Path.Star;

    StarShape.rname = 'Star';

    StarShape.rdescription = "Star shape.";

    StarShape.iconUrl = 'static/images/icons/inverted/star.png';

    StarShape.iconAlt = 'star';

    StarShape.parameters = function() {
      var parameters;
      parameters = StarShape.__super__.constructor.parameters.call(this);
      if (parameters['Style'] == null) {
        parameters['Style'] = {};
      }
      parameters['Style'].nPoints = {
        type: 'slider',
        label: 'N points',
        min: 1,
        max: 100,
        "default": 5,
        step: 2
      };
      parameters['Style'].internalRadius = {
        type: 'slider',
        label: 'Internal radius',
        min: -200,
        max: 100,
        "default": 37
      };
      parameters['Style'].rsmooth = {
        type: 'checkbox',
        label: 'Smooth',
        "default": false
      };
      parameters['Style'].animate = {
        type: 'checkbox',
        label: 'Animate',
        "default": false
      };
      return parameters;
    };

    StarShape.prototype.initialize = function() {
      this.initializeAnimation(this.data.animate);
    };

    StarShape.prototype.createShape = function() {
      var externalRadius, internalRadius, rectangle;
      rectangle = this.rectangle;
      if (this.data.internalRadius > -100) {
        externalRadius = rectangle.width / 2;
        internalRadius = externalRadius * this.data.internalRadius / 100;
      } else {
        internalRadius = rectangle.width / 2;
        externalRadius = internalRadius * 100 / this.data.internalRadius;
      }
      this.shape = this.addPath(new this.constructor.Shape(rectangle.center, this.data.nPoints, externalRadius, internalRadius));
      if (this.data.rsmooth) {
        return this.shape.smooth();
      }
    };

    StarShape.prototype.onFrame = function(event) {
      this.shape.strokeColor.hue += 1;
      this.shape.rotation += 1;
    };

    return StarShape;

  })(RShape);

  this.StarShape = StarShape;

  SpiralShape = (function(_super) {
    __extends(SpiralShape, _super);

    function SpiralShape() {
      this.onFrame = __bind(this.onFrame, this);
      return SpiralShape.__super__.constructor.apply(this, arguments);
    }

    SpiralShape.Shape = paper.Path.Ellipse;

    SpiralShape.rname = 'Spiral';

    SpiralShape.rdescription = "Spiral shape, can have an intern radius, and any number of sides.";

    SpiralShape.parameters = function() {
      var parameters;
      parameters = SpiralShape.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].minRadius = {
        type: 'slider',
        label: 'Minimum radius',
        min: 0,
        max: 100,
        "default": 0
      };
      parameters['Parameters'].nTurns = {
        type: 'slider',
        label: 'Number of turns',
        min: 1,
        max: 50,
        "default": 10
      };
      parameters['Parameters'].nSides = {
        type: 'slider',
        label: 'Sides',
        min: 3,
        max: 100,
        "default": 50
      };
      parameters['Parameters'].animate = {
        type: 'checkbox',
        label: 'Animate',
        "default": false
      };
      parameters['Parameters'].rotationSpeed = {
        type: 'slider',
        label: 'Rotation speed',
        min: -10,
        max: 10,
        "default": 1
      };
      return parameters;
    };

    SpiralShape.prototype.initialize = function() {
      this.initializeAnimation(this.data.animate);
    };

    SpiralShape.prototype.createShape = function() {
      var angle, angleStep, c, hh, hw, i, radiusStepX, radiusStepY, rectangle, spiralHeight, spiralWidth, step, _i, _j, _ref, _ref1;
      this.shape = this.addPath();
      rectangle = this.rectangle;
      hw = rectangle.width / 2;
      hh = rectangle.height / 2;
      c = rectangle.center;
      angle = 0;
      angleStep = 360.0 / this.data.nSides;
      spiralWidth = hw - hw * this.data.minRadius / 100.0;
      spiralHeight = hh - hh * this.data.minRadius / 100.0;
      radiusStepX = (spiralWidth / this.data.nTurns) / this.data.nSides;
      radiusStepY = (spiralHeight / this.data.nTurns) / this.data.nSides;
      for (i = _i = 0, _ref = this.data.nTurns - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (step = _j = 0, _ref1 = this.data.nSides - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; step = 0 <= _ref1 ? ++_j : --_j) {
          this.shape.add(new Point(c.x + hw * Math.cos(angle), c.y + hh * Math.sin(angle)));
          angle += 2.0 * Math.PI * angleStep / 360.0;
          hw -= radiusStepX;
          hh -= radiusStepY;
        }
      }
      this.shape.add(new Point(c.x + hw * Math.cos(angle), c.y + hh * Math.sin(angle)));
    };

    SpiralShape.prototype.onFrame = function(event) {
      this.shape.strokeColor.hue += 1;
      this.shape.rotation += this.data.rotationSpeed;
    };

    return SpiralShape;

  })(RShape);

  this.SpiralShape = SpiralShape;

  FaceShape = (function(_super) {
    __extends(FaceShape, _super);

    function FaceShape() {
      return FaceShape.__super__.constructor.apply(this, arguments);
    }

    FaceShape.Shape = paper.Path.Rectangle;

    FaceShape.rname = 'Face generator';

    FaceShape.rdescription = "Face generator, inspired by weird faces study by Matthias Drfelt aka mokafolio.";

    FaceShape.parameters = function() {
      var parameters;
      parameters = FaceShape.__super__.constructor.parameters.call(this);
      if (parameters['Parameters'] == null) {
        parameters['Parameters'] = {};
      }
      parameters['Parameters'].minRadius = {
        type: 'slider',
        label: 'Minimum radius',
        min: 0,
        max: 100,
        "default": 0
      };
      parameters['Parameters'].nTurns = {
        type: 'slider',
        label: 'Number of turns',
        min: 1,
        max: 50,
        "default": 10
      };
      parameters['Parameters'].nSides = {
        type: 'slider',
        label: 'Sides',
        min: 3,
        max: 100,
        "default": 50
      };
      return parameters;
    };

    FaceShape.prototype.createShape = function() {
      var center, deltaX, eyeLeft, eyeRight, height, i, noze, nozeLeft, nozeRight, nozeShape, position, rangeRandC, rangeRandMM, segment, size, width, x, y, _i, _j, _len, _ref, _ref1;
      this.headShape = this.addPath(new Path.Ellipse(this.rectangle.expand(-20, -10)));
      this.headShape.flatten(50);
      _ref = this.headShape.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        segment.point.x += Math.random() * 20;
        segment.point.y += Math.random() * 5;
        segment.handleIn += Math.random() * 5;
        segment.handleOut += Math.random() * 5;
      }
      this.headShape.smooth();
      nozeShape = Math.random();
      center = this.rectangle.center;
      width = this.rectangle.width;
      height = this.rectangle.height;
      rangeRandMM = function(min, max) {
        return min + (max - min) * Math.random();
      };
      rangeRandC = function(center, amplitude) {
        return center + amplitude * (Math.random() - 0.5);
      };
      if (nozeShape < 0.333) {
        deltaX = 0.1 * width + Math.random() * 10;
        x = center.x - deltaX;
        y = center.y + rangeRandC(0, 5);
        position = center.add(x, y);
        size = new Size(Math.random() * 5, Math.random() * 5);
        nozeLeft = this.addPath(new Path.Ellipse(position, size));
        position += 2 * deltaX;
        size = new Size(Math.random() * 5, Math.random() * 5);
        nozeRight = this.addPath(new Path.Ellipse(position, size));
      } else if (nozeShape < 0.666) {
        noze = this.addPath();
        noze.add(center);
        noze.add(center.add(Math.random() * 15, Math.random() * 5));
        noze.add(center.add(0, rangeRandMM(5, 10)));
        noze.smooth();
      } else {
        noze = this.addPath();
        noze.add(center);
        noze.add(center.add(-Math.random() * 15, Math.random() * 5));
        noze.add(center.add(0, rangeRandMM(15, 20)));
        noze.smooth();
      }
      deltaX = rangeRandC(0, 0.1 * width);
      x = center.x - deltaX;
      y = this.rectangle.top + width / 3 + rangeRandC(0, 10);
      position = new Point(x, y);
      size = new Size(Math.max(Math.random() * 30, deltaX), Math.random() * 30);
      eyeLeft = this.addPath(new Path.Ellipse(position, size));
      position.x += 2 * deltaX;
      eyeRight = this.addPath(new Path.Ellipse(position, size));
      eyeRight.position.x += rangeRandC(0, 5);
      eyeLeft.position.x += rangeRandC(0, 5);
      for (i = _j = 1, _ref1 = eyeLeft.segments.length - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        eyeLeft.segments[i].point.x += Math.random() * 3;
        eyeLeft.segments[i].point.y += Math.random() * 3;
        eyeRight.segments[i].point.x += Math.random() * 3;
        eyeRight.segments[i].point.y += Math.random() * 3;
      }
    };

    return FaceShape;

  })(RShape);

  this.FaceShape = FaceShape;

  Checkpoint = (function(_super) {
    __extends(Checkpoint, _super);

    Checkpoint.Shape = paper.Path.Rectangle;

    Checkpoint.rname = 'Checkpoint';

    Checkpoint.rdescription = "Checkpoint.";

    Checkpoint.squareByDefault = false;

    function Checkpoint(date, data, pk, points) {
      this.date = date != null ? date : null;
      this.data = data != null ? data : null;
      this.pk = pk != null ? pk : null;
      if (points == null) {
        points = null;
      }
      Checkpoint.__super__.constructor.call(this, this.date, this.data, this.pk, points);
      return;
    }

    Checkpoint.prototype.initialize = function() {
      var _base;
      this.game = g.gameAt(this.rectangle.center);
      if (this.game != null) {
        if (this.game.checkpoints.indexOf(this) < 0) {
          this.game.checkpoints.push(this);
        }
        if ((_base = this.data).checkpointNumber == null) {
          _base.checkpointNumber = this.game.checkpoints.indexOf(this);
        }
      }
    };

    Checkpoint.prototype.createShape = function() {
      this.data.strokeColor = 'rgb(150,30,30)';
      this.data.fillColor = null;
      this.shape = this.addPath(new Path.Rectangle(this.rectangle));
      this.text = this.addPath(new PointText(this.rectangle.center.add(0, 4)));
      this.text.content = this.data.checkpointNumber != null ? 'Checkpoint ' + this.data.checkpointNumber : 'Checkpoint';
      this.text.justification = 'center';
    };

    Checkpoint.prototype.contains = function(point) {
      var delta;
      delta = point.subtract(this.rectangle.center);
      delta.rotation = -this.data.rotation;
      return this.rectangle.contains(this.rectangle.center.add(delta));
    };

    Checkpoint.prototype.remove = function() {
      var _ref;
      if ((_ref = this.game) != null) {
        _ref.checkpoints.remove(this);
      }
      Checkpoint.__super__.remove.call(this);
    };

    return Checkpoint;

  })(RShape);

  this.Checkpoint = Checkpoint;

}).call(this);

//# sourceMappingURL=path.map
