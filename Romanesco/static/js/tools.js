// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  define(['utils', 'zeroClipboard', 'item', 'lock', 'div', 'path', 'jquery', 'paper', 'bootstrap'], function(utils, ZeroClipboard) {
    var CarTool, CodeTool, GradientTool, ItemTool, LockTool, MediaTool, MoveTool, PathTool, RTool, ScreenshotTool, SelectTool, TextTool, g;
    g = utils.g();
    RTool = (function() {

      /*
      		parameters =
      			'First folder':
      				firstParameter:
      					type: 'slider' 									# type is only required when adding a color (then it must be 'color') or a string input (then it must be 'string')
      																	 * if type is 'string' and there is no onChange nor onFinishChange callback:
      																	 * the default onChange callback will be called on onFinishChange since we often want to update only when the change is finished
      																	 * to override this behaviour, 'fireOnEveryChange' can be set to true or onChange and onFinishChange can be defined
      					label: 'Name of the parameter'					# label of the controller (name displayed in the gui)
      					value: 0										# value (deprecated)
      					default: 0 										# default value
      					step: 5 										# values will be incremented/decremented by step
      					min: 0 											# minimum value
      					max: 100 										# maximum value
      					simplified: 0 									# value during the simplified mode (useful to quickly draw an RPath, for example when modifying a curve)
      					defaultFunction: () -> 							# called to get a default value
      					addController: true 							# if true: adds the dat.gui controller to the item or the selected tool
      					onChange: (value)->  							# called when controller changes
      					onFinishChange: (value)-> 						# called when controller finishes change
      					setValue: (value, item)-> 						# called on set value of controller
      					permanent: true									# if true: the controller is never removed (always says in dat.gui)
      					defaultCheck: true 								# checked/activated by default or not
      					initializeController: (controller, item)->		# called just after controller is added to dat.gui, enables to customize the gui and add functionalities
      					fireOnEveryChange: false 						# if true and *type* is input: the default onChange callback will be called on everychange
      				secondParameter:
      					type: 'slider'
      					label: 'Second parameter'
      					value: 1
      					min: 0
      					max: 10
      			'Second folder':
      				thirdParameter:
      					type: 'slider'
      					label: 'Third parameter'
      					value: 1
      					min: 0
      					max: 10
       */
      RTool.parameters = function() {
        return {};
      };

      function RTool(name, cursorPosition, cursorDefault) {
        var description, popoverOptions;
        this.name = name;
        this.cursorPosition = cursorPosition != null ? cursorPosition : {
          x: 0,
          y: 0
        };
        this.cursorDefault = cursorDefault != null ? cursorDefault : "default";
        g.tools[this.name] = this;
        if (this.btnJ == null) {
          this.btnJ = g.toolsJ.find('li[data-name="' + this.name + '"]');
        }
        this.cursorName = this.btnJ.attr("data-cursor");
        this.btnJ.click((function(_this) {
          return function() {
            return _this.select();
          };
        })(this));
        popoverOptions = {
          placement: 'right',
          container: 'body',
          trigger: 'hover',
          delay: {
            show: 500,
            hide: 100
          }
        };
        description = this.description();
        if (description == null) {
          popoverOptions.content = this.name;
        } else {
          popoverOptions.title = this.name;
          popoverOptions.content = description;
        }
        this.btnJ.popover(popoverOptions);
        return;
      }

      RTool.prototype.description = function() {
        return null;
      };

      RTool.prototype.select = function(constructor, selectedItem, deselectItems) {
        var differentTool, _ref;
        if (constructor == null) {
          constructor = this.constructor;
        }
        if (selectedItem == null) {
          selectedItem = null;
        }
        if (deselectItems == null) {
          deselectItems = true;
        }
        differentTool = g.previousTool !== g.selectedTool;
        if (this !== g.selectedTool) {
          g.previousTool = g.selectedTool;
        }
        if ((_ref = g.selectedTool) != null) {
          _ref.deselect();
        }
        g.selectedTool = this;
        if (this.cursorName != null) {
          g.stageJ.css('cursor', 'url(static/images/cursors/' + this.cursorName + '.png) ' + this.cursorPosition.x + ' ' + this.cursorPosition.y + ',' + this.cursorDefault);
        } else {
          g.stageJ.css('cursor', this.cursorDefault);
        }
        if (deselectItems) {
          g.deselectAll();
        }
        g.cancelCallNextFrame('updateParametersForSelectedItems');
        g.updateParameters({
          tool: constructor,
          item: selectedItem
        }, differentTool);
      };

      RTool.prototype.deselect = function() {};

      RTool.prototype.begin = function(event) {};

      RTool.prototype.update = function(event) {};

      RTool.prototype.move = function(event) {};

      RTool.prototype.end = function(event) {};

      RTool.prototype.keyUp = function(event) {};

      RTool.prototype.disableSnap = function() {
        return false;
      };

      return RTool;

    })();
    g.RTool = RTool;
    CodeTool = (function(_super) {
      __extends(CodeTool, _super);

      function CodeTool() {
        CodeTool.__super__.constructor.call(this, "Script");
        return;
      }

      CodeTool.prototype.select = function() {
        CodeTool.__super__.select.call(this);
        g.showEditor();
      };

      return CodeTool;

    })(RTool);
    g.CodeTool = CodeTool;
    MoveTool = (function(_super) {
      __extends(MoveTool, _super);

      function MoveTool() {
        MoveTool.__super__.constructor.call(this, "Move", {
          x: 32,
          y: 32
        }, "move");
        this.prevPoint = {
          x: 0,
          y: 0
        };
        this.dragging = false;
        return;
      }

      MoveTool.prototype.select = function() {
        var div, _i, _len, _ref;
        MoveTool.__super__.select.call(this, this.constructor, null, false);
        g.stageJ.addClass("moveTool");
        _ref = g.divs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          div = _ref[_i];
          div.disableInteraction();
        }
      };

      MoveTool.prototype.deselect = function() {
        var div, _i, _len, _ref;
        MoveTool.__super__.deselect.call(this);
        g.stageJ.removeClass("moveTool");
        _ref = g.divs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          div = _ref[_i];
          div.enableInteraction();
        }
      };

      MoveTool.prototype.begin = function(event) {};

      MoveTool.prototype.update = function(event) {};

      MoveTool.prototype.end = function(moved) {};

      MoveTool.prototype.beginNative = function(event) {
        this.dragging = true;
        this.initialPosition = {
          x: event.pageX,
          y: event.pageY
        };
        this.prevPoint = {
          x: event.pageX,
          y: event.pageY
        };
      };

      MoveTool.prototype.updateNative = function(event) {
        if (this.dragging) {
          g.RMoveBy({
            x: (this.prevPoint.x - event.pageX) / view.zoom,
            y: (this.prevPoint.y - event.pageY) / view.zoom
          });
          this.prevPoint = {
            x: event.pageX,
            y: event.pageY
          };
        }
      };

      MoveTool.prototype.endNative = function(event) {
        this.dragging = false;
      };

      return MoveTool;

    })(RTool);
    g.MoveTool = MoveTool;
    CarTool = (function(_super) {
      __extends(CarTool, _super);

      CarTool.parameters = function() {
        var parameters;
        parameters = {
          'Car': {
            speed: {
              type: 'string',
              label: 'Speed',
              value: '0',
              addController: true,
              onChange: function() {}
            },
            volume: {
              type: 'slider',
              label: 'Volume',
              value: 1,
              min: 0,
              max: 10,
              onChange: function(value) {
                if (g.selectedTool.constructor.name === "CarTool") {
                  if (value > 0) {
                    if (!g.sound.isPlaying) {
                      g.sound.play();
                      g.sound.setLoopStart(3.26);
                      g.sound.setLoopEnd(5.22);
                    }
                    g.sound.setVolume(0.1 * value);
                  } else {
                    g.sound.stop();
                  }
                }
              }
            }
          }
        };
        return parameters;
      };

      function CarTool() {
        CarTool.__super__.constructor.call(this, "Car");
        return;
      }

      CarTool.prototype.select = function() {
        CarTool.__super__.select.call(this);
        this.car = new Raster("/static/images/car.png");
        g.carLayer.addChild(this.car);
        this.car.position = view.center;
        this.speed = 0;
        this.direction = new Point(0, -1);
        this.car.onLoad = function() {
          console.log('car loaded');
        };
        this.previousSpeed = 0;
        g.sound.setVolume(0.1);
        g.sound.play(0);
        g.sound.setLoopStart(3.26);
        g.sound.setLoopEnd(5.22);
        this.lastUpdate = Date.now();
      };

      CarTool.prototype.deselect = function() {
        CarTool.__super__.deselect.call(this);
        this.car.remove();
        this.car = null;
        g.sound.stop();
      };

      CarTool.prototype.onFrame = function() {
        var maxRate, maxSpeed, minRate, minSpeed, rate, _ref, _ref1, _ref2;
        if (this.car == null) {
          return;
        }
        minSpeed = 0.05;
        maxSpeed = 100;
        if (Key.isDown('right')) {
          this.direction.angle += 5;
        }
        if (Key.isDown('left')) {
          this.direction.angle -= 5;
        }
        if (Key.isDown('up')) {
          if (this.speed < maxSpeed) {
            this.speed++;
          }
        } else if (Key.isDown('down')) {
          if (this.speed > -maxSpeed) {
            this.speed--;
          }
        } else {
          this.speed *= 0.9;
          if (Math.abs(this.speed) < minSpeed) {
            this.speed = 0;
          }
        }
        minRate = 0.25;
        maxRate = 3;
        rate = minRate + Math.abs(this.speed) / maxSpeed * (maxRate - minRate);
        g.sound.setRate(rate);
        this.previousSpeed = this.speed;
        if ((_ref = this.parameterControllers) != null) {
          if ((_ref1 = _ref['speed']) != null) {
            _ref1.setValue(this.speed.toFixed(2));
          }
        }
        this.car.rotation = this.direction.angle + 90;
        if (Math.abs(this.speed) > minSpeed) {
          this.car.position = this.car.position.add(this.direction.multiply(this.speed));
          g.RMoveTo(this.car.position);
        }
        if ((_ref2 = g.gameAt(this.car.position)) != null) {
          _ref2.updateGame(this);
        }
        if (Date.now() - this.lastUpdate > 150) {
          if (g.me != null) {
            g.chatSocket.emit("car move", g.me, this.car.position, this.car.rotation, this.speed);
          }
          this.lastUpdate = Date.now();
        }
      };

      CarTool.prototype.keyUp = function(event) {
        switch (event.key) {
          case 'escape':
            g.tools['Move'].select();
        }
      };

      return CarTool;

    })(RTool);
    g.CarTool = CarTool;
    SelectTool = (function(_super) {
      var hitOptions;

      __extends(SelectTool, _super);

      hitOptions = {
        stroke: true,
        fill: true,
        handles: true,
        segments: true,
        curves: true,
        selected: true,
        tolerance: 5
      };

      function SelectTool() {
        SelectTool.__super__.constructor.call(this, "Select");
        this.selectedItem = null;
        return;
      }

      SelectTool.prototype.select = function() {
        var _ref;
        this.selectedItem = g.selectedItems.first();
        SelectTool.__super__.select.call(this, ((_ref = this.selectedItem) != null ? _ref.constructor : void 0) || this.constructor, this.selectedItem, false);
      };

      SelectTool.prototype.createSelectionRectangle = function(event) {
        var bounds, item, itemsToHighlight, name, rectangle, rectanglePath, _ref;
        rectangle = new Rectangle(event.downPoint, event.point);
        if (g.currentPaths[g.me] != null) {
          g.updatePathRectangle(g.currentPaths[g.me], rectangle);
        } else {
          rectanglePath = new Path.Rectangle(rectangle);
          rectanglePath.name = 'select tool selection rectangle';
          rectanglePath.strokeColor = g.selectionBlue;
          rectanglePath.strokeScaling = false;
          rectanglePath.dashArray = [10, 4];
          g.selectionLayer.addChild(rectanglePath);
          g.currentPaths[g.me] = rectanglePath;
        }
        itemsToHighlight = [];
        _ref = g.items;
        for (name in _ref) {
          item = _ref[name];
          item.unhighlight();
          bounds = item.getBounds();
          if (bounds.intersects(rectangle)) {
            item.highlight();
            console.log(item.highlightRectangle.index);
          }
          if (rectangle.area === 0) {
            break;
          }
        }
      };

      SelectTool.prototype.begin = function(event) {
        var hitResult, name, path, _base, _ref, _ref1, _ref2;
        if (event.event.which === 2) {
          return;
        }
        console.log('begin select');
        g.logElapsedTime();
        _ref = g.paths;
        for (name in _ref) {
          path = _ref[name];
          path.prepareHitTest();
        }
        hitResult = g.project.hitTest(event.point, hitOptions);
        _ref1 = g.paths;
        for (name in _ref1) {
          path = _ref1[name];
          path.finishHitTest();
        }
        if (hitResult && (hitResult.item.controller != null)) {
          this.selectedItem = hitResult.item.controller;
          if (!event.modifiers.shift) {
            if (g.selectedItems.length > 0) {
              if (g.selectedItems.indexOf((_ref2 = hitResult.item) != null ? _ref2.controller : void 0) < 0) {
                g.commandManager.add(new g.DeselectCommand(), true);
              }
            }
          } else {
            g.tools['Screenshot'].checkRemoveScreenshotRectangle(hitResult.item.controller);
          }
          if (typeof (_base = hitResult.item.controller).beginSelect === "function") {
            _base.beginSelect(event);
          }
        } else {
          g.deselectAll();
          this.createSelectionRectangle(event);
        }
        g.logElapsedTime();
      };

      SelectTool.prototype.update = function(event) {
        if (!g.currentPaths[g.me]) {
          this.selectedItem.updateSelect(event);
        } else {
          this.createSelectionRectangle(event);
        }
      };

      SelectTool.prototype.end = function(event) {
        var child, i, item, itemsAreSiblings, itemsToSelect, lock, locksToSelect, name, parent, rectangle, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
        if (!g.currentPaths[g.me]) {
          this.selectedItem.endSelect(event);
          this.selectedItem = null;
        } else {
          rectangle = new Rectangle(event.downPoint, event.point);
          itemsToSelect = [];
          locksToSelect = [];
          _ref = g.items;
          for (name in _ref) {
            item = _ref[name];
            if (item.getBounds().intersects(rectangle)) {
              if (g.RLock.prototype.isPrototypeOf(item)) {
                locksToSelect.push(item);
              } else {
                itemsToSelect.push(item);
              }
            }
          }
          if (itemsToSelect.length === 0) {
            itemsToSelect = locksToSelect;
          }
          if (itemsToSelect.length > 0) {
            itemsAreSiblings = true;
            parent = itemsToSelect.first().group.parent;
            for (_i = 0, _len = itemsToSelect.length; _i < _len; _i++) {
              item = itemsToSelect[_i];
              if (item.group.parent !== parent) {
                itemsAreSiblings = false;
                break;
              }
            }
            if (!itemsAreSiblings) {
              for (_j = 0, _len1 = locksToSelect.length; _j < _len1; _j++) {
                lock = locksToSelect[_j];
                _ref1 = lock.children();
                for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                  child = _ref1[_k];
                  itemsToSelect.remove(child);
                }
              }
              itemsToSelect = itemsToSelect.concat(locksToSelect);
            }
            if (rectangle.area === 0) {
              itemsToSelect = [itemsToSelect.first()];
            }
            g.commandManager.add(new g.SelectCommand(itemsToSelect), true);
            i = itemsToSelect.length - 1;
            while (i >= 0) {
              item = itemsToSelect[i];
              if (!item.isSelected()) {
                itemsToSelect.remove(item);
              }
              i--;
            }
          }
          g.currentPaths[g.me].remove();
          delete g.currentPaths[g.me];
          _ref2 = g.items;
          for (name in _ref2) {
            item = _ref2[name];
            item.unhighlight();
          }
        }
        console.log('end select');
        g.logElapsedTime();
      };

      SelectTool.prototype.doubleClick = function(event) {
        var item, _i, _len, _ref;
        _ref = g.selectedItems;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (typeof item.doubleClick === "function") {
            item.doubleClick(event);
          }
        }
      };

      SelectTool.prototype.disableSnap = function() {
        return g.currentPaths[g.me] != null;
      };

      SelectTool.prototype.keyUp = function(event) {
        var delta, item, selectedItems, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        if ((_ref = event.key) === 'left' || _ref === 'right' || _ref === 'up' || _ref === 'down') {
          delta = event.modifiers.shift ? 50 : event.modifiers.option ? 5 : 1;
        }
        switch (event.key) {
          case 'right':
            _ref1 = g.selectedItems;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              item = _ref1[_i];
              item.moveBy(new Point(delta, 0), true);
            }
            break;
          case 'left':
            _ref2 = g.selectedItems;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              item = _ref2[_j];
              item.moveBy(new Point(-delta, 0), true);
            }
            break;
          case 'up':
            _ref3 = g.selectedItems;
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              item = _ref3[_k];
              item.moveBy(new Point(0, -delta), true);
            }
            break;
          case 'down':
            _ref4 = g.selectedItems;
            for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
              item = _ref4[_l];
              item.moveBy(new Point(0, delta), true);
            }
            break;
          case 'escape':
            g.deselectAll();
            break;
          case 'delete':
          case 'backspace':
            selectedItems = g.selectedItems.slice();
            for (_m = 0, _len4 = selectedItems.length; _m < _len4; _m++) {
              item = selectedItems[_m];
              if (((_ref5 = item.selectionState) != null ? _ref5.segment : void 0) != null) {
                item.deletePointCommand();
              } else {
                item.deleteCommand();
              }
            }
        }
      };

      return SelectTool;

    })(RTool);
    g.SelectTool = SelectTool;
    PathTool = (function(_super) {
      __extends(PathTool, _super);

      function PathTool(RPath, justCreated) {
        var favorite, _ref;
        this.RPath = RPath;
        if (justCreated == null) {
          justCreated = false;
        }
        this.name = this.RPath.rname;
        if (justCreated && (g.tools[this.name] != null)) {
          g[this.RPath.constructor.name] = this.RPath;
          g.tools[this.name].remove();
          delete g.tools[this.name];
          g.lastPathCreated = this.RPath;
        }
        this.btnJ = g.allToolsJ.find('li[data-name="' + this.name + '"]');
        if (this.btnJ.length === 0) {
          favorite = justCreated || ((_ref = g.favoriteTools) != null ? _ref.indexOf(this.name) : void 0) >= 0;
          this.btnJ = g.createToolButton(this.name, this.RPath.iconURL, favorite, this.RPath.category);
        } else {
          this.btnJ.off("click");
        }
        if (this.name === 'Precise path') {
          this.RPath.iconURL = null;
        }
        PathTool.__super__.constructor.call(this, this.RPath.rname, this.RPath.cursorPosition, this.RPath.cursorDefault, this.RPath.options);
        if (justCreated) {
          this.select();
        }
        return;
      }

      PathTool.prototype.description = function() {
        return this.RPath.rdescription;
      };

      PathTool.prototype.remove = function() {
        this.btnJ.remove();
      };

      PathTool.prototype.select = function() {
        g.rasterizer.drawItems();
        PathTool.__super__.select.call(this, this.RPath);
        g.tool.onMouseMove = function(event) {
          event = g.snap(event);
          g.selectedTool.move(event);
        };
      };

      PathTool.prototype.deselect = function() {
        PathTool.__super__.deselect.call(this);
        this.finish();
        g.tool.onMouseMove = null;
      };

      PathTool.prototype.begin = function(event, from, data) {
        var _ref;
        if (from == null) {
          from = g.me;
        }
        if (data == null) {
          data = null;
        }
        if (event.event.which === 2) {
          return;
        }
        if (100 * view.zoom < 10) {
          g.romanesco_alert("You can not draw path at a zoom smaller than 10.", "Info");
          return;
        }
        if (!((g.currentPaths[from] != null) && ((_ref = g.currentPaths[from].data) != null ? _ref.polygonMode : void 0))) {
          g.deselectAll();
          g.currentPaths[from] = new this.RPath(Date.now(), data);
        }
        g.currentPaths[from].beginCreate(event.point, event, false);
        if ((g.me != null) && from === g.me) {
          data = g.currentPaths[from].data;
          data.id = g.currentPaths[from].id;
          g.chatSocket.emit("bounce", {
            tool: this.name,
            "function": "begin",
            "arguments": [event, g.me, data]
          });
        }
      };

      PathTool.prototype.update = function(event, from) {
        if (from == null) {
          from = g.me;
        }
        g.currentPaths[from].updateCreate(event.point, event, false);
        if ((g.me != null) && from === g.me) {
          g.chatSocket.emit("bounce", {
            tool: this.name,
            "function": "update",
            "arguments": [event, g.me]
          });
        }
      };

      PathTool.prototype.move = function(event) {
        var _base, _ref, _ref1;
        if ((_ref = g.currentPaths[g.me]) != null ? (_ref1 = _ref.data) != null ? _ref1.polygonMode : void 0 : void 0) {
          if (typeof (_base = g.currentPaths[g.me]).createMove === "function") {
            _base.createMove(event);
          }
        }
      };

      PathTool.prototype.createPath = function(event, from) {
        var bounds, lock, locks, path, _i, _len;
        path = g.currentPaths[from];
        if ((g.me != null) && from === g.me) {
          if (path.rectangle.area === 0) {
            path.remove();
            delete g.currentPaths[from];
            return;
          }
          bounds = path.getBounds();
          locks = g.RLock.getLocksWhichIntersect(bounds);
          for (_i = 0, _len = locks.length; _i < _len; _i++) {
            lock = locks[_i];
            if (lock.rectangle.contains(bounds)) {
              if (lock.owner === g.me) {
                lock.addItem(path);
              } else {
                g.romanesco_alert("The path intersects with a lock", "Warning");
                path.remove();
                delete g.currentPaths[from];
                return;
              }
            }
          }
          if (path.getDrawingBounds().area > g.rasterizer.maxArea()) {
            g.romanesco_alert("The path is too big", "Warning");
            path.remove();
            delete g.currentPaths[from];
            return;
          }
          if ((g.me != null) && from === g.me) {
            g.chatSocket.emit("bounce", {
              tool: this.name,
              "function": "createPath",
              "arguments": [event, g.me]
            });
          }
          path.save(true);
          path.select(false);
        } else {
          path.endCreate(event.point, event);
        }
        delete g.currentPaths[from];
      };

      PathTool.prototype.end = function(event, from) {
        var path, _ref;
        if (from == null) {
          from = g.me;
        }
        path = g.currentPaths[from];
        if (!((_ref = path.data) != null ? _ref.polygonMode : void 0)) {
          path.endCreate(event.point, event, false);
          this.createPath(event, from);
        } else {
          path.endCreate(event.point, event, false);
        }
      };

      PathTool.prototype.finish = function(from) {
        var _ref, _ref1;
        if (from == null) {
          from = g.me;
        }
        if (!((_ref = g.currentPaths[g.me]) != null ? (_ref1 = _ref.data) != null ? _ref1.polygonMode : void 0 : void 0)) {
          return false;
        }
        g.currentPaths[from].finish();
        this.createPath(event, from);
        return true;
      };

      PathTool.prototype.keyUp = function(event) {
        var finishingPath;
        switch (event.key) {
          case 'enter':
            if (typeof this.finish === "function") {
              this.finish();
            }
            break;
          case 'escape':
            finishingPath = typeof this.finish === "function" ? this.finish() : void 0;
            if (!finishingPath) {
              g.deselectAll();
            }
        }
      };

      return PathTool;

    })(RTool);
    g.PathTool = PathTool;
    ItemTool = (function(_super) {
      __extends(ItemTool, _super);

      function ItemTool(name, RItem) {
        this.name = name;
        this.RItem = RItem;
        ItemTool.__super__.constructor.call(this, this.name, {
          x: 24,
          y: 0
        }, "crosshair");
        return;
      }

      ItemTool.prototype.select = function() {
        g.rasterizer.drawItems();
        ItemTool.__super__.select.call(this, this.RItem);
      };

      ItemTool.prototype.begin = function(event, from) {
        var point;
        if (from == null) {
          from = g.me;
        }
        point = event.point;
        g.deselectAll();
        g.currentPaths[from] = new Path.Rectangle(point, point);
        g.currentPaths[from].name = 'div tool rectangle';
        g.currentPaths[from].dashArray = [4, 10];
        g.currentPaths[from].strokeColor = 'black';
        g.selectionLayer.addChild(g.currentPaths[from]);
        if ((g.me != null) && from === g.me) {
          g.chatSocket.emit("bounce", {
            tool: this.name,
            "function": "begin",
            "arguments": [event, g.me, g.currentPaths[from].data]
          });
        }
      };

      ItemTool.prototype.update = function(event, from) {
        var bounds, lock, locks, point, _i, _len;
        if (from == null) {
          from = g.me;
        }
        point = event.point;
        g.currentPaths[from].segments[2].point = point;
        g.currentPaths[from].segments[1].point.x = point.x;
        g.currentPaths[from].segments[3].point.y = point.y;
        g.currentPaths[from].fillColor = null;
        bounds = g.currentPaths[from].bounds;
        locks = g.RLock.getLocksWhichIntersect(bounds);
        for (_i = 0, _len = locks.length; _i < _len; _i++) {
          lock = locks[_i];
          if (lock.owner !== g.me || (this.name !== 'Lock' && !lock.rectangle.contains(bounds))) {
            g.currentPaths[from].fillColor = 'red';
          }
        }
        if (g.rectangleOverlapsTwoPlanets(bounds)) {
          g.currentPaths[from].fillColor = 'red';
        }
        if ((g.me != null) && from === g.me) {
          g.chatSocket.emit("bounce", {
            tool: this.name,
            "function": "update",
            "arguments": [event, g.me]
          });
        }
      };

      ItemTool.prototype.end = function(event, from) {
        var bounds, lock, locks, point, _i, _len;
        if (from == null) {
          from = g.me;
        }
        if (from !== g.me) {
          g.currentPaths[from].remove();
          delete g.currentPaths[from];
          return false;
        }
        point = event.point;
        g.currentPaths[from].remove();
        bounds = g.currentPaths[from].bounds;
        locks = g.RLock.getLocksWhichIntersect(bounds);
        for (_i = 0, _len = locks.length; _i < _len; _i++) {
          lock = locks[_i];
          if (lock.owner !== g.me || (this.name !== 'Lock' && !lock.rectangle.contains(bounds))) {
            g.romanesco_alert('Your item intersects with a locked area.', 'error');
            return false;
          }
        }
        if (g.rectangleOverlapsTwoPlanets(bounds)) {
          g.romanesco_alert('Your item overlaps with two planets.', 'error');
          return false;
        }
        if (g.currentPaths[from].bounds.area < 100) {
          g.currentPaths[from].width = 10;
          g.currentPaths[from].height = 10;
        }
        if ((g.me != null) && from === g.me) {
          g.chatSocket.emit("bounce", {
            tool: this.name,
            "function": "end",
            "arguments": [event, g.me]
          });
        }
        return true;
      };

      return ItemTool;

    })(RTool);
    g.ItemTool = ItemTool;
    LockTool = (function(_super) {
      __extends(LockTool, _super);

      function LockTool() {
        LockTool.__super__.constructor.call(this, "Lock", g.RLock);
        this.textItem = null;
        return;
      }

      LockTool.prototype.update = function(event, from) {
        var cost, point, _ref;
        if (from == null) {
          from = g.me;
        }
        point = event.point;
        cost = g.currentPaths[from].bounds.area / 1000.0;
        if ((_ref = this.textItem) != null) {
          _ref.remove();
        }
        this.textItem = new PointText(point);
        this.textItem.justification = 'right';
        this.textItem.fillColor = 'black';
        this.textItem.content = '' + cost + ' romanescoins';
        LockTool.__super__.update.call(this, event, from);
      };

      LockTool.prototype.end = function(event, from) {
        var _ref;
        if (from == null) {
          from = g.me;
        }
        if ((_ref = this.textItem) != null) {
          _ref.remove();
        }
        if (LockTool.__super__.end.call(this, event, from)) {
          g.RLock.initialize(g.currentPaths[from].bounds);
          delete g.currentPaths[from];
        }
      };

      return LockTool;

    })(ItemTool);
    g.LockTool = LockTool;
    TextTool = (function(_super) {
      __extends(TextTool, _super);

      function TextTool() {
        TextTool.__super__.constructor.call(this, "Text", g.RText);
        return;
      }

      TextTool.prototype.end = function(event, from) {
        var text;
        if (from == null) {
          from = g.me;
        }
        if (TextTool.__super__.end.call(this, event, from)) {
          text = new g.RText(g.currentPaths[from].bounds);
          text.addToParent();
          text.select();
          text.save(true);
          delete g.currentPaths[from];
        }
      };

      return TextTool;

    })(ItemTool);
    g.TextTool = TextTool;
    MediaTool = (function(_super) {
      __extends(MediaTool, _super);

      function MediaTool() {
        MediaTool.__super__.constructor.call(this, "Media", g.RMedia);
        return;
      }

      MediaTool.prototype.end = function(event, from) {
        if (from == null) {
          from = g.me;
        }
        if (MediaTool.__super__.end.call(this, event, from)) {
          g.RMedia.initialize(g.currentPaths[from].bounds);
          delete g.currentPaths[from];
        }
      };

      return MediaTool;

    })(ItemTool);
    g.MediaTool = MediaTool;
    ScreenshotTool = (function(_super) {
      __extends(ScreenshotTool, _super);

      function ScreenshotTool() {
        this.downloadSVG = __bind(this.downloadSVG, this);
        this.downloadPNG = __bind(this.downloadPNG, this);
        this.publishOnPinterestCallback = __bind(this.publishOnPinterestCallback, this);
        this.publishOnPinterest = __bind(this.publishOnPinterest, this);
        this.publishOnFacebookAsPhotoCallback = __bind(this.publishOnFacebookAsPhotoCallback, this);
        this.publishOnFacebookAsPhoto = __bind(this.publishOnFacebookAsPhoto, this);
        this.publishOnFacebookCallback = __bind(this.publishOnFacebookCallback, this);
        this.publishOnFacebook = __bind(this.publishOnFacebook, this);
        this.extractImage = __bind(this.extractImage, this);
        ScreenshotTool.__super__.constructor.call(this, 'Screenshot', {
          x: 24,
          y: 0
        }, "crosshair");
        this.modalJ = $("#screenshotModal");
        this.modalJ.find('button[name="publish-on-facebook"]').click((function(_this) {
          return function() {
            return _this.publishOnFacebook();
          };
        })(this));
        this.modalJ.find('button[name="publish-on-facebook-photo"]').click((function(_this) {
          return function() {
            return _this.publishOnFacebookAsPhoto();
          };
        })(this));
        this.modalJ.find('button[name="download-png"]').click((function(_this) {
          return function() {
            return _this.downloadPNG();
          };
        })(this));
        this.modalJ.find('button[name="download-svg"]').click((function(_this) {
          return function() {
            return _this.downloadSVG();
          };
        })(this));
        this.modalJ.find('button[name="publish-on-pinterest"]').click((function(_this) {
          return function() {
            return _this.publishOnPinterest();
          };
        })(this));
        this.descriptionJ = this.modalJ.find('input[name="message"]');
        this.descriptionJ.change((function(_this) {
          return function() {
            _this.modalJ.find('a[name="publish-on-twitter"]').attr("data-text", _this.getDescription());
          };
        })(this));
        ZeroClipboard.config({
          swfPath: g.romanescoURL + "static/libs/ZeroClipboard/ZeroClipboard.swf"
        });
        this.selectionRectangle = null;
        return;
      }

      ScreenshotTool.prototype.getDescription = function() {
        if (this.descriptionJ.val().length > 0) {
          return this.descriptionJ.val();
        } else {
          return "Artwork made with Romanesco: " + this.locationURL;
        }
      };

      ScreenshotTool.prototype.checkRemoveScreenshotRectangle = function(item) {
        if ((this.selectionRectangle != null) && item !== this.selectionRectangle) {
          this.selectionRectangle.remove();
        }
      };

      ScreenshotTool.prototype.begin = function(event) {
        var from;
        from = g.me;
        g.currentPaths[from] = new Path.Rectangle(event.point, event.point);
        g.currentPaths[from].name = 'screenshot tool selection rectangle';
        g.currentPaths[from].dashArray = [4, 10];
        g.currentPaths[from].strokeColor = 'black';
        g.currentPaths[from].strokeWidth = 1;
        g.selectionLayer.addChild(g.currentPaths[from]);
      };

      ScreenshotTool.prototype.update = function(event) {
        var from;
        from = g.me;
        g.currentPaths[from].lastSegment.point = event.point;
        g.currentPaths[from].lastSegment.next.point.y = event.point.y;
        g.currentPaths[from].lastSegment.previous.point.x = event.point.x;
      };

      ScreenshotTool.prototype.end = function(event) {
        var from, r;
        from = g.me;
        g.currentPaths[from].remove();
        delete g.currentPaths[from];
        r = new Rectangle(event.downPoint, event.point);
        if (r.area < 100) {
          return;
        }
        this.selectionRectangle = new g.RSelectionRectangle(new Rectangle(event.downPoint, event.point), this.extractImage);
      };

      ScreenshotTool.prototype.extractImage = function(redraw) {
        var copyDataBtnJ, imgJ, maxHeight, twitterLinkJ, twitterScriptJ;
        this.rectangle = this.selectionRectangle.getBounds();
        this.selectionRectangle.remove();
        this.dataURL = g.rasterizer.extractImage(this.rectangle, redraw);
        this.locationURL = g.romanescoURL + location.hash;
        this.descriptionJ.attr('placeholder', 'Artwork made with Romanesco: ' + this.locationURL);
        copyDataBtnJ = this.modalJ.find('button[name="copy-data-url"]');
        copyDataBtnJ.attr("data-clipboard-text", this.dataURL);
        imgJ = this.modalJ.find("img.png");
        imgJ.attr("src", this.dataURL);
        maxHeight = window.innerHeight - 220;
        imgJ.css({
          'max-height': maxHeight + "px"
        });
        this.modalJ.find("a.png").attr("href", this.dataURL);
        twitterLinkJ = this.modalJ.find('a[name="publish-on-twitter"]');
        twitterLinkJ.empty().text("Publish on Twitter");
        twitterLinkJ.attr("data-url", this.locationURL);
        twitterScriptJ = $("<script type=\"text/javascript\">\n	window.twttr=(function(d,s,id){var t,js,fjs=d.getElementsByTagName(s)[0];\n	if(d.getElementById(id)){return}js=d.createElement(s);\n	js.id=id;js.src=\"https://platform.twitter.com/widgets.js\";\n	fjs.parentNode.insertBefore(js,fjs);\n	return window.twttr||(t={_e:[],ready:function(f){t._e.push(f)}})}(document,\"script\",\"twitter-wjs\"));\n</script>");
        twitterLinkJ.append(twitterScriptJ);
        this.modalJ.modal('show');
        this.modalJ.on('shown.bs.modal', function(e) {
          var client;
          client = new ZeroClipboard(copyDataBtnJ);
          client.on("ready", function(readyEvent) {
            console.log("ZeroClipboard SWF is ready!");
            client.on("aftercopy", function(event) {
              g.romanesco_alert("Image data url was successfully copied into the clipboard!", "success");
              this.destroy();
            });
          });
        });
      };

      ScreenshotTool.prototype.saveImage = function(callback) {
        Dajaxice.draw.saveImage(callback, {
          'image': this.dataURL
        });
        g.romanesco_alert("Your image is being uploaded...", "info");
      };

      ScreenshotTool.prototype.publishOnFacebook = function() {
        this.saveImage(this.publishOnFacebookCallback);
      };

      ScreenshotTool.prototype.publishOnFacebookCallback = function(result) {
        var caption;
        g.romanesco_alert("Your image was successfully uploaded to Romanesco, posting to Facebook...", "info");
        caption = this.getDescription();
        FB.ui({
          method: "feed",
          name: "Romanesco",
          caption: caption,
          description: "Romanesco is an infinite collaborative drawing app.",
          link: this.locationURL,
          picture: g.romanescoURL + result.url
        }, function(response) {
          if (response && response.post_id) {
            g.romanesco_alert("Your Post was successfully published!", "success");
          } else {
            g.romanesco_alert("An error occured. Your post was not published.", "error");
          }
        });
      };

      ScreenshotTool.prototype.publishOnFacebookAsPhoto = function() {
        if (!g.loggedIntoFacebook) {
          FB.login((function(_this) {
            return function(response) {
              if (response && !response.error) {
                _this.saveImage(_this.publishOnFacebookAsPhotoCallback);
              } else {
                g.romanesco_alert("An error occured when trying to log you into facebook.", "error");
              }
            };
          })(this));
        } else {
          this.saveImage(this.publishOnFacebookAsPhotoCallback);
        }
      };

      ScreenshotTool.prototype.publishOnFacebookAsPhotoCallback = function(result) {
        var caption;
        g.romanesco_alert("Your image was successfully uploaded to Romanesco, posting to Facebook...", "info");
        caption = this.getDescription();
        FB.api("/me/photos", "POST", {
          "url": g.romanescoURL + result.url,
          "message": caption
        }, function(response) {
          if (response && !response.error) {
            g.romanesco_alert("Your Post was successfully published!", "success");
          } else {
            g.romanesco_alert("An error occured. Your post was not published.", "error");
            console.log(response.error);
          }
        });
      };

      ScreenshotTool.prototype.publishOnPinterest = function() {
        this.saveImage(this.publishOnPinterestCallback);
      };

      ScreenshotTool.prototype.publishOnPinterestCallback = function(result) {
        var buttonJ, caption, description, imageUrl, imgJ, linkJ, linkJcopy, pinterestModalJ, siteUrl, submit;
        g.romanesco_alert("Your image was successfully uploaded to Romanesco...", "info");
        pinterestModalJ = $("#customModal");
        pinterestModalJ.modal('show');
        pinterestModalJ.addClass("pinterest-modal");
        pinterestModalJ.find(".modal-title").text("Publish on Pinterest");
        siteUrl = encodeURI(g.romanescoURL);
        imageUrl = siteUrl + result.url;
        caption = this.getDescription();
        description = encodeURI(caption);
        linkJ = $("<a>");
        linkJ.addClass("image");
        linkJ.attr("href", "http://pinterest.com/pin/create/button/?url=" + siteUrl + "&media=" + imageUrl + "&description=" + description);
        linkJcopy = linkJ.clone();
        imgJ = $('<img>');
        imgJ.attr('src', siteUrl + result.url);
        linkJ.append(imgJ);
        buttonJ = pinterestModalJ.find('button[name="submit"]');
        linkJcopy.addClass("btn btn-primary").text("Pin it!").insertBefore(buttonJ);
        buttonJ.hide();
        submit = function() {
          pinterestModalJ.modal('hide');
        };
        linkJ.click(submit);
        pinterestModalJ.find(".modal-body").empty().append(linkJ);
        pinterestModalJ.on('hide.bs.modal', function(event) {
          pinterestModalJ.removeClass("pinterest-modal");
          linkJcopy.remove();
          pinterestModalJ.off('hide.bs.modal');
        });
      };

      ScreenshotTool.prototype.downloadPNG = function() {
        this.modalJ.find("a.png")[0].click();
        this.modalJ.modal('hide');
      };

      ScreenshotTool.prototype.downloadSVG = function() {
        var blob, bounds, canvasTemp, controlPath, fileName, item, itemsToSave, link, position, rectanglePath, svg, svgGroup, tempProject, url, _i, _j, _k, _len, _len1, _len2, _ref;
        rectanglePath = new Path.Rectangle(this.rectangle);
        itemsToSave = [];
        _ref = project.activeLayer.children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          bounds = item.bounds;
          if (item.controller != null) {
            controlPath = item.controller.controlPath;
            if (this.rectangle.contains(bounds) || (this.rectangle.intersects(bounds) && (controlPath != null ? controlPath.getIntersections(rectanglePath).length : void 0) > 0)) {
              g.pushIfAbsent(itemsToSave, item.controller);
            }
          }
        }
        svgGroup = new Group();
        for (_j = 0, _len1 = itemsToSave.length; _j < _len1; _j++) {
          item = itemsToSave[_j];
          if (item.drawing == null) {
            item.draw();
          }
        }
        view.update();
        for (_k = 0, _len2 = itemsToSave.length; _k < _len2; _k++) {
          item = itemsToSave[_k];
          svgGroup.addChild(item.drawing.clone());
        }
        rectanglePath.remove();
        position = svgGroup.position.subtract(this.rectangle.topLeft);
        fileName = "image.svg";
        canvasTemp = document.createElement('canvas');
        canvasTemp.width = this.rectangle.width;
        canvasTemp.height = this.rectangle.height;
        tempProject = new Project(canvasTemp);
        svgGroup.position = position;
        tempProject.addChild(svgGroup);
        svg = tempProject.exportSVG({
          asString: true
        });
        tempProject.remove();
        paper.projects.first().activate();
        blob = new Blob([svg], {
          type: 'image/svg+xml'
        });
        url = URL.createObjectURL(blob);
        link = document.createElement("a");
        link.download = fileName;
        link.href = url;
        link.click();
        this.modalJ.modal('hide');
      };

      ScreenshotTool.prototype.copyURL = function() {};

      return ScreenshotTool;

    })(RTool);
    g.ScreenshotTool = ScreenshotTool;
    GradientTool = (function(_super) {
      __extends(GradientTool, _super);

      GradientTool.handleSize = 5;

      function GradientTool() {
        var handleSize;
        this.group = new Group();
        handleSize = this.constructor.handleSize;
        this.createHandle(view.bounds.scale(0.5).topLeft, 0, 'red');
        this.createHandle(view.bounds.scale(0.5).bottomRight, 0, 'blue');
        this.line = new Path();
        this.line.add(this.startHandle.position);
        this.line.add(this.endHandle.position);
        this.group.addChild(this.line);
        this.line.strokeColor = g.selectionBlue;
        this.line.strokeWidth = 1;
        this.handles = {
          0: this.startHandle,
          1: this.endHandle
        };
        g.selectionLayer.addChild(this.group);
        return;
      }

      GradientTool.prototype.select = function() {
        var differentTool, _ref;
        differentTool = g.previousTool !== g.selectedTool;
        if (this !== g.selectedTool) {
          g.previousTool = g.selectedTool;
        }
        if ((_ref = g.selectedTool) != null) {
          _ref.deselect();
        }
        g.selectedTool = this;
      };

      GradientTool.prototype.updateGradient = function() {
        var handle, location, stops, _ref;
        stops = [];
        _ref = this.handles;
        for (location in _ref) {
          handle = _ref[location];
          stops.push([handle.fillColor, location]);
        }
        return stops;
      };

      GradientTool.prototype.createHandle = function(position, location, color) {
        var handle;
        handle = new Path.Circle(position, this.constructor.handleSize);
        handle.name = 'handle';
        this.group.addChild(handle);
        handle.strokeColor = g.selectionBlue;
        handle.strokeWidth = 1;
        this.handles[location] = handle;
        this.updateGradient();
        return handle;
      };

      GradientTool.prototype.addHandle = function(event) {
        var location;
        location = this.line.hitTest(event.point).location;
        this.createHandle(location.position, location.location, g.selectedColor);
      };

      GradientTool.prototype.doubleClick = function(event) {
        var hitResult, point;
        point = view.viewToProject(new Point(event.pageX, event.pageY));
        hitResult = this.group.hitTest();
        if (hitResult) {
          if (hitResult.item === this.line) {
            this.addHandle(event);
          } else if (hitResult.item.name === 'handle') {
            hitResult.item.remove();
            this.updateGradient();
          }
        }
      };

      GradientTool.prototype.begin = function(event) {
        var hitResult;
        hitResult = this.group.hitTest(event.point);
        if (hitResult) {
          if (hitResult.item.name === 'handle') {
            this.selectedHandle = hitResult.item;
            this.dragging = true;
          }
        }
      };

      GradientTool.prototype.update = function(event) {
        if (this.dragging) {
          if (this.selectedHandle === this.handles[0] || this.selectedHandle === this.handles[1]) {
            this.selectedHandle.position.x += event.delta.x;
            this.selectedHandle.position.y += event.delta.y;
          } else {
            this.selectedHandle.position = this.line.getNearestPoint(event.point);
          }
        }
      };

      GradientTool.prototype.end = function(event) {
        this.dragging = false;
      };

      return GradientTool;

    })(RTool);
  });

}).call(this);

//# sourceMappingURL=tools.map
