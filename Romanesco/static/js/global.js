// Generated by CoffeeScript 1.7.1

/*
 * Global functions #

Here are all global functions (which do not belong to classes and are not event handlers neither initialization functions).
 */

(function() {
  this.showAlert = function(index) {
    var alertJ, prevType;
    if (g.alerts.length <= 0 || index < 0 || index >= g.alerts.length) {
      return;
    }
    prevType = g.alerts[g.currentAlert].type;
    g.currentAlert = index;
    alertJ = g.alertsContainer.find(".alert");
    alertJ.removeClass(prevType).addClass(g.alerts[g.currentAlert].type).text(g.alerts[g.currentAlert].message);
    g.alertsContainer.find(".alert-number").text(g.currentAlert + 1);
  };

  this.romanesco_alert = function(message, type, delay) {
    var alertJ;
    if (type == null) {
      type = "";
    }
    if (delay == null) {
      delay = 2000;
    }
    if (type.length === 0) {
      type = "info";
    } else if (type === "error") {
      type = "danger";
    }
    type = " alert-" + type;
    alertJ = g.alertsContainer.find(".alert");
    g.alertsContainer.removeClass("r-hidden");
    g.currentAlert = g.alerts.length;
    g.alerts.push({
      type: type,
      message: message
    });
    if (g.alerts.length > 0) {
      g.alertsContainer.addClass("activated");
    }
    this.showAlert(g.alerts.length - 1);
    g.alertsContainer.addClass("show");
    if (delay !== 0) {
      clearTimeout(g.alertTimeOut);
      g.alertTimeOut = setTimeout((function() {
        return g.alertsContainer.removeClass("show");
      }), delay);
    }
  };

  this.eventToObject = function(event) {
    var eo;
    eo = {
      modifiers: event.modifiers,
      point: event.pageX == null ? event.point : view.viewToProject(new Point(event.pageX, event.pageY)),
      downPoint: event.downPoint != null,
      delta: event.delta
    };
    if ((event.pageX != null) && (event.pageY != null)) {
      eo.modifiers = {};
      eo.modifiers.control = event.ctrlKey;
      eo.modifiers.command = event.command;
    }
    if (event.target != null) {
      eo.target = "." + event.target.className.replace(" ", ".");
    }
    return eo;
  };

  this.objectToEvent = function(event) {
    event.point = new Point(event.point);
    event.downPoint = new Point(event.downPoint);
    event.delta = new Point(event.delta);
    return event;
  };

  this.specialKey = function(event) {
    var specialKey;
    if ((event.pageX != null) && (event.pageY != null)) {
      specialKey = g.OSName === "MacOS" ? event.metaKey : event.ctrlKey;
    } else {
      specialKey = g.OSName === "MacOS" ? event.modifiers.command : event.modifiers.control;
    }
    return specialKey;
  };

  this.getSnap = function() {
    var snap;
    snap = g.parameters.snap.snap;
    return snap - snap % g.parameters.snap.step;
  };

  this.snap1D = function(value, snap) {
    if (snap == null) {
      snap = g.getSnap();
    }
    if (snap !== 0) {
      return Math.floor(value / snap) * snap;
    } else {
      return value;
    }
  };

  this.snap2D = function(point, snap) {
    if (snap == null) {
      snap = g.getSnap();
    }
    if (snap !== 0) {
      return new Point(snap1D(point.x, snap), snap1D(point.y, snap));
    } else {
      return point;
    }
  };

  this.snap = function(event, from) {
    var snap, snappedEvent;
    if (from == null) {
      from = g.me;
    }
    if (from !== g.me) {
      return event;
    }
    if (g.selectedTool.disableSnap()) {
      return event;
    }
    snap = g.parameters.snap.snap;
    snap = snap - snap % g.parameters.snap.step;
    if (snap !== 0) {
      snappedEvent = jQuery.extend({}, event);
      snappedEvent.modifiers = event.modifiers;
      snappedEvent.point = g.snap2D(event.point, snap);
      if (event.lastPoint != null) {
        snappedEvent.lastPoint = g.snap2D(event.lastPoint, snap);
      }
      if (event.downPoint != null) {
        snappedEvent.downPoint = g.snap2D(event.downPoint, snap);
      }
      if (event.lastPoint != null) {
        snappedEvent.middlePoint = snappedEvent.point.add(snappedEvent.lastPoint).multiply(0.5);
      }
      if (event.type !== 'mouseup' && (event.lastPoint != null)) {
        snappedEvent.delta = snappedEvent.point.subtract(snappedEvent.lastPoint);
      } else if (event.downPoint != null) {
        snappedEvent.delta = snappedEvent.point.subtract(snappedEvent.downPoint);
      }
      return snappedEvent;
    } else {
      return event;
    }
  };

  g.hideOthers = function(me) {
    var item, name, _ref, _ref1;
    _ref = g.paths;
    for (name in _ref) {
      item = _ref[name];
      if (item !== me) {
        if ((_ref1 = item.group) != null) {
          _ref1.visible = false;
        }
      }
    }
    g.fastModeOn = true;
  };

  g.showAll = function() {
    var item, name, _ref, _ref1;
    if (!g.fastModeOn) {
      return;
    }
    _ref = g.paths;
    for (name in _ref) {
      item = _ref[name];
      if ((_ref1 = item.group) != null) {
        _ref1.visible = true;
      }
    }
    g.fastModeOn = false;
  };

  g.getLimitPaths = function() {
    var limit, limitPathH, limitPathV;
    limit = getLimit();
    limitPathV = null;
    limitPathH = null;
    if (limit.x >= view.bounds.left && limit.x <= view.bounds.right) {
      limitPathV = new Path();
      limitPathV.name = 'limitPathV';
      limitPathV.add(limit.x, view.bounds.top);
      limitPathV.add(limit.x, view.bounds.bottom);
    }
    if (limit.y >= view.bounds.top && limit.y <= view.bounds.bottom) {
      limitPathH = new Path();
      limitPathH.name = 'limitPathH';
      limitPathH.add(view.bounds.left, limit.y);
      limitPathH.add(view.bounds.right, limit.y);
    }
    return {
      vertical: limitPathV,
      horizontal: limitPathH
    };
  };

  g.rectangleOverlapsTwoPlanets = function(rectangle) {
    return g.overlapsTwoPlanets(new Path.Rectangle(rectangle));
  };

  g.pathOverlapsTwoPlanets = function(path) {
    var intersections, limitPathH, limitPathV, limitPaths;
    limitPaths = g.getLimitPaths();
    limitPathV = limitPaths.vertical;
    limitPathH = limitPaths.horizontal;
    if (limitPathV != null) {
      intersections = path.getIntersections(limitPathV);
      limitPathV.remove();
      if (intersections.length > 0) {
        return true;
      }
    }
    if (limitPathH != null) {
      intersections = path.getIntersections(limitPathH);
      limitPathH.remove();
      if (intersections.length > 0) {
        return true;
      }
    }
    return false;
  };

  g.updateGrid = function() {
    var b, debug, i, ijOnPlanet, j, l, limitPathH, limitPathV, limitPaths, n, p, planet, planetText, pos, posOnPlanet, posText, px, py, r, snap, t, x, y;
    g.grid.removeChildren();
    limitPaths = g.getLimitPaths();
    limitPathV = limitPaths.vertical;
    limitPathH = limitPaths.horizontal;
    if (limitPathV != null) {
      limitPathV.strokeColor = "#00FF00";
      limitPathV.strokeWidth = 5;
      g.grid.addChild(limitPathV);
    }
    if (limitPathH != null) {
      limitPathH.strokeColor = "#00FF00";
      limitPathH.strokeWidth = 5;
      g.grid.addChild(limitPathH);
    }
    if (!g.displayGrid) {
      return;
    }
    t = Math.floor(view.bounds.top / g.scale);
    l = Math.floor(view.bounds.left / g.scale);
    b = Math.floor(view.bounds.bottom / g.scale);
    r = Math.floor(view.bounds.right / g.scale);
    pos = getTopLeftCorner();
    planet = projectToPlanet(pos);
    posOnPlanet = projectToPosOnPlanet(pos);
    debug = false;
    snap = g.getSnap();
    if (snap < 15) {
      snap = 15;
    }
    if (debug) {
      snap = 250;
    }
    n = 1;
    i = l;
    j = t;
    while (i < r + 1 || j < b + 1) {
      px = new Path();
      px.name = "grid px";
      py = new Path();
      px.name = "grid py";
      ijOnPlanet = projectToPosOnPlanet(new Point(i * g.scale, j * g.scale));
      if (ijOnPlanet.x === -180) {
        px.strokeColor = "#00FF00";
        px.strokeWidth = 5;
      } else if (n < 4) {
        px.strokeColor = "#666666";
      } else {
        px.strokeColor = "#000000";
        px.strokeWidth = 2;
      }
      if (ijOnPlanet.y === -90) {
        py.strokeColor = "#00FF00";
        py.strokeWidth = 5;
      } else if (n < 4) {
        py.strokeColor = "#666666";
      } else {
        py.strokeColor = "#000000";
        py.strokeWidth = 2;
      }
      px.add(new Point(i * g.scale, view.bounds.top));
      px.add(new Point(i * g.scale, view.bounds.bottom));
      py.add(new Point(view.bounds.left, j * g.scale));
      py.add(new Point(view.bounds.right, j * g.scale));
      g.grid.addChild(px);
      g.grid.addChild(py);
      i += snap / g.scale;
      j += snap / g.scale;
      if (n === 4) {
        n = 0;
      }
      n++;
    }
    if (!debug) {
      return;
    }
    i = l;
    while (i < r + 1) {
      j = t;
      while (j < b + 1) {
        x = i * g.scale;
        y = j * g.scale;
        planetText = new PointText(new Point(x - 10, y - 40));
        planetText.justification = 'right';
        planetText.fillColor = 'black';
        p = projectToPlanet(new Point(i * g.scale, j * g.scale));
        planetText.content = 'px: ' + Math.floor(p.x) + ', py: ' + Math.floor(p.y);
        g.grid.addChild(planetText);
        posText = new PointText(new Point(x - 10, y - 20));
        posText.justification = 'right';
        posText.fillColor = 'black';
        p = projectToPosOnPlanet(new Point(i * g.scale, j * g.scale));
        posText.content = 'x: ' + p.x.toFixed(2) + ', y: ' + p.y.toFixed(2);
        g.grid.addChild(posText);
        j += snap / g.scale;
      }
      i += snap / g.scale;
    }
  };

  this.gameAt = function(point) {
    var div, _i, _len, _ref;
    _ref = g.divs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      div = _ref[_i];
      if (div.getBounds().contains(point) && div.constructor.name === 'RVideoGame') {
        return div;
      }
    }
    return null;
  };

  g.RMoveTo = function(pos) {
    return g.RMoveBy(pos.subtract(view.center));
  };

  g.RMoveBy = function(delta) {
    var area, div, newEntireArea, newView, restrictedAreaShrinked, _i, _j, _len, _len1, _ref, _ref1;
    if (g.restrictedArea != null) {
      if (!g.restrictedArea.contains(view.center)) {
        delta = g.restrictedArea.center.subtract(view.center);
      } else {
        newView = view.bounds.clone();
        newView.center.x += delta.x;
        newView.center.y += delta.y;
        if (!g.restrictedArea.contains(newView)) {
          restrictedAreaShrinked = g.restrictedArea.expand(view.size.multiply(-1));
          if (restrictedAreaShrinked.width < 0) {
            restrictedAreaShrinked.left = restrictedAreaShrinked.right = g.restrictedArea.center.x;
          }
          if (restrictedAreaShrinked.height < 0) {
            restrictedAreaShrinked.top = restrictedAreaShrinked.bottom = g.restrictedArea.center.y;
          }
          newView.center.x = g.clamp(restrictedAreaShrinked.left, newView.center.x, restrictedAreaShrinked.right);
          newView.center.y = g.clamp(restrictedAreaShrinked.top, newView.center.y, restrictedAreaShrinked.bottom);
          delta = newView.center.subtract(view.center);
        }
      }
    }
    project.view.scrollBy(new Point(delta.x, delta.y));
    _ref = g.divs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      div = _ref[_i];
      div.updateTransform();
    }
    updateGrid();
    newEntireArea = null;
    _ref1 = g.entireAreas;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      area = _ref1[_j];
      if (area.getBounds().contains(project.view.center)) {
        newEntireArea = area;
        break;
      }
    }
    if ((g.entireArea == null) && (newEntireArea != null)) {
      g.entireArea = newEntireArea.getBounds();
    } else if ((g.entireArea != null) && (newEntireArea == null)) {
      g.entireArea = null;
    }
    if (newEntireArea != null) {
      load(g.entireArea);
    } else {
      load();
    }
    g.updateRoom();
    g.defferedExecution(g.updateHash, 500);
    g.setControllerValue(g.parameters.location.controller, null, '' + view.center.x.toFixed(2) + ',' + view.center.y.toFixed(2));
  };

  g.updateHash = function() {
    g.moving = true;
    location.hash = '' + view.center.x.toFixed(2) + ',' + view.center.y.toFixed(2);
  };

  window.onhashchange = function(event) {
    var p, pos;
    if (g.moving) {
      g.moving = false;
      return;
    }
    pos = location.hash.substr(1).split(',');
    p = new Point();
    p.x = parseFloat(pos[0]);
    p.y = parseFloat(pos[1]);
    if (!p.x) {
      p.x = 0;
    }
    if (!p.y) {
      p.y = 0;
    }
    g.RMoveTo(p);
  };

  this.selectedItems = function() {
    var item, items, _i, _len, _ref;
    items = [];
    _ref = project.selectedItems;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if ((item.controller != null) && items.indexOf(item.controller) < 0) {
        items.push(item.controller);
      }
    }
    return items.concat(g.selectedDivs);
  };

  this.deselectAll = function() {
    var item, _i, _len, _ref;
    _ref = g.selectedItems();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (typeof item.deselect === "function") {
        item.deselect();
      }
    }
    project.activeLayer.selected = false;
  };

  this.toggleSidebar = function(show) {
    if (show == null) {
      show = !g.sidebarJ.hasClass("r-hidden");
    }
    if (show) {
      g.sidebarJ.addClass("r-hidden");
      g.editorJ.addClass("r-hidden");
      g.alertsContainer.addClass("r-sidebar-hidden");
      g.sidebarHandleJ.find("span").removeClass("glyphicon-chevron-left").addClass("glyphicon-chevron-right");
    } else {
      g.sidebarJ.removeClass("r-hidden");
      g.editorJ.removeClass("r-hidden");
      g.alertsContainer.removeClass("r-sidebar-hidden");
      g.sidebarHandleJ.find("span").removeClass("glyphicon-chevron-right").addClass("glyphicon-chevron-left");
    }
  };

  this.logItems = function() {
    var i, item, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    console.log("Selected items:");
    _ref = project.selectedItems;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      if (((_ref1 = item.name) != null ? _ref1.indexOf("debug") : void 0) === 0) {
        continue;
      }
      console.log("------" + i + "------");
      console.log(item.name);
      console.log(item);
      console.log(item.controller);
      console.log((_ref2 = item.controller) != null ? _ref2.pk : void 0);
    }
    console.log("All items:");
    _ref3 = project.activeLayer.children;
    for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
      item = _ref3[i];
      if (((_ref4 = item.name) != null ? _ref4.indexOf("debug") : void 0) === 0) {
        continue;
      }
      console.log("------" + i + "------");
      console.log(item.name);
      console.log(item);
      console.log(item.controller);
      console.log((_ref5 = item.controller) != null ? _ref5.pk : void 0);
    }
    console.log("hiiiiiii");
    return "--- THE END ---";
  };

  this.checkRasters = function() {
    var item, _i, _len, _ref;
    _ref = project.activeLayer.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if ((item.controller != null) && (item.controller.raster == null)) {
        console.log(item.controller);
      }
    }
  };

}).call(this);

//# sourceMappingURL=global.map
