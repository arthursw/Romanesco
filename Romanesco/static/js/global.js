// Generated by CoffeeScript 1.7.1
(function() {
  var RSound, g, sqrtTwoPi,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  g = this;

  this.g = g;

  g.alerts = null;

  g.scale = 1000.0;

  this.getTime = function() {
    return new Date().getTime();
  };

  this.sign = function(x) {
    if (typeof x === "number") {
      if (x) {
        if (x < 0) {
          return -1;
        } else {
          return 1;
        }
      } else {
        if (x === x) {
          return 0;
        } else {
          return NaN;
        }
      }
    } else {
      return NaN;
    }
  };

  this.clamp = function(min, value, max) {
    return Math.min(Math.max(value, min), max);
  };

  Array.prototype.remove = function(itemToRemove) {
    var i, item, _i, _len;
    for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
      item = this[i];
      if (item === itemToRemove) {
        this.splice(i, 1);
        break;
      }
    }
  };

  Array.prototype.first = function() {
    return this[0];
  };

  Array.prototype.last = function() {
    return this[this.length - 1];
  };

  Array.prototype.random = function() {
    return this[Math.floor(Math.random() * this.length)];
  };

  this.pushIfAbsent = function(array, item) {
    if (array.indexOf(item) < 0) {
      array.push(item);
    }
  };

  this.defferedExecution = function(handler, id, n) {
    if (n == null) {
      n = 500;
    }
    if (g.updateTimeout[id] != null) {
      clearTimeout(g.updateTimeout[id]);
    }
    return g.updateTimeout[id] = setTimeout(handler, n);
  };

  this.load = function() {
    return console.log("load");
  };

  this.setAlert = function(index) {
    var alertJ, prevType;
    if (g.alerts.length <= 0 || index < 0 || index >= g.alerts.length) {
      return;
    }
    prevType = g.alerts[g.currentAlert].type;
    g.currentAlert = index;
    alertJ = g.alertsContainer.find(".alert");
    alertJ.removeClass(prevType).addClass(g.alerts[g.currentAlert].type).text(g.alerts[g.currentAlert].message);
    return g.alertsContainer.find(".alert-number").text(g.currentAlert + 1);
  };

  this.romanesco_alert = function(message, type, delay, container) {
    var alertJ, prevType;
    if (type == null) {
      type = "";
    }
    if (delay == null) {
      delay = 2000;
    }
    if (container == null) {
      container = null;
    }
    if (type.length === 0) {
      type = "info";
    } else if (type === "error") {
      type = "danger";
    }
    type = " alert-" + type;
    alertJ = g.alertsContainer.find(".alert");
    g.alertsContainer.removeClass("r-hidden");
    prevType = g.alerts.length > 0 ? g.alerts[g.alerts.length - 1].type : "";
    g.currentAlert = g.alerts.length;
    g.alerts.push({
      type: type,
      message: message
    });
    if (g.alerts.length > 0) {
      g.alertsContainer.addClass("activated");
    }
    alertJ.removeClass(prevType).addClass(type).text(message);
    g.alertsContainer.find(".alert-number").text(g.alerts.length);
    g.alertsContainer.addClass("show");
    if (delay !== 0) {
      clearTimeout(g.alertTimeOut);
      return g.alertTimeOut = setTimeout((function() {
        return g.alertsContainer.removeClass("show");
      }), delay);
    }
  };

  sqrtTwoPi = Math.sqrt(2 * Math.PI);

  this.gaussian = function(mean, sigma, x) {
    var expf;
    expf = -((x - mean) * (x - mean) / (2 * sigma * sigma));
    return (1.0 / (sigma * sqrtTwoPi)) * Math.exp(expf);
  };

  this.eventObj = function(event) {
    var eo;
    eo = {
      modifiers: event.modifiers,
      point: event.pageX == null ? event.point : view.viewToProject(new Point(event.pageX, event.pageY)),
      downPoint: event.downPoint != null,
      delta: event.delta
    };
    if ((event.pageX != null) && (event.pageY != null)) {
      eo.modifiers = {};
      eo.modifiers.control = event.ctrlKey;
      eo.modifiers.command = event.command;
    }
    if (event.target != null) {
      eo.target = "." + event.target.className.replace(" ", ".");
    }
    return eo;
  };

  this.parseEventObj = function(event) {
    event.point = new Point(event.point);
    event.downPoint = new Point(event.downPoint);
    event.delta = new Point(event.delta);
    return event;
  };

  this.specialKey = function(event) {
    var specialKey;
    if ((event.pageX != null) && (event.pageY != null)) {
      specialKey = g.OSName === "MacOS" ? event.metaKey : event.ctrlKey;
    } else {
      specialKey = g.OSName === "MacOS" ? event.modifiers.command : event.modifiers.control;
    }
    return specialKey;
  };

  this.getSnap = function() {
    var snap;
    snap = g.parameters.snap.snap;
    return snap - snap % g.parameters.snap.step;
  };

  this.snap1D = function(value, snap) {
    if (snap == null) {
      snap = g.getSnap();
    }
    if (snap !== 0) {
      return Math.floor(value / snap) * snap;
    } else {
      return value;
    }
  };

  this.snap2D = function(point, snap) {
    if (snap == null) {
      snap = g.getSnap();
    }
    if (snap !== 0) {
      return new Point(snap1D(point.x, snap), snap1D(point.y, snap));
    } else {
      return point;
    }
  };

  this.snap = function(event, from) {
    var snap, snappedEvent;
    if (from == null) {
      from = g.me;
    }
    if (from !== g.me) {
      return event;
    }
    if (g.selectedTool.disableSnap()) {
      return event;
    }
    snap = g.parameters.snap.snap;
    snap = snap - snap % g.parameters.snap.step;
    if (snap !== 0) {
      snappedEvent = jQuery.extend({}, event);
      snappedEvent.modifiers = event.modifiers;
      snappedEvent.point = g.snap2D(event.point, snap);
      if (event.lastPoint != null) {
        snappedEvent.lastPoint = g.snap2D(event.lastPoint, snap);
      }
      if (event.downPoint != null) {
        snappedEvent.downPoint = g.snap2D(event.downPoint, snap);
      }
      if (event.lastPoint != null) {
        snappedEvent.middlePoint = snappedEvent.point.add(snappedEvent.lastPoint).multiply(0.5);
      }
      if (event.type !== 'mouseup' && (event.lastPoint != null)) {
        snappedEvent.delta = snappedEvent.point.subtract(snappedEvent.lastPoint);
      } else if (event.downPoint != null) {
        snappedEvent.delta = snappedEvent.point.subtract(snappedEvent.downPoint);
      }
      return snappedEvent;
    } else {
      return event;
    }
  };

  RSound = (function() {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;

    RSound.context = new AudioContext();

    function RSound(urlList, onLoadCallback) {
      this.urlList = urlList;
      this.onLoadCallback = onLoadCallback;
      this.bufferOnDecoded = __bind(this.bufferOnDecoded, this);
      this.bufferOnLoad = __bind(this.bufferOnLoad, this);
      this.context = this.constructor.context;
      this.load();
      return;
    }

    RSound.prototype.load = function() {
      this.loadBuffer(0);
    };

    RSound.prototype.loadBuffer = function(index) {
      var request, url;
      this.index = index;
      if (this.index >= this.urlList.length) {
        return;
      }
      url = this.urlList[this.index];
      request = new RXMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = "arraybuffer";
      request.onload = (function(_this) {
        return function() {
          _this.bufferOnLoad(request.response);
        };
      })(this);
      request.onerror = function() {
        console.error('BufferLoader: XHR error');
      };
      request.send();
    };

    RSound.prototype.bufferOnLoad = function(response) {
      this.context.decodeAudioData(response, this.bufferOnDecoded, this.bufferOnError);
    };

    RSound.prototype.bufferOnDecoded = function(buffer) {
      this.buffer = buffer;
      if (!this.buffer) {
        console.log('Error decoding url number ' + this.index + ', trying next url.');
        if (this.index + 1 < this.urlList.length) {
          this.loadBuffer(this.index + 1);
        } else {
          console.error('Error decoding file data.');
        }
        return;
      }
      if (this.playOnLoad != null) {
        this.play(this.playOnLoad);
        this.playOnLoad = null;
      }
      if (typeof this.onLoadCallback === "function") {
        this.onLoadCallback();
      }
      console.log('Sound loaded using url: ' + this.urlList[this.index]);
    };

    RSound.prototype.bufferOnError = function(error) {
      return console.error('decodeAudioData', error);
    };

    RSound.prototype.play = function(time) {
      if (time == null) {
        time = 0;
      }
      if (this.buffer == null) {
        this.playOnLoad = time;
        return;
      }
      this.source = this.context.createBufferSource();
      this.source.buffer = this.buffer;
      this.source.connect(this.context.destination);
      this.source.loop = true;
      this.gainNode = this.context.createGain();
      this.source.connect(this.gainNode);
      this.gainNode.connect(this.context.destination);
      this.gainNode.gain.value = this.volume;
      this.source.start(time);
    };

    RSound.prototype.setLoopStart = function(start) {
      this.source.loopStart = start;
    };

    RSound.prototype.setLoopEnd = function(end) {
      this.source.loopEnd = end;
    };

    RSound.prototype.stop = function() {
      this.source.stop();
    };

    RSound.prototype.setRate = function(rate) {
      this.source.playbackRate.value = rate;
    };

    RSound.prototype.rate = function() {
      return this.source.playbackRate.value;
    };

    RSound.prototype.volume = function() {
      return this.volume;
    };

    RSound.prototype.setVolume = function(volume) {
      this.volume = volume;
      if (this.source == null) {
        return;
      }
      return this.gainNode.gain.value = this.volume;
    };

    return RSound;

  })();

  this.RSound = RSound;

}).call(this);

//# sourceMappingURL=global.map
