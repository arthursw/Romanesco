// Generated by CoffeeScript 1.7.1

/*
 * Global functions #

Here are all global functions (which do not belong to classes and are not event handlers neither initialization functions).
 */

(function() {
  this.showAlert = function(index) {
    var alertJ, prevType;
    if (g.alerts.length <= 0 || index < 0 || index >= g.alerts.length) {
      return;
    }
    prevType = g.alerts[g.currentAlert].type;
    g.currentAlert = index;
    alertJ = g.alertsContainer.find(".alert");
    alertJ.removeClass(prevType).addClass(g.alerts[g.currentAlert].type).text(g.alerts[g.currentAlert].message);
    g.alertsContainer.find(".alert-number").text(g.currentAlert + 1);
  };

  this.romanesco_alert = function(message, type, delay) {
    var alertJ;
    if (type == null) {
      type = "";
    }
    if (delay == null) {
      delay = 2000;
    }
    if (type.length === 0) {
      type = "info";
    } else if (type === "error") {
      type = "danger";
    }
    type = " alert-" + type;
    alertJ = g.alertsContainer.find(".alert");
    g.alertsContainer.removeClass("r-hidden");
    g.currentAlert = g.alerts.length;
    g.alerts.push({
      type: type,
      message: message
    });
    if (g.alerts.length > 0) {
      g.alertsContainer.addClass("activated");
    }
    this.showAlert(g.alerts.length - 1);
    g.alertsContainer.addClass("show");
    if (delay !== 0) {
      clearTimeout(g.alertTimeOut);
      g.alertTimeOut = setTimeout((function() {
        return g.alertsContainer.removeClass("show");
      }), delay);
    }
  };

  this.checkError = function(result) {
    if (result == null) {
      return true;
    }
    if (result.state === 'not_logged_in') {
      romanesco_alert("You must be logged in to update drawings to the database.", "info");
      return false;
    }
    if (result.state === 'error') {
      if (result.message === 'invalid_url') {
        romanesco_alert("Your URL is invalid or does not point to an existing page.", "error");
      } else {
        romanesco_alert("Error: " + result.message, "error");
      }
      return false;
    } else if (result.state === 'system_error') {
      console.log(result.message);
      return false;
    }
    return true;
  };

  this.jEventToPoint = function(event) {
    return view.viewToProject(new Point(event.pageX - g.canvasJ.offset().left, event.pageY - g.canvasJ.offset().top));
  };

  this.eventToObject = function(event) {
    var eo;
    eo = {
      modifiers: event.modifiers,
      point: event.pageX == null ? event.point : g.jEventToPoint(event),
      downPoint: event.downPoint != null,
      delta: event.delta
    };
    if ((event.pageX != null) && (event.pageY != null)) {
      eo.modifiers = {};
      eo.modifiers.control = event.ctrlKey;
      eo.modifiers.command = event.metaKey;
    }
    if (event.target != null) {
      eo.target = "." + event.target.className.replace(" ", ".");
    }
    return eo;
  };

  this.objectToEvent = function(event) {
    event.point = new Point(event.point);
    event.downPoint = new Point(event.downPoint);
    event.delta = new Point(event.delta);
    return event;
  };

  this.jEventToPaperEvent = function(event, previousPosition, initialPosition, type, count) {
    var currentPosition, delta, paperEvent;
    if (previousPosition == null) {
      previousPosition = null;
    }
    if (initialPosition == null) {
      initialPosition = null;
    }
    if (type == null) {
      type = null;
    }
    if (count == null) {
      count = null;
    }
    currentPosition = g.jEventToPoint(event);
    if (previousPosition == null) {
      previousPosition = currentPosition;
    }
    if (initialPosition == null) {
      initialPosition = currentPosition;
    }
    delta = currentPosition.subtract(previousPosition);
    paperEvent = {
      modifiers: {
        shift: event.shiftKey,
        control: event.ctrlKey,
        option: event.altKey,
        command: event.metaKey
      },
      point: currentPosition,
      downPoint: initialPosition,
      delta: delta,
      middlePoint: previousPosition.add(delta.divide(2)),
      type: type,
      count: count
    };
    return paperEvent;
  };

  this.specialKey = function(event) {
    var specialKey;
    if ((event.pageX != null) && (event.pageY != null)) {
      specialKey = g.OSName === "MacOS" ? event.metaKey : event.ctrlKey;
    } else {
      specialKey = g.OSName === "MacOS" ? event.modifiers.command : event.modifiers.control;
    }
    return specialKey;
  };

  this.getSnap = function() {
    var snap;
    snap = g.parameters.snap.snap;
    return snap - snap % g.parameters.snap.step;
  };

  this.snap1D = function(value, snap) {
    if (snap == null) {
      snap = g.getSnap();
    }
    if (snap !== 0) {
      return Math.floor(value / snap) * snap;
    } else {
      return value;
    }
  };

  this.snap2D = function(point, snap) {
    if (snap == null) {
      snap = g.getSnap();
    }
    if (snap !== 0) {
      return new Point(snap1D(point.x, snap), snap1D(point.y, snap));
    } else {
      return point;
    }
  };

  this.snap = function(event, from) {
    var snap, snappedEvent;
    if (from == null) {
      from = g.me;
    }
    if (from !== g.me) {
      return event;
    }
    if (g.selectedTool.disableSnap()) {
      return event;
    }
    snap = g.parameters.snap.snap;
    snap = snap - snap % g.parameters.snap.step;
    if (snap !== 0) {
      snappedEvent = jQuery.extend({}, event);
      snappedEvent.modifiers = event.modifiers;
      snappedEvent.point = g.snap2D(event.point, snap);
      if (event.lastPoint != null) {
        snappedEvent.lastPoint = g.snap2D(event.lastPoint, snap);
      }
      if (event.downPoint != null) {
        snappedEvent.downPoint = g.snap2D(event.downPoint, snap);
      }
      if (event.lastPoint != null) {
        snappedEvent.middlePoint = snappedEvent.point.add(snappedEvent.lastPoint).multiply(0.5);
      }
      if (event.type !== 'mouseup' && (event.lastPoint != null)) {
        snappedEvent.delta = snappedEvent.point.subtract(snappedEvent.lastPoint);
      } else if (event.downPoint != null) {
        snappedEvent.delta = snappedEvent.point.subtract(snappedEvent.downPoint);
      }
      return snappedEvent;
    } else {
      return event;
    }
  };

  g.hideOthers = function(me) {
    var item, name, _ref, _ref1;
    _ref = g.paths;
    for (name in _ref) {
      item = _ref[name];
      if (item !== me) {
        if ((_ref1 = item.group) != null) {
          _ref1.visible = false;
        }
      }
    }
    g.fastModeOn = true;
  };

  g.showAll = function() {
    var item, name, _ref, _ref1;
    if (!g.fastModeOn) {
      return;
    }
    _ref = g.paths;
    for (name in _ref) {
      item = _ref[name];
      if ((_ref1 = item.group) != null) {
        _ref1.visible = true;
      }
    }
    g.fastModeOn = false;
  };

  g.rectangleOverlapsTwoPlanets = function(rectangle) {
    var limit;
    limit = getLimit();
    if ((rectangle.left < limit.x && rectangle.right > limit.x) || (rectangle.top < limit.y && rectangle.bottom > limit.y)) {
      return true;
    }
    return false;
  };

  g.updateLimitPaths = function() {
    var limit;
    limit = getLimit();
    g.limitPathV = null;
    g.limitPathH = null;
    if (limit.x >= view.bounds.left && limit.x <= view.bounds.right) {
      g.limitPathV = new Path();
      g.limitPathV.name = 'limitPathV';
      g.limitPathV.add(limit.x, view.bounds.top);
      g.limitPathV.add(limit.x, view.bounds.bottom);
      g.grid.addChild(g.limitPathV);
    }
    if (limit.y >= view.bounds.top && limit.y <= view.bounds.bottom) {
      g.limitPathH = new Path();
      g.limitPathH.name = 'limitPathH';
      g.limitPathH.add(view.bounds.left, limit.y);
      g.limitPathH.add(view.bounds.right, limit.y);
      g.grid.addChild(g.limitPathH);
    }
  };

  g.updateGrid = function() {
    var b, debug, i, ijOnPlanet, j, l, n, p, planet, planetText, pos, posOnPlanet, posText, px, py, r, snap, t, x, y;
    g.grid.removeChildren();
    g.updateLimitPaths();
    if (g.limitPathV != null) {
      g.limitPathV.strokeColor = 'green';
      g.limitPathV.strokeWidth = 5;
    }
    if (g.limitPathH != null) {
      g.limitPathH.strokeColor = 'green';
      g.limitPathH.strokeWidth = 5;
    }
    if (!g.displayGrid) {
      return;
    }
    t = Math.floor(view.bounds.top / g.scale);
    l = Math.floor(view.bounds.left / g.scale);
    b = Math.floor(view.bounds.bottom / g.scale);
    r = Math.floor(view.bounds.right / g.scale);
    pos = getTopLeftCorner();
    planet = projectToPlanet(pos);
    posOnPlanet = projectToPosOnPlanet(pos);
    debug = false;
    snap = g.getSnap();
    if (snap < 15) {
      snap = 15;
    }
    if (debug) {
      snap = 250;
    }
    n = 1;
    i = l;
    j = t;
    while (i < r + 1 || j < b + 1) {
      px = new Path();
      px.name = "grid px";
      py = new Path();
      px.name = "grid py";
      ijOnPlanet = projectToPosOnPlanet(new Point(i * g.scale, j * g.scale));
      if (ijOnPlanet.x === -180) {
        px.strokeColor = "#00FF00";
        px.strokeWidth = 5;
      } else if (n < 4) {
        px.strokeColor = "#666666";
      } else {
        px.strokeColor = "#000000";
        px.strokeWidth = 2;
      }
      if (ijOnPlanet.y === -90) {
        py.strokeColor = "#00FF00";
        py.strokeWidth = 5;
      } else if (n < 4) {
        py.strokeColor = "#666666";
      } else {
        py.strokeColor = "#000000";
        py.strokeWidth = 2;
      }
      px.add(new Point(i * g.scale, view.bounds.top));
      px.add(new Point(i * g.scale, view.bounds.bottom));
      py.add(new Point(view.bounds.left, j * g.scale));
      py.add(new Point(view.bounds.right, j * g.scale));
      g.grid.addChild(px);
      g.grid.addChild(py);
      i += snap / g.scale;
      j += snap / g.scale;
      if (n === 4) {
        n = 0;
      }
      n++;
    }
    if (!debug) {
      return;
    }
    i = l;
    while (i < r + 1) {
      j = t;
      while (j < b + 1) {
        x = i * g.scale;
        y = j * g.scale;
        planetText = new PointText(new Point(x - 10, y - 40));
        planetText.justification = 'right';
        planetText.fillColor = 'black';
        p = projectToPlanet(new Point(i * g.scale, j * g.scale));
        planetText.content = 'px: ' + Math.floor(p.x) + ', py: ' + Math.floor(p.y);
        g.grid.addChild(planetText);
        posText = new PointText(new Point(x - 10, y - 20));
        posText.justification = 'right';
        posText.fillColor = 'black';
        p = projectToPosOnPlanet(new Point(i * g.scale, j * g.scale));
        posText.content = 'x: ' + p.x.toFixed(2) + ', y: ' + p.y.toFixed(2);
        g.grid.addChild(posText);
        j += snap / g.scale;
      }
      i += snap / g.scale;
    }
  };

  this.gameAt = function(point) {
    var div, _i, _len, _ref;
    _ref = g.divs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      div = _ref[_i];
      if (div.getBounds().contains(point) && div.constructor.name === 'RVideoGame') {
        return div;
      }
    }
    return null;
  };

  g.RMoveTo = function(pos, delay, addCommand) {
    var initialPosition, somethingToLoad, tween;
    if (addCommand == null) {
      addCommand = true;
    }
    if (delay == null) {
      somethingToLoad = g.RMoveBy(pos.subtract(view.center), addCommand);
    } else {
      initialPosition = view.center;
      tween = new TWEEN.Tween(initialPosition).to(pos, delay).easing(TWEEN.Easing.Exponential.InOut).onUpdate(function() {
        g.RMoveTo(this, addCommand);
      }).start();
    }
    return somethingToLoad;
  };

  g.RMoveBy = function(delta, addCommand) {
    var addMoveCommand, area, div, newEntireArea, newView, pk, rectangle, restrictedAreaShrinked, somethingToLoad, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    if (addCommand == null) {
      addCommand = true;
    }
    if (g.restrictedArea != null) {
      if (!g.restrictedArea.contains(view.center)) {
        delta = g.restrictedArea.center.subtract(view.center);
      } else {
        newView = view.bounds.clone();
        newView.center.x += delta.x;
        newView.center.y += delta.y;
        if (!g.restrictedArea.contains(newView)) {
          restrictedAreaShrinked = g.restrictedArea.expand(view.size.multiply(-1));
          if (restrictedAreaShrinked.width < 0) {
            restrictedAreaShrinked.left = restrictedAreaShrinked.right = g.restrictedArea.center.x;
          }
          if (restrictedAreaShrinked.height < 0) {
            restrictedAreaShrinked.top = restrictedAreaShrinked.bottom = g.restrictedArea.center.y;
          }
          newView.center.x = g.clamp(restrictedAreaShrinked.left, newView.center.x, restrictedAreaShrinked.right);
          newView.center.y = g.clamp(restrictedAreaShrinked.top, newView.center.y, restrictedAreaShrinked.bottom);
          delta = newView.center.subtract(view.center);
        }
      }
    }
    if (g.previousViewPosition == null) {
      g.previousViewPosition = view.center;
    }
    project.view.scrollBy(new Point(delta.x, delta.y));
    _ref = g.divs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      div = _ref[_i];
      div.updateTransform();
    }
    updateGrid();
    newEntireArea = null;
    _ref1 = g.entireAreas;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      area = _ref1[_j];
      if (area.getBounds().contains(project.view.center)) {
        newEntireArea = area;
        break;
      }
    }
    if ((g.entireArea == null) && (newEntireArea != null)) {
      g.entireArea = newEntireArea.getBounds();
    } else if ((g.entireArea != null) && (newEntireArea == null)) {
      g.entireArea = null;
    }
    somethingToLoad = newEntireArea != null ? load(g.entireArea) : load();
    g.updateRoom();
    g.deferredExecution(g.updateHash, 'updateHash', 500);
    if (addCommand) {
      addMoveCommand = function() {
        g.commandManager.add(new MoveViewCommand(g.previousViewPosition, view.center));
        g.previousViewPosition = null;
      };
      g.deferredExecution(addMoveCommand, 'add move command');
    }
    _ref2 = g.areasToUpdate;
    for (pk in _ref2) {
      rectangle = _ref2[pk];
      if (rectangle.intersects(view.bounds)) {
        g.updateView();
        break;
      }
    }
    g.setControllerValue(g.parameters.location.controller, null, '' + view.center.x.toFixed(2) + ',' + view.center.y.toFixed(2));
    return somethingToLoad;
  };

  g.updateHash = function() {
    g.ignoreHashChange = true;
    location.hash = '' + view.center.x.toFixed(2) + ',' + view.center.y.toFixed(2);
  };

  window.onhashchange = function(event) {
    var p, pos;
    if (g.ignoreHashChange) {
      g.ignoreHashChange = false;
      return;
    }
    pos = location.hash.substr(1).split(',');
    p = new Point();
    p.x = parseFloat(pos[0]);
    p.y = parseFloat(pos[1]);
    if (!p.x) {
      p.x = 0;
    }
    if (!p.y) {
      p.y = 0;
    }
    g.RMoveTo(p);
  };

  this.deselectAll = function() {
    var item, _i, _len, _ref;
    g.previouslySelectedItems = g.selectedItems.slice();
    _ref = g.previouslySelectedItems;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (typeof item.deselect === "function") {
        item.deselect(false);
      }
    }
    project.activeLayer.selected = false;
  };

  this.toggleSidebar = function(show) {
    if (show == null) {
      show = !g.sidebarJ.hasClass("r-hidden");
    }
    if (show) {
      g.sidebarJ.addClass("r-hidden");
      g.editorJ.addClass("r-hidden");
      g.alertsContainer.addClass("r-sidebar-hidden");
      g.sidebarHandleJ.find("span").removeClass("glyphicon-chevron-left").addClass("glyphicon-chevron-right");
    } else {
      g.sidebarJ.removeClass("r-hidden");
      g.editorJ.removeClass("r-hidden");
      g.alertsContainer.removeClass("r-sidebar-hidden");
      g.sidebarHandleJ.find("span").removeClass("glyphicon-chevron-right").addClass("glyphicon-chevron-left");
    }
  };

  this.highlightStage = function(color) {
    g.backgroundRectangle = new Path.Rectangle(view.bounds);
    g.backgroundRectangle.fillColor = color;
    g.backgroundRectangle.sendToBack();
  };

  this.unhighlightStage = function() {
    var _ref;
    if ((_ref = g.backgroundRectangle) != null) {
      _ref.remove();
    }
    g.backgroundRectangle = null;
  };

  this.benchmarkRectangleClone = function() {
    var d, end, i, p, r, r2, start, _i, _j;
    start = Date.now();
    r = new Rectangle(1, 2, 3, 4);
    p = new Point(5, 6);
    for (i = _i = 0; _i <= 1000000; i = ++_i) {
      r2 = r.clone();
      r2.center = p;
    }
    end = Date.now();
    console.log("rectangle clone time: " + (end - start));
    d = p.subtract(r.center);
    start = Date.now();
    for (i = _j = 0; _j <= 1000000; i = ++_j) {
      r.x += d.x;
      r.y += d.y;
    }
    end = Date.now();
    console.log("rectangle move time: " + (end - start));
  };

  this.highlightValidity = function(item) {
    g.validatePosition(item, null, true);
  };

  this.validatePosition = function(item, bounds, highlight) {
    var lock, locks, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
    if (bounds == null) {
      bounds = null;
    }
    if (highlight == null) {
      highlight = false;
    }
    if (bounds == null) {
      bounds = item.getBounds();
    }
    if ((_ref = g.limitPathV) != null) {
      _ref.strokeColor = 'green';
    }
    if ((_ref1 = g.limitPathH) != null) {
      _ref1.strokeColor = 'green';
    }
    _ref2 = g.locks;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      lock = _ref2[_i];
      lock.unhighlight();
    }
    this.unhighlightStage();
    if (g.rectangleOverlapsTwoPlanets(bounds)) {
      if (highlight) {
        if ((_ref3 = g.limitPathV) != null) {
          _ref3.strokeColor = 'red';
        }
        if ((_ref4 = g.limitPathH) != null) {
          _ref4.strokeColor = 'red';
        }
      } else {
        return false;
      }
    }
    locks = RLock.intersectRectangle(bounds);
    for (_j = 0, _len1 = locks.length; _j < _len1; _j++) {
      lock = locks[_j];
      if (RLock.prototype.isPrototypeOf(item)) {
        if (item !== lock) {
          if (highlight) {
            lock.highlight('red');
          } else {
            return false;
          }
        }
      } else {
        if (lock.getBounds().contains(bounds) && g.me === lock.owner) {
          if (item.lock !== lock) {
            if (highlight) {
              lock.highlight('green');
            } else {
              lock.addRItem(item);
            }
          }
        } else {
          if (highlight) {
            lock.highlight('red');
          } else {
            return false;
          }
        }
      }
    }
    if (locks.length === 0) {
      if (item.lock != null) {
        if (highlight) {
          this.highlightStage('green');
        } else {
          lock.removeRItem(item);
        }
      }
    }
    if (RLock.prototype.isPrototypeOf(item)) {
      if (!item.containsChildren()) {
        if (highlight) {
          item.highlight('red');
        } else {
          return false;
        }
      }
    }
    return true;
  };

  this.zIndexSortStop = (function(_this) {
    return function(event, ui) {
      var item, nextItemJ, previousItemJ, rItem, _i, _len, _ref;
      g.deselectAll();
      rItem = g.items[ui.item.attr("data-pk")];
      nextItemJ = ui.item.next();
      if (nextItemJ.length > 0) {
        rItem.insertAbove(g.items[nextItemJ.attr("data-pk")], null, true);
      } else {
        previousItemJ = ui.item.prev();
        if (previousItemJ.length > 0) {
          rItem.insertBelow(g.items[previousItemJ.attr("data-pk")], null, true);
        }
      }
      _ref = g.previouslySelectedItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        item.select();
      }
    };
  })(this);

  this.getRotatedBounds = function(rectangle, rotation) {
    var bottomLeft, bottomRight, bounds, topLeft, topRight;
    if (rotation == null) {
      rotation = 0;
    }
    topLeft = rectangle.topLeft.subtract(rectangle.center);
    topLeft.angle += rotation;
    bottomRight = rectangle.bottomRight.subtract(rectangle.center);
    bottomRight.angle += rotation;
    bottomLeft = rectangle.bottomLeft.subtract(rectangle.center);
    bottomLeft.angle += rotation;
    topRight = rectangle.topRight.subtract(rectangle.center);
    topRight.angle += rotation;
    bounds = new Rectangle(rectangle.center.add(topLeft), rectangle.center.add(bottomRight));
    bounds = bounds.include(rectangle.center.add(bottomLeft));
    bounds = bounds.include(rectangle.center.add(topRight));
    return bounds;
  };

  this.getRectangleListFromIntersection = function(rectangle1, rectangle2) {
    var i, rA, rB, rC, rD, rectangle, rectangles;
    rectangles = [];
    if ((!rectangle1.intersects(rectangle2)) || (rectangle2.contains(rectangle1))) {
      return rectangles;
    }
    rA = new Rectangle();
    rA.topLeft = rectangle1.topLeft;
    rA.bottomRight = new Point(rectangle1.right, rectangle2.top);
    rectangles.push(rA);
    rB = new Rectangle();
    rB.topLeft = new Point(rectangle1.left, Math.max(rectangle2.top, rectangle1.top));
    rB.bottomRight = new Point(rectangle2.left, Math.min(rectangle2.bottom, rectangle1.bottom));
    rectangles.push(rB);
    rC = new Rectangle();
    rC.topLeft = new Point(rectangle2.right, Math.max(rectangle2.top, rectangle1.top));
    rC.bottomRight = new Point(rectangle1.right, Math.min(rectangle2.bottom, rectangle1.bottom));
    rectangles.push(rC);
    rD = new Rectangle();
    rD.topLeft = new Point(rectangle1.left, rectangle2.bottom);
    rD.bottomRight = rectangle1.bottomRight;
    rectangles.push(rD);
    i = rectangles.length - 1;
    while (i >= 0) {
      rectangle = rectangles[i];
      if (rectangle.width <= 0 || rectangle.height <= 0) {
        rectangles.splice(i, 1);
      }
      i--;
    }
    return rectangles;
  };

  this.areaToImageDataUrl = function(rectangle, convertToView) {
    var canvasTemp, contextTemp, dataURL, viewRectangle;
    if (convertToView == null) {
      convertToView = true;
    }
    if (rectangle.height <= 0 || rectangle.width <= 0) {
      console.log('Warning: trying to extract empty area!!!');
      return null;
    }
    if (convertToView) {
      rectangle = rectangle.intersect(view.bounds);
      viewRectangle = g.projectToViewRectangle(rectangle);
    } else {
      viewRectangle = rectangle;
    }
    canvasTemp = document.createElement('canvas');
    canvasTemp.width = viewRectangle.width;
    canvasTemp.height = viewRectangle.height;
    contextTemp = canvasTemp.getContext('2d');
    contextTemp.putImageData(g.context.getImageData(viewRectangle.x, viewRectangle.y, viewRectangle.width, viewRectangle.height), 0, 0);
    dataURL = canvasTemp.toDataURL("image/png");
    return dataURL;
  };

  this.areaToImageDataUrlWithAreasNotRasterized = function(rectangle) {
    var area, areasNotRasterized, areasNotRasterizedBox, dataURL, intersection, item, itemObject, selectedItems, viewCenter, viewIntersection, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (view.zoom !== 1) {
      g.romanesco_alert("You are creating or modifying an item in a zoom different than 100. \nThis will not be rasterized, other users will have to render it \n(please consider drawing and modifying items at zoom 100 for better loading performances).", "warning", 3000);
      return {
        dataURL: null,
        rectangle: rectangle,
        areasNotRasterized: [g.boxFromRectangle(rectangle)]
      };
    }
    viewCenter = view.center;
    view.center = view.bounds.topLeft.round().add(view.size.multiply(0.5));
    rectangle = g.expandRectangleToInteger(rectangle);
    intersection = rectangle.intersect(view.bounds);
    intersection = g.shrinkRectangleToInteger(intersection);
    viewIntersection = g.roundRectangle(g.projectToViewRectangle(intersection));
    if (view.bounds.contains(rectangle) && !g.shrinkRectangleToInteger(intersection).equals(rectangle)) {
      console.log("ERROR: good error :-) but unlikely...");
      debugger;
    }
    if (!rectangle.topLeft.round().equals(rectangle.topLeft) || !rectangle.bottomRight.round().equals(rectangle.bottomRight)) {
      console.log('Error: rectangle is not rounded!');
      debugger;
    }
    if (!intersection.topLeft.round().equals(intersection.topLeft) || !intersection.bottomRight.round().equals(intersection.bottomRight)) {
      console.log('Error: rectangle is not rounded!');
      debugger;
    }
    if (!viewIntersection.topLeft.round().equals(viewIntersection.topLeft) || !viewIntersection.bottomRight.round().equals(viewIntersection.bottomRight)) {
      console.log('Error: rectangle is not rounded!');
      debugger;
    }
    selectedItems = [];
    _ref = project.getItems({
      selected: true
    });
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (((_ref1 = item.constructor) != null ? _ref1.name : void 0) !== "Group" && ((_ref2 = item.constructor) != null ? _ref2.name : void 0) !== "Layer") {
        selectedItems.push({
          item: item,
          fullySelected: item.fullySelected
        });
      }
    }
    project.activeLayer.selected = false;
    g.carLayer.visible = false;
    g.debugLayer.visible = false;
    view.draw();
    dataURL = areaToImageDataUrl(viewIntersection, false);
    view.center = viewCenter;
    g.debugLayer.visible = true;
    g.carLayer.visible = true;
    for (_j = 0, _len1 = selectedItems.length; _j < _len1; _j++) {
      itemObject = selectedItems[_j];
      if (itemObject.fullySelected) {
        itemObject.item.fullySelected = true;
      } else {
        itemObject.item.selected = true;
      }
    }
    areasNotRasterized = g.getRectangleListFromIntersection(rectangle, intersection);
    areasNotRasterizedBox = (function() {
      var _k, _len2, _results;
      _results = [];
      for (_k = 0, _len2 = areasNotRasterized.length; _k < _len2; _k++) {
        area = areasNotRasterized[_k];
        _results.push(g.boxFromRectangle(area));
      }
      return _results;
    })();
    for (_k = 0, _len2 = areasNotRasterized.length; _k < _len2; _k++) {
      area = areasNotRasterized[_k];
      console.log(area);
    }
    return {
      dataURL: dataURL,
      rectangle: intersection,
      areasNotRasterized: areasNotRasterizedBox
    };
  };

  this.addAreasToUpdate = function(newAreasToUpdate) {
    var area, debugRectangle, rectangle, _i, _len;
    for (_i = 0, _len = newAreasToUpdate.length; _i < _len; _i++) {
      area = newAreasToUpdate[_i];
      if (g.areasToUpdate[area._id.$oid] != null) {
        continue;
      }
      rectangle = g.rectangleFromBox(area);
      g.areasToUpdate[area._id.$oid] = rectangle;
      debugRectangle = new Path.Rectangle(rectangle);
      debugRectangle.strokeColor = 'red';
      debugRectangle.strokeWidth = 1;
      debugRectangle.name = area._id.$oid;
      g.debugLayer.addChild(debugRectangle);
      g.areasToUpdateRectangles[area._id.$oid] = debugRectangle;
    }
  };

  this.updateRasters = function(rectangle, areaPk) {
    var area, br, extraction, planet, tl, _i, _len, _ref, _ref1;
    if (areaPk == null) {
      areaPk = null;
    }
    extraction = g.areaToImageDataUrlWithAreasNotRasterized(rectangle);
    console.log('request to add ' + ((_ref = extraction.areasNotRasterized) != null ? _ref.length : void 0) + ' areas');
    _ref1 = extraction.areasNotRasterized;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      area = _ref1[_i];
      console.log("---");
      console.log(area);
      planet = new Point(area.planet);
      tl = posOnPlanetToProject(area.tl, planet);
      br = posOnPlanetToProject(area.br, planet);
      console.log(new Rectangle(tl, br).toJSON());
    }
    if (extraction.dataURL === "data:,") {
      console.log("Warning: trying to add an area outside the screen!");
    }
  };

  this.batchUpdateRasters_callback = function(results) {
    var result, _i, _len;
    for (_i = 0, _len = results.length; _i < _len; _i++) {
      result = results[_i];
      updateRasters_callback(result);
    }
  };

  this.updateRasters_callback = function(results) {
    var area, areaToDeletePk, debugRectangle, newAreasToUpdate, _i, _j, _len, _len1, _ref, _ref1;
    if (!g.checkError(results)) {
      return;
    }
    if (results.state === 'log' && results.message === 'Delete impossible: area does not exist') {
      return;
    }
    if (results.areasDeleted != null) {
      _ref = results.areasDeleted;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        areaToDeletePk = _ref[_i];
        if (g.areasToUpdate[areaToDeletePk] != null) {
          debugRectangle = debugLayer.getItem({
            name: areaToDeletePk
          });
          if (debugRectangle != null) {
            debugRectangle.strokeColor = 'green';
            setTimeout((function(debugRectangle) {
              return function() {
                return debugRectangle.remove();
              };
            })(debugRectangle), 2000);
          }
          delete g.areasToUpdate[areaToDeletePk];
        } else {
          console.log('Error: area to delete could not be found');
          debugger;
        }
      }
    }
    newAreasToUpdate = [];
    if (results.areasToUpdate != null) {
      _ref1 = results.areasToUpdate;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        area = _ref1[_j];
        newAreasToUpdate.push(JSON.parse(area));
      }
    }
    g.addAreasToUpdate(newAreasToUpdate);
  };

  this.updateAreasToUpdate = function() {
    var areaNotRasterized, areaToDeletePks, arg, args, debugRectangle, extraction, intersection, pk, rectangle, viewUpdated, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (view.zoom !== 1) {
      return;
    }
    viewUpdated = false;
    args = [];
    _ref = g.areasToUpdate;
    for (pk in _ref) {
      rectangle = _ref[pk];
      intersection = rectangle.intersect(view.bounds);
      if ((rectangle.width > 1 && intersection.width <= 1) || (rectangle.height > 1 && intersection.height <= 1)) {
        continue;
      }
      debugRectangle = g.areasToUpdateRectangles[pk];
      if (debugRectangle != null) {
        debugRectangle.strokeColor = 'blue';
        setTimeout((function(debugRectangle) {
          return function() {
            return debugRectangle.remove();
          };
        })(debugRectangle), 2000);
      } else {
        console.log('Error: could not find debug rectangles');
      }
      if (!viewUpdated) {
        g.updateView();
        viewUpdated = true;
      }
      extraction = g.areaToImageDataUrlWithAreasNotRasterized(rectangle);
      if (extraction.dataURL === "data:,") {
        console.log("Warning: trying to add an area outside the screen!");
      }
      args.push({
        'data': extraction.dataURL,
        'position': extraction.rectangle.topLeft,
        'areasNotRasterized': extraction.areasNotRasterized,
        'areaToDeletePk': pk
      });
      delete g.areasToUpdate[pk];
    }
    areaToDeletePks = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (areaToDeletePks.indexOf(arg.areaToDeletePk) >= 0) {
        console.log('areaToDeletePk is twice!!');
        debugger;
      }
      _ref1 = arg.areasNotRasterized;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        areaNotRasterized = _ref1[_j];
        _ref2 = g.areasToUpdate;
        for (rectangle = _k = 0, _len2 = _ref2.length; _k < _len2; rectangle = ++_k) {
          pk = _ref2[rectangle];
          intersection = areaNotRasterized.intersect(rectangle);
          if (intersection.area > 0) {
            console.log('rectangles ' + rectangle.toString() + ', and ' + areaNotRasterized.toString() + ' should not intersect');
            debugger;
          }
        }
      }
      areaToDeletePks.push(arg.areaToDeletePk);
    }
    if (args.length > 0) {
      Dajaxice.draw.batchUpdateRasters(g.batchUpdateRasters_callback, {
        'args': args
      });
    }
    g.willUpdateAreasToUpdate = false;
  };

  this.updateView = function(ritem) {
    var item, pk, raster, rasterColumn, x, y, _ref, _ref1;
    if (ritem == null) {
      ritem = null;
    }
    _ref = g.rasters;
    for (x in _ref) {
      rasterColumn = _ref[x];
      for (y in rasterColumn) {
        raster = rasterColumn[y];
        raster.remove();
        delete g.rasters[x][y];
        if (g.isEmpty(g.rasters[x])) {
          delete g.rasters[x];
        }
      }
    }
    _ref1 = g.paths;
    for (pk in _ref1) {
      item = _ref1[pk];
      item.draw();
    }
  };

  this.rasterizeArea = function(rectangle) {
    var b, dataURL, height, item, l, r, restoreView, selectedItems, t, viewCenter, viewZoom, width, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2;
    rectangle = g.expandRectangleToInteger(rectangle);
    viewCenter = view.center;
    viewZoom = view.zoom;
    selectedItems = [];
    _ref = project.getItems({
      selected: true
    });
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (((_ref1 = item.constructor) != null ? _ref1.name : void 0) !== "Group" && ((_ref2 = item.constructor) != null ? _ref2.name : void 0) !== "Layer") {
        selectedItems.push({
          item: item,
          fullySelected: item.fullySelected
        });
      }
    }
    project.activeLayer.selected = false;
    view.zoom = 1;
    view.center = view.bounds.topLeft.round().add(view.size.multiply(0.5));
    restoreView = function() {
      var itemObject, _j, _len1;
      view.zoom = viewZoom;
      view.center = viewCenter;
      g.debugLayer.visible = true;
      g.carLayer.visible = true;
      for (_j = 0, _len1 = selectedItems.length; _j < _len1; _j++) {
        itemObject = selectedItems[_j];
        if (itemObject.fullySelected) {
          itemObject.item.fullySelected = true;
        } else {
          itemObject.item.selected = true;
        }
      }
      view.draw();
      view.update();
    };
    if (view.bounds.contains(rectangle)) {
      dataURL = areaToImageDataUrl(g.roundRectangle(g.projectToViewRectangle(rectangle)), false);
      g.rastersToUpload.push({
        data: dataURL,
        position: rectangle.topLeft
      });
    } else {
      if (rectangle.area > 4 * Math.min(view.bounds.area, 1000 * 1000)) {
        restoreView();
        return;
      }
      t = Math.floor(rectangle.top / scale);
      l = Math.floor(rectangle.left / scale);
      b = Math.floor(rectangle.bottom / scale);
      r = Math.floor(rectangle.right / scale);
      for (x = _j = l; l <= r ? _j <= r : _j >= r; x = l <= r ? ++_j : --_j) {
        for (y = _k = t; t <= b ? _k <= b : _k >= b; y = t <= b ? ++_k : --_k) {
          if (!g.areaIsQuickLoaded({
            x: x,
            y: y
          })) {
            restoreView();
            return;
          }
        }
      }
      view.center = rectangle.topLeft.add(view.size.multiply(0.5));
      while (view.bounds.bottom < rectangle.bottom) {
        while (view.bounds.right < rectangle.right) {
          width = Math.min(Math.min(view.size.width, 1000), rectangle.right - view.bounds.left);
          height = Math.min(Math.min(view.size.height, 1000), rectangle.bottom - view.bounds.top);
          dataURL = areaToImageDataUrl(new Rectangle(0, 0, width, height), false);
          g.rastersToUpload.push({
            data: dataURL,
            position: view.bounds.topLeft
          });
          view.center = view.center.add(Math.min(view.size.width, 1000), 0);
        }
        view.center = new Point(rectangle.left + view.size.width * 0.5, view.center.y + Math.min(view.size.height, 1000));
      }
    }
    if (!g.isUpdatingRasters) {
      g.loopUpdateRasters();
    }
    restoreView();
  };

  this.loopUpdateRasters = function(results) {
    g.checkError(results);
    if (g.rastersToUpload.length > 0) {
      g.isUpdatingRasters = true;
    } else {
      g.isUpdatingRasters = false;
    }
  };

  this.rasterizeAreasToUpdate = function() {
    Dajaxice.draw.getAreasToUpdate(rasterizeAreasToUpdate_callback);
  };

  this.rasterizeAreasToUpdate_callback = function(areas) {
    var area, rectangle;
    g.areasToRasterize = areas;
    area = g.areasToRasterize.first();
    if (!area) {
      return;
    }
    rectangle = g.rectangleFromBox(area);
    project.activeLayer.selected = false;
    g.carLayer.visible = false;
    g.debugLayer.visible = false;
    view.zoom = 1;
    view.center = rectangle.topLeft.add(view.size.multiply(0.5));
    this.rasterizeAreasToUpdate_loop();
  };

  this.rasterizeAreasToUpdate_loop = function() {
    var area, dataURL, height, rectangle, waitUntilLastRastersAreUpdloaded, width;
    if (g.rastersToUpload.length > 10) {
      if (!g.isUpdatingRasters) {
        g.loopUpdateRasters();
      }
      setTimeout(rasterizeAreasToUpdate_loop, 1000);
      return;
    }
    area = g.areasToRasterize.first();
    if (!area) {
      console.log('area is null, g.areasToRasterize is empty?');
      debugger;
      return;
    }
    rectangle = g.rectangleFromBox(area);
    width = Math.min(Math.min(view.size.width, 1000), rectangle.right - view.bounds.left);
    height = Math.min(Math.min(view.size.height, 1000), rectangle.bottom - view.bounds.top);
    dataURL = areaToImageDataUrl(new Rectangle(0, 0, width, height), false);
    g.rastersToUpload.push({
      data: dataURL,
      position: view.bounds.topLeft
    });
    view.update();
    view.center = view.center.add(Math.min(view.size.width, 1000), 0);
    if (view.bounds.left > rectangle.right) {
      view.center = new Point(rectangle.left + view.size.width * 0.5, view.center.y + Math.min(view.size.height, 1000));
    }
    if (view.bounds.top > rectangle.bottom) {
      g.rastersToUpload.last().areaToDeletePk = area._id.$oid;
      g.areasToRasterize.shift();
      if (g.areasToRasterize.length > 0) {
        area = g.areasToRasterize.first();
        rectangle = g.rectangleFromBox(area);
        view.center = rectangle.topLeft.add(view.size.multiply(0.5));
      } else {
        waitUntilLastRastersAreUpdloaded = function() {
          if (g.isUpdatingRasters) {
            setTimeout(waitUntilLastRastersAreUpdloaded, 1000);
          } else {
            g.loopUpdateRasters();
          }
        };
        waitUntilLastRastersAreUpdloaded();
        g.debugLayer.visible = true;
        g.carLayer.visible = true;
        return;
      }
    }
    if (!g.isUpdatingRasters) {
      g.loopUpdateRasters();
    }
    setTimeout(rasterizeAreasToUpdate_loop, 0);
  };

  this.shrinkRectangleToInteger = function(rectangle) {
    return new Rectangle(rectangle.topLeft.ceil(), rectangle.bottomRight.floor());
  };

  this.expandRectangleToInteger = function(rectangle) {
    return new Rectangle(rectangle.topLeft.floor(), rectangle.bottomRight.ceil());
  };

  this.roundRectangle = function(rectangle) {
    return new Rectangle(rectangle.topLeft.round(), rectangle.bottomRight.round());
  };

  this.roundToLowerMultiple = function(x, m) {
    return Math.floor(x / m) * m;
  };

  this.roundToGreaterMultiple = function(x, m) {
    return Math.ceil(x / m) * m;
  };

  this.highlightAreasToUpdate = function() {
    var pk, rectangle, rectanglePath, _ref;
    _ref = g.areasToUpdate;
    for (pk in _ref) {
      rectangle = _ref[pk];
      rectanglePath = project.getItem({
        name: pk
      });
      rectanglePath.strokeColor = 'green';
    }
  };

  this.logItems = function() {
    var i, item, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    console.log("Selected items:");
    _ref = project.selectedItems;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      if (((_ref1 = item.name) != null ? _ref1.indexOf("debug") : void 0) === 0) {
        continue;
      }
      console.log("------" + i + "------");
      console.log(item.name);
      console.log(item);
      console.log(item.controller);
      console.log((_ref2 = item.controller) != null ? _ref2.pk : void 0);
    }
    console.log("All items:");
    _ref3 = project.activeLayer.children;
    for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
      item = _ref3[i];
      if (((_ref4 = item.name) != null ? _ref4.indexOf("debug") : void 0) === 0) {
        continue;
      }
      console.log("------" + i + "------");
      console.log(item.name);
      console.log(item);
      console.log(item.controller);
      console.log((_ref5 = item.controller) != null ? _ref5.pk : void 0);
    }
    return "--- THE END ---";
  };

  this.checkRasters = function() {
    var item, _i, _len, _ref;
    _ref = project.activeLayer.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if ((item.controller != null) && (item.controller.raster == null)) {
        console.log(item.controller);
      }
    }
  };

  this.selectRasters = function() {
    var item, rasters, _i, _len, _ref;
    rasters = [];
    _ref = project.activeLayer.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (item.constructor.name === "Raster") {
        item.selected = true;
        rasters.push(item);
      }
    }
    console.log('selected rasters:');
    return rasters;
  };

  this.printPathList = function() {
    var names, pathClass, _i, _len, _ref;
    names = [];
    _ref = g.pathClasses;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pathClass = _ref[_i];
      names.push(pathClass.rname);
    }
    console.log(names);
  };

  this.testRectangleIntersection = function() {
    var p, pr, pr2, r, r2, rectangle, rectangles, _i, _len;
    r = new Rectangle(0, 0, 250, 400);
    pr = new Path.Rectangle(r);
    pr.strokeColor = 'blue';
    pr.strokeWidth = 5;
    r2 = new Rectangle(-30, 10, 10, 10);
    pr2 = new Path.Rectangle(r2);
    pr2.strokeColor = 'green';
    pr2.strokeWidth = 5;
    rectangles = g.getRectangleListFromIntersection(r2, r);
    for (_i = 0, _len = rectangles.length; _i < _len; _i++) {
      rectangle = rectangles[_i];
      p = new Path.Rectangle(rectangle);
      p.strokeColor = 'red';
      p.strokeWidth = 1;
    }
  };

}).call(this);

//# sourceMappingURL=global.map
