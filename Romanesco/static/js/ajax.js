// Generated by CoffeeScript 1.7.1
(function() {
  var __hasProp = {}.hasOwnProperty;

  this.checkError = function(result) {
    if (result.state === 'not_logged_in') {
      romanesco_alert("You must be logged in to update drawings to the database.", "info");
      return false;
    }
    if (result.state === 'error') {
      if (result.message === 'invalid_url') {
        romanesco_alert("Your URL is invalid or does not point to an existing page.", "error");
      } else {
        romanesco_alert("Error: " + result.message, "error");
      }
      return false;
    } else if (result.state === 'system_error') {
      console.log(result.message);
      return false;
    }
    return true;
  };

  this.areaIsLoaded = function(pos, planet) {
    var area, _i, _len, _ref;
    _ref = g.loadedAreas;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      area = _ref[_i];
      if (area.planet.x === planet.x && area.planet.y === planet.y) {
        if (area.pos.x === pos.x && area.pos.y === pos.y) {
          return true;
        }
      }
    }
    return false;
  };

  this.load = function(area) {
    var areaRectangle, areasToLoad, args, b, bounds, debug, i, item, itemsOutsideLimit, j, l, limit, loadedArea, pk, planet, pos, r, rectangle, removeRectangle, scale, showLoadingBar, t, unloadDist, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
    if (area == null) {
      area = null;
    }
    if ((g.previousLoadPosition != null) && g.previousLoadPosition.subtract(view.center).length < 50) {
      return;
    }
    console.log("load");
    debug = false;
    scale = !debug ? g.scale : 500;
    g.previousLoadPosition = view.center;
    if (area === null) {
      bounds = !debug ? view.bounds : view.bounds.scale(0.3, 0.3);
    } else {
      bounds = area;
    }
    t = Math.floor(bounds.top / scale) * scale;
    l = Math.floor(bounds.left / scale) * scale;
    b = Math.floor(bounds.bottom / scale) * scale;
    r = Math.floor(bounds.right / scale) * scale;
    if (debug) {
      if ((_ref = g.unloadRectangle) != null) {
        _ref.remove();
      }
      if ((_ref1 = g.viewRectangle) != null) {
        _ref1.remove();
      }
      if ((_ref2 = g.limitRectangle) != null) {
        _ref2.remove();
      }
      g.viewRectangle = new Path.Rectangle(bounds);
      g.viewRectangle.name = 'debug load view rectangle';
      g.viewRectangle.strokeWidth = 1;
      g.viewRectangle.strokeColor = 'blue';
      g.limitRectangle = new Path.Rectangle(new Point(l, t), new Point(r, b));
      g.limitRectangle.name = 'debug load limit rectangle';
      g.limitRectangle.strokeWidth = 2;
      g.limitRectangle.strokeColor = 'blue';
      g.limitRectangle.dashArray = [10, 4];
    }
    areasToLoad = [];
    for (x = _i = l; scale > 0 ? _i <= r : _i >= r; x = _i += scale) {
      for (y = _j = t; scale > 0 ? _j <= b : _j >= b; y = _j += scale) {
        planet = projectToPlanet(new Point(x, y));
        pos = projectToPosOnPlanet(new Point(x, y));
        if (!areaIsLoaded(pos, planet)) {
          if (debug) {
            areaRectangle = new Path.Rectangle(x, y, scale, scale);
            areaRectangle.name = 'debug load area rectangle';
            areaRectangle.strokeWidth = 1;
            areaRectangle.strokeColor = 'green';
          }
          area = {
            pos: pos,
            planet: planet
          };
          areasToLoad.push(area);
          if (debug) {
            area.rectangle = areaRectangle;
          }
          g.loadedAreas.push(area);
        }
      }
    }
    unloadDist = Math.round(2 * scale);
    if (!g.entireArea) {
      limit = bounds.expand(unloadDist);
    } else {
      limit = g.entireArea;
    }
    itemsOutsideLimit = [];
    _ref3 = g.items;
    for (pk in _ref3) {
      if (!__hasProp.call(_ref3, pk)) continue;
      item = _ref3[pk];
      if (!item.getBounds().intersects(limit)) {
        itemsOutsideLimit.push(item);
      }
    }
    if (debug) {
      g.unloadRectangle = new Path.Rectangle(limit);
      g.unloadRectangle.name = 'debug load unload rectangle';
      g.unloadRectangle.strokeWidth = 1;
      g.unloadRectangle.strokeColor = 'red';
      g.unloadRectangle.dashArray = [10, 4];
    }
    if (debug) {
      removeRectangle = function(rectangle) {
        var removeRect;
        removeRect = function() {
          return rectangle.remove();
        };
        setTimeout(removeRect, 1500);
      };
    }
    i = g.loadedAreas.length;
    while (i--) {
      loadedArea = g.loadedAreas[i];
      pos = posOnPlanetToProject(loadedArea.pos, loadedArea.planet);
      rectangle = new Rectangle(pos.x, pos.y, scale, scale);
      if (!rectangle.intersects(limit)) {
        area = g.loadedAreas[i];
        if (debug) {
          area.rectangle.strokeColor = 'red';
          removeRectangle(area.rectangle);
        }
        g.loadedAreas.splice(i, 1);
        j = itemsOutsideLimit.length;
        while (j--) {
          item = itemsOutsideLimit[j];
          if (item.getBounds().intersects(rectangle)) {
            item.remove();
            itemsOutsideLimit.splice(j, 1);
          }
        }
      }
    }
    itemsOutsideLimit = null;
    if (areasToLoad.length <= 0) {
      return;
    }
    if (g.loadingBarTimeout == null) {
      showLoadingBar = function() {
        $("#loadingBar").show();
      };
      g.loadingBarTimeout = setTimeout(showLoadingBar, 0);
    }
    console.log("load areas: " + areasToLoad.length);
    args = new Object();
    args.areasToLoad = areasToLoad;
    Dajaxice.draw.load(load_callback, args);
  };

  this.load_callback = function(results) {
    var b, box, br, d, data, date, div, divJ, itemIsLoaded, lock, p, path, planet, point, points, rmedia, rpath, rtext, tl, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    checkError(results);
    if (results.hasOwnProperty('message') && results.message === 'no_paths') {
      return;
    }
    if (g.me == null) {
      g.me = results.user;
      if (g.chatJ.find("#chatUserNameInput").length === 0) {
        g.startChatting(g.me);
      }
    }
    itemIsLoaded = function(pk) {
      return g.items[pk] != null;
    };
    _ref = results.boxes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      b = _ref[_i];
      _ref1 = JSON.parse(b);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        box = _ref1[_j];
        if (itemIsLoaded(box._id.$oid)) {
          continue;
        }
        if (box.box.coordinates[0].length < 5) {
          console.log("Error: box has less than 5 points");
        }
        planet = new Point(box.planetX, box.planetY);
        tl = posOnPlanetToProject(box.box.coordinates[0][0], planet);
        br = posOnPlanetToProject(box.box.coordinates[0][2], planet);
        data = (box.data != null) && box.data.length > 0 ? JSON.parse(box.data) : null;
        lock = null;
        switch (box.object_type) {
          case 'link':
            lock = new RLink(tl, new Size(br.subtract(tl)), box.owner, box._id.$oid, box.message, box.name, box.url, data);
            break;
          case 'lock':
            lock = new RLock(tl, new Size(br.subtract(tl)), box.owner, box._id.$oid, box.message, false, data);
            break;
          case 'website':
            lock = new RWebsite(tl, new Size(br.subtract(tl)), box.owner, box._id.$oid, box.message, data);
            break;
          case 'video-game':
            lock = new RVideoGame(tl, new Size(br.subtract(tl)), box.owner, box._id.$oid, box.message, data);
        }
        if (data != null ? data.loadEntireArea : void 0) {
          g.entireAreas.push(lock);
        }
      }
    }
    _ref2 = results.paths;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      p = _ref2[_k];
      _ref3 = JSON.parse(p);
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        path = _ref3[_l];
        if (itemIsLoaded(path._id.$oid)) {
          continue;
        }
        planet = new Point(path.planetX, path.planetY);
        date = path.date.$date;
        if ((path.data != null) && path.data.length > 0) {
          data = JSON.parse(path.data);
          data.planet = planet;
        }
        points = [];
        _ref4 = path.points.coordinates;
        for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
          point = _ref4[_m];
          points.push(posOnPlanetToProject(point, planet));
        }
        if (g.tools[path.object_type] != null) {
          rpath = new g.tools[path.object_type].RPath(date, data, path._id.$oid, points);
          if (rpath.constructor.name === "Checkpoint") {
            console.log(rpath);
          }
        } else {
          console.log("Unknown path type: " + path.object_type);
        }
      }
    }
    _ref5 = results.divs;
    for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
      d = _ref5[_n];
      _ref6 = JSON.parse(d);
      for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
        div = _ref6[_o];
        if (itemIsLoaded(div._id.$oid)) {
          continue;
        }
        if (div.box.coordinates[0].length < 5) {
          console.log("Error: box has less than 5 points");
        }
        planet = new Point(div.planetX, div.planetY);
        tl = posOnPlanetToProject(div.box.coordinates[0][0], planet);
        br = posOnPlanetToProject(div.box.coordinates[0][2], planet);
        data = (div.data != null) && div.data.length > 0 ? JSON.parse(div.data) : null;
        divJ = null;
        if (div.object_type === 'text') {
          rtext = new RText(tl, new Size(br.subtract(tl)), div.owner, div._id.$oid, div.locked, div.message, data);
          divJ = rtext.divJ;
        } else if (div.object_type === 'media') {
          rmedia = new RMedia(tl, new Size(br.subtract(tl)), div.owner, div._id.$oid, div.locked, div.url, data);
          divJ = rmedia.divJ;
        }
      }
    }
    view.draw();
    clearTimeout(g.loadingBarTimeout);
    g.loadingBarTimeout = null;
    $("#loadingBar").hide();
  };

}).call(this);

//# sourceMappingURL=ajax.map
