{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"mu",
				"multiply"
			],
			[
				"objc",
				"object_type"
			],
			[
				"els",
				"else"
			],
			[
				"deregister",
				"deregisterAnimation"
			],
			[
				"margin",
				"margin-top"
			],
			[
				"init",
				"initialPosition"
			],
			[
				"RM",
				"RMoveTo"
			],
			[
				"cl",
				"click"
			],
			[
				"move",
				"moveGui"
			],
			[
				"tiny",
				"tinycolor"
			],
			[
				"input",
				"inputJ"
			],
			[
				"center",
				"center"
			],
			[
				"repla",
				"replaceGui"
			],
			[
				"repl",
				"replaceGui"
			],
			[
				"colo",
				"colorpickersliders"
			],
			[
				"Rect",
				"RectangleShape"
			],
			[
				"fa",
				"favorite"
			],
			[
				"path",
				"pathClass"
			],
			[
				"Geo",
				"GeometricLines"
			],
			[
				"margin-",
				"margin-right"
			],
			[
				"ini",
				"initialize"
			],
			[
				"location",
				"locationURL"
			],
			[
				"data-",
				"data-font-family"
			],
			[
				"show",
				"showAlert"
			],
			[
				"bounds",
				"boundsPath"
			],
			[
				"stroke",
				"strokeBounds"
			],
			[
				"rotat",
				"rotation"
			],
			[
				"conten",
				"contentJ"
			],
			[
				"sele",
				"selectedTool"
			],
			[
				"roman",
				"Romanesco_alerts"
			],
			[
				"initi",
				"initialize"
			],
			[
				"ras",
				"rasterize"
			],
			[
				"play",
				"playOnLoad"
			],
			[
				"cons",
				"constructor"
			],
			[
				"rotati",
				"rotationSpeed"
			],
			[
				"class",
				"className"
			],
			[
				"B",
				"BooleanField"
			],
			[
				"spe",
				"specialKey"
			],
			[
				"sc",
				"scriptName"
			],
			[
				"exi",
				"exists"
			],
			[
				"add",
				"addTool"
			],
			[
				"save",
				"saveChanges"
			],
			[
				"item",
				"itemsOutsideLimit"
			],
			[
				"pint",
				"pinterestModalJ"
			],
			[
				"modal",
				"modal"
			],
			[
				"emtp",
				"emptyTwitterDiv"
			],
			[
				"publi",
				"publishOnFacebook"
			],
			[
				"obje",
				"object_type"
			],
			[
				"hie",
				"hide"
			],
			[
				"type",
				"object_type"
			],
			[
				"romanesco",
				"romanesco_alert"
			],
			[
				"thro",
				"throw"
			],
			[
				"contr",
				"constructor"
			],
			[
				"enti",
				"entireArea"
			],
			[
				"me",
				"media"
			],
			[
				"sprite",
				"spriteName"
			],
			[
				"max",
				"maxSpeed"
			],
			[
				"pla",
				"plays"
			],
			[
				"bufferO",
				"bufferOnLoad"
			],
			[
				"buffer",
				"bufferOnError"
			],
			[
				"url",
				"urlList"
			],
			[
				"buffe",
				"bufferList"
			],
			[
				"loa",
				"loadCount"
			],
			[
				"buff",
				"bufferList"
			],
			[
				"load",
				"loader"
			],
			[
				"re",
				"request"
			],
			[
				"deco",
				"decodeAudioData"
			],
			[
				"cont",
				"context"
			],
			[
				"array",
				"arraybuffer"
			],
			[
				"call",
				"callback"
			],
			[
				"acti",
				"activate"
			],
			[
				"controlPa",
				"controlPathLength"
			],
			[
				"contorlPa",
				"controlPathLength"
			],
			[
				"star",
				"startLoadingBar"
			],
			[
				"loadin",
				"loadingBar"
			],
			[
				"loadi",
				"loadingBar"
			],
			[
				"lo",
				"location"
			],
			[
				"par",
				"parameters"
			],
			[
				"delta",
				"delta"
			],
			[
				"selec",
				"selected"
			],
			[
				"upda",
				"update"
			],
			[
				"update",
				"updateCar"
			],
			[
				"window",
				"windowJ"
			],
			[
				"code",
				"codeEditor"
			],
			[
				"back",
				"background-color"
			],
			[
				"mar",
				"margin-right"
			],
			[
				"ma",
				"margin-bottom"
			],
			[
				"romane",
				"romanescoCode"
			],
			[
				"op",
				"Option"
			],
			[
				"obj",
				"object_type"
			],
			[
				"def",
				"default"
			],
			[
				"trans",
				"transform"
			],
			[
				"con",
				"console"
			],
			[
				"log",
				"logMessage"
			],
			[
				"erro",
				"error"
			],
			[
				"error",
				"errorMessage"
			],
			[
				"tre",
				"true"
			],
			[
				"new",
				"newView"
			],
			[
				"resti",
				"restrictedAreaPath"
			],
			[
				"res",
				"restrictedArea"
			],
			[
				"ret",
				"restrictedArea"
			],
			[
				"disabl",
				"disableToolbar"
			],
			[
				"ta",
				"target"
			],
			[
				"web",
				"website"
			],
			[
				"check",
				"checked"
			],
			[
				"select",
				"selectBegin"
			],
			[
				"mouse",
				"mousedown"
			],
			[
				"lock",
				"locked"
			],
			[
				"loc",
				"locked"
			],
			[
				"us",
				"username"
			],
			[
				"side",
				"sidebarJ"
			],
			[
				"can",
				"canvasJ"
			],
			[
				"req",
				"required"
			],
			[
				"segm",
				"segment"
			],
			[
				"profil",
				"profil_image"
			],
			[
				"de",
				"default"
			],
			[
				"user",
				"userGoogleId"
			],
			[
				"val",
				"value"
			],
			[
				"get",
				"getSnap"
			],
			[
				"romanes",
				"romanesco_alert"
			],
			[
				"im",
				"imgJ"
			],
			[
				"sv",
				"svgGroup"
			],
			[
				"canva",
				"canvasTemp"
			],
			[
				"control",
				"controlPath"
			],
			[
				"rec",
				"rectangle"
			],
			[
				"desele",
				"deselected"
			],
			[
				"dr",
				"drawing"
			],
			[
				"it",
				"itemsToSave"
			]
		]
	},
	"buffers":
	[
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/index.html",
			"settings":
			{
				"buffer_size": 39829,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/urls.py",
			"settings":
			{
				"buffer_size": 684,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/Romanesco/urls.py",
			"settings":
			{
				"buffer_size": 921,
				"line_ending": "Unix"
			}
		},
		{
			"file": "less/styles.less",
			"settings":
			{
				"buffer_size": 23026,
				"line_ending": "Windows"
			}
		},
		{
			"file": "less/flexbox.less",
			"settings":
			{
				"buffer_size": 3460,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/ajax.py",
			"settings":
			{
				"buffer_size": 17945,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/ajax.coffee",
			"settings":
			{
				"buffer_size": 17868,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/sockets.py",
			"settings":
			{
				"buffer_size": 11068,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/models.py",
			"settings":
			{
				"buffer_size": 4566,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/Romanesco/settings.py",
			"settings":
			{
				"buffer_size": 8109,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "# todo: Actions, undo & redo...\n# todo: strokeWidth min = 0?\n# todo change bounding box selection\n# todo/bug?: if @data? but not @data.id? then @id is not initialized, causing a bug when saving..\n# todo: have a selectPath (simplified version of group to test selection)instead of the group ?\n# todo: replace smooth by rsmooth and rdata in general.\n\n# important todo: pass args in deffered exec to update 'points' or 'data'\n\n# RPath: mother of all romanesco paths\n# A romanesco path (RPath) is a path made of the following items:\n# - a control path, with which users will interact\n# - a drawing group (the drawing) containing all visible items built around the control path (it must follow the control path)\n# - a selection group (containing a selection path) when the RPath is selected; it enables user to scale and rotate the RPath\n# - a group (main group or *group*) which contains all of the previous items\n\n# There are three main RPaths:\n# - PrecisePath adds control handles to the control path (which can be hidden): one can edit, add or remove points, to precisely shape the curve.\n# - SpeedPath which extends PrecisePath to add speed functionnalities: \n#    - the speed at which the user has drawn the path is stored and has influence on the drawing,\n#    - the speed values are displayed as normals of the path, and can be edited thanks to handles\n#    - when the user drags a handle, it will also influence surrounding speed values depending on how far from the normal the user drags the handle (with a gaussian attenuation)\n#    - the speed path and handles are added to a speed group, which is added to the main group\n#    - the speed group can be shown or hidden\n# - RShape defined by a rectangle in which the drawing should be included (the user draws the rectangle with the mouse)\n\n# Those three RPaths (PrecisePath, SpeedPath and RShape) provide drawing functionnalities and are meant to be overridden to generate some advanced paths:\n# - in PrecisePath and SpeedPath, three methods are meant to be overridden: drawBegin, drawUpdate and drawEnd, \n#   see {PrecisePath} to see how those methods are called while drawing.\n# - in RShape, {RShape#createShape} is meant to be overloaded\n\n# Parameters:\n# - parameters are defined as in RTools\n# - all data related to the parameters (and state) of the RPath is stored under the @data property\n# - dy default, when a parameter is chanegd in the gui, onParameterChange is called\n\n# tododoc: loadPath will call create begin, update, end\n# todo-doc: explain userAction?\n# todo-doc: explain ID?\n\n# Notable differences between RPath:\n# - in regular path: when transforming a path, the points of the control path are resaved with their new positions; no transform information is stored\n# - in RShape: the rectangle  is never changed with transformations; instead the rotation and scale are stored in @data and taken into account at each draw\n\nclass RPath\n	@rname = 'Pen' 										# the name used in the gui (to create the button and for the tooltip/popover)\n	@rdescription = \"The classic and basic pen tool\" 	# the path description\n	@cursorPosition = { x: 24, y: 0 } 					# the position of the cursor image (relative to the cursor position)\n	@cursorDefault = \"crosshair\" 						# the cursor to use with this path\n\n	# Paper hitOptions for hitTest function to check which items (corresponding to those criterias) are under a point\n	@hitOptions =\n		segments: true\n		stroke: true\n		fill: true\n		selected: true\n		tolerance: 5\n\n	@constructor.secureDistance = 2 					# the points of the flattened path must not be 5 pixels away from the recorded points\n\n	# parameters are defined as in {RTool}\n	# The following parameters are reserved for romanesco: id, polygonMode, points, planet, step, smooth, speeds, showSpeeds\n	@parameters: ()->\n		return parameters =\n			'General': \n				# zoom: g.parameters.zoom\n				# displayGrid: g.parameters.displayGrid\n				# snap: g.parameters.snap \n				align: g.parameters.align 				# common parameters are defined in g.parameters\n				distribute: g.parameters.distribute\n				duplicate: g.parameters.duplicate\n				delete: g.parameters.delete\n				editTool:\n					type: 'button'\n					label: 'Edit tool'\n					default: ()=> g.toolEditor(@)\n			'Style':\n				strokeWidth: $.extend(true, {}, g.parameters.strokeWidth)\n				strokeColor: $.extend(true, {}, g.parameters.strokeColor)\n				fillColor: $.extend(true, {}, g.parameters.fillColor)\n\n	# Create the RPath and initialize the drawing creation if a user is creating it, or draw if the path is being loaded\n	# When user creates a path, the path is given an identifier (@id); when the path is saved, the servers returns a primary key (@pk) and @id will not be used anymore\n	# @param date [Date] (optional) the date at which the path has been crated (will be used as z-index in further versions)\n	# @param data [Object] (optional) the data containing information about parameters and state of RPath\n	# @param pk [ID] (optional) the primary key of the path in the database\n	# @param points [Array of Point] (optional) the points of the controlPath, the points must fit on the control path (the control path is stored in @data.points)\n	constructor: (@date=null, @data=null, @pk=null, points=null) ->\n		@selectedSegment = null\n		\n		@id = if @data? then @data.id else Math.random() 	# temporary id used until the server sends back the primary key (@pk)\n\n		g.paths[@id] = @ 									# adds the path to the map of all RItems. key is @id for now, it will be replaced with @pk when server responds\n\n		if not @data? 				# if not @data then set @data to the values of the controllers in the gui\n			@data = new Object()\n			@data.id = @id\n			for name, folder of g.gui.__folders\n				if name=='General' then continue\n				for controller in folder.__controllers\n					@data[controller.property] = controller.rValue() 	# rValue returns the value of the controller, and custom information (in case of color: must return null if checkbox is uncheck)\n		\n		# if the RPath is being loaded: directly set pk and load path\n		if @pk?\n			@setPK(@pk, false)\n		if points?\n			@loadPath(points)\n		return\n	\n	# common to all RItems\n	# construct a new RPath and save it\n	# @return [RPath] the copy\n	duplicate: ()->\n		copy = new @constructor(new Date(), @getData(), null, @pathOnPlanet())\n		copy.save()\n		return copy\n\n	# returns the maximum width of the RPath arround control path\n	# the drawing can not exeed the limit of *@pathWidth()* around the contorl path\n	# path width is used for example for hit tests and to determine is the RPath overlaps on an RLock\n	pathWidth: ()->\n		return @data.strokeWidth\n\n	# common to all RItems\n	# return [Rectangle] the bounds of the control path (should fit the drawing entirely since the stroke width is pathWidth)\n	getBounds: ()->\n		return @controlPath.strokeBounds\n\n	# common to all RItems\n	# move the RPath by *delta* and update if *userAction*\n	# @param delta [Point] the amount by which moving the path\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user\n	moveBy: (delta, userAction)->\n		@group.position.x += delta.x\n		@group.position.y += delta.y\n		if userAction\n			g.defferedExecution(@update, @getPk())\n			# if g.me? and userAction then g.chatSocket.emit( \"double click\", g.me, @pk, g.eventToObject(event))\n		return\n\n	# common to all RItems\n	# move the RPath to *position* and update if *userAction*\n	# @param position [Point] the new position of the path\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user \n	# @return [Paper point] the new position\n	moveTo: (position, userAction)->\n		bounds = @getBounds()\n		delta = @group.position.subtract(bounds.center)\n		@group.position = position.add(delta)\n		if userAction\n			g.defferedExecution(@update, @getPk())\n			# if g.me? and userAction then g.chatSocket.emit( \"double click\", g.me, @pk, g.eventToObject(event))\n		return position.add(delta)\n\n	# convert a point from project coordinate system to raster coordinate system\n	# @param point [Paper point] point to convert\n	# @return [Paper point] resulting point\n	projectToRaster: (point)->\n		return point.subtract(@canvasRaster.bounds.topLeft)\n\n	# set path items (control path, drawing, etc.) to the right state before performing hitTest\n	# store the current state of items, and change their state (the original states will be restored in @finishHitTest())\n	# @param fullySelected [Boolean] (optional) whether the control path must be fully selected before performing the hit test (it must be if we want to test over control path handles)\n	# @param strokeWidth [Number] (optional) contorl path width will be set to *strokeWidth* if it is provided\n	prepareHitTest: (fullySelected=true, strokeWidth)->\n		console.log \"prepareHitTest\"\n		@hitTestSelected = @controlPath.selected  				# store control path select state\n\n		if fullySelected 										# select control path\n			@hitTestFullySelected = @controlPath.fullySelected\n			@controlPath.fullySelected = true\n		else\n			@controlPath.selected = true\n\n		# set control path and drawing to visible\n		# improvement: hide drawing to speed up the hitTest?\n		@hitTestControlPathVisible = @controlPath.visible\n		@controlPath.visible = true\n		@hitTestGroupVisible = @drawing.visible\n		@drawing.visible = true\n		\n		@hitTestStrokeWidth = @controlPath.strokeWidth\n		if strokeWidth then @controlPath.strokeWidth = strokeWidth\n\n		# hide raster and canvas raster\n		@raster?.visible = false\n		@canvasRaster?.visible = false\n		return\n\n	# restore path items orginial states (same as before @prepareHitTest())\n	# @param fullySelected [Boolean] (optional) whether the control path must be fully selected before performing the hit test (it must be if we want to test over control path handles)\n	finishHitTest: (fullySelected=true)->\n		console.log \"finishHitTest\"\n		if fullySelected then @controlPath.fullySelected = @hitTestFullySelected\n		@controlPath.selected = @hitTestSelected\n		@controlPath.visible = @hitTestControlPathVisible\n		@drawing.visible = @hitTestGroupVisible\n		@controlPath.strokeWidth = @hitTestStrokeWidth\n		@raster?.visible = true\n		@canvasRaster?.visible = true\n		return\n\n	# perform hit test to check if the point hits the selection rectangle  \n	# @param point [Point] the point to test\n	# @param hitOptions [Object] the [paper hit test options](http://paperjs.org/reference/item/#hittest-point)\n	hitTest: (point, hitOptions)->\n		return @selectionRectangle.hitTest(point)\n\n	# when hit through websocket, must be (fully)Selected to hitTest\n	# perform hit test on selection rectangle\n	# since @hitTest() will be overridden by children RPath, it is necessary to @prepareHitTest() and @finishHitTest()\n	# @param point [Point] the point to test\n	# @param hitOptions [Object] the [paper hit test options](http://paperjs.org/reference/item/#hittest-point)\n	# @param fullySelected [Boolean] (optional) whether the control path must be fully selected before performing the hit test (it must be if we want to test over control path handles)\n	# @return [Paper HitResult] the paper hit result\n	performeHitTest: (point, hitOptions, fullySelected=true)->\n		@prepareHitTest(fullySelected, 1)\n		hitResult = @hitTest(point, hitOptions)\n		@finishHitTest(fullySelected)\n		return hitResult\n\n	# add or update the selection rectangle (path used to rotate and scale the RPath)\n	# redefined by RShape\n	updateSelectionRectangle: ()->\n		# reset the selection rectangle (and use contorl path bounds as rectangle) if the control path has default transformation (rotation==0 and scaling==(1, 1))\n		reset = not @selectionRectangleBounds? or @controlPath.rotation==0 and @controlPath.scaling.x == 1 and @controlPath.scaling.y == 1\n		if reset\n			@selectionRectangleBounds = @controlPath.bounds.clone()\n\n		# expand the selection rectangle to fit the entire drawing, and to avoid interference (overlapping) between control path and selection rectangle\n		bounds = @selectionRectangleBounds.clone().expand(10+@pathWidth()/2)\n		@selectionRectangle?.remove()\n\n		# create the selection rectangle: rectangle path + handle at the top used for rotations\n		@selectionRectangle = new Path.Rectangle(bounds)\n		@group.addChild(@selectionRectangle)\n		@selectionRectangle.name = \"selection rectangle\"\n		@selectionRectangle.pivot = @selectionRectangle.bounds.center\n		@selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top))\n		@selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top-25))\n		@selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top))\n		if not reset 				# restore transformations if not reset\n			@selectionRectangle.position = @controlPath.position\n			@selectionRectangle.rotation = @controlPath.rotation\n			@selectionRectangle.scaling = @controlPath.scaling\n		@selectionRectangle.selected = true\n		@selectionRectangle.controller = @\n		@controlPath.pivot = @selectionRectangle.pivot 	# set contol path pivot to the selection rectangle pivot, otherwise they are not the same because of the handle\n		return\n\n	# common to all RItems\n	# select the RPath: (only if it has a control path but no selection rectangle i.e. already selected)\n	# - create or update the selection rectangle, \n	# - create or update the global selection group (i.e. add this RPath to the grouop)\n	# - (optionally) update controller in the gui accordingly\n	# @param updateOptions [Boolean] whether to update controllers in gui or not\n	select: (updateOptions=true)->\n		if not @controlPath? then return\n		if @selectionRectangle? then return\n		console.log \"select\"\n\n		# create or update the selection rectangle\n		@selectionRectangleRotation = null\n		@selectionRectangleScale = null\n		@updateSelectionRectangle()\n\n		# create or update the global selection group (i.e. add this RPath to the grouop)\n		g.selectionGroup ?= new Group()\n		g.selectionGroup.name = 'selection group'\n		g.selectionGroup.addChild(@group)\n\n		# create or update the global selection group\n		if updateOptions then g.updateParameters( { tool: @constructor, item: @ } , true)\n		# debug:\n		g.s = @\n		return\n\n	# deselect: remove the selection rectangle (and rasterize)\n	deselect: ()->\n		console.log \"deselect\"\n		if not @selectionRectangle? then return\n		@selectionRectangle?.remove()\n		@selectionRectangle = null\n		@rasterize()\n		return\n\n	# called when user deselects, after a not simplified draw or once the user finished creating the path\n	# this is suppose to convert all the group to a raster to speed up paper.js operations, but it does not drastically improve speed, so it is just commented out\n	rasterize: ()->\n		# if @raster? or not @drawing? then return\n		# @raster = @drawing.rasterize()\n		# @group.addChild(@raster)\n		# @drawing.visible = false\n		return\n\n	# perform a hit test and initialize the selection\n	# called by @selectBegin()\n	# @param event [Paper event] the mouse event\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user \n	# @return [String] string describing how will the path change during the selection process. The string can be 'rotation', 'scale', 'segment', 'move' or null (if nothing must be changed)\n	# 				   *change* is also used as soon as something changes before the update (for example when a parameter is changed, it is set to the name of the parameter)\n	hitTestAndInitSelection: (event, userAction)->\n		hitResult = @performeHitTest(event.point, @constructor.hitOptions)\n		if not hitResult? then return null\n		return @initSelection(event, hitResult, userAction)\n\n	# intialize the selection: \n	# determine which action to perform depending on the the *hitResult* (move by default, edit point if segment from contorl path, etc.)\n	# set @selectedSegment, @selectionRectangleRotation or @selectionRectangleScale which will be used during the selection process (select begin, update, end)\n	# @param event [Paper event] the mouse event\n	# @param hitResult [Paper HitResult] [paper hit result](http://paperjs.org/reference/hitresult/) form the hit test\n	# @param userAction [Boolean] (optional) whether this is an action from *g.me* or another user \n	# redefined by {PrecisePath}, only used as is by {RShape}\n	# the transformation is not intialized the same way for PrecisePath and for RShape\n	# @return [String] string describing how will the path change during the selection process. The string can be 'rotation', 'scale', 'segment' or 'move';\n	# 				   *change* is also used as soon as something changes before the update (for example when a parameter is changed, it is set to the name of the parameter)\n	initSelection: (event, hitResult, userAction=true) ->\n		# @selectionRectangleRotation and @selectionRectangleScale store the position of the mouse relatively to the selection rectangle, \n		# they will be used for transformation in @selectUpdate() but they are not initialized in the same way for PrecisePath and RShape\n\n		change = 'move' 				# change is 'move' by default\n		if hitResult.type == 'segment' 						# if user hit a segment which belongs to the control path: this segment will be moved\n			if hitResult.item == @controlPath\n				@selectedSegment = hitResult.segment\n				change = 'segment'\n			else if hitResult.item == @selectionRectangle 	# if the segment belongs to the selection rectangle: initialize rotation or scaling\n				if hitResult.segment.index >= 2 and hitResult.segment.index <= 4\n					@selectionRectangleRotation = event.point.subtract(@selectionRectangle.bounds.center)\n					change = 'rotation'\n				else\n					@selectionRectangleScale = event.point.subtract(@selectionRectangle.bounds.center).length #/@controlPath.scaling.x\n					change = 'scale'\n		return change\n\n	# common to all RItems\n	# begin select action:\n	# - initialize selection (reset selection state)\n	# - select if *userAction*\n	# - hit test and initilize selection\n	# - hide other path if in fast mode\n	# @param event [Paper event] the mouse event\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user \n	# @return [String] string describing how will the path change during the selection process. The string can be 'rotation', 'scale', 'segment' or 'move';\n	# 				   *change* is also used as soon as something changes before the update (for example when a parameter is changed, it is set to the name of the parameter)\n	selectBegin: (event, userAction=true) ->\n		# if not userAction and @changed\n		# 	romanesco_alert(\"This path is already being modified.\", \"error\")\n		# 	return\n		console.log \"selectBegin\"\n		\n		# initialize selection (reset selection state)\n		@changed = null\n		if @selectedSegment? then @selectedSegment = null\n		if @selectedHandle? then @selectedHandle = null\n		@selectionHighlight?.remove()\n		@selectionHighlight = null\n		@selectionRectangleRotation = null\n		@selectionRectangleScale = null\n\n		if userAction\n			@select()\n\n		change = @hitTestAndInitSelection(event, userAction)\n		\n		if g.fastMode and change != 'move' # hide other path if in fast mode\n			g.hideOthers(@)\n\n		# if g.me? and userAction then g.chatSocket.emit( \"select begin\", g.me, @pk, g.eventToObject(event))\n\n		return change\n\n	# common to all RItems\n	# update select action\n	# to be redefined by children classes\n	# @param event [Paper event] the mouse event\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user \n	selectUpdate: (event, userAction=true)->\n		console.log \"selectUpdate\"\n		return\n\n	# common to all RItems\n	# end select action\n	# @param event [Paper event] the mouse event\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user \n	selectEnd: (event, userAction=true)->\n		console.log \"selectEnd\"\n		@selectionRectangleRotation = null\n		@selectionRectangleScale = null\n		if userAction and @changed?\n			@update('point')\n			# if g.me? and userAction then g.chatSocket.emit( \"select end\", g.me, @pk, g.eventToObject(event))\n		@changed = null\n\n		if g.fastMode\n			g.showAll(@)\n		return\n\n	# double click action\n	# to be redefined in children classes\n	# @param event [Paper event] the mouse event\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user \n	doubleClick: (event, userAction=true)->\n		return\n\n	# redraw the skeleton (controlPath) of the path, \n	# called only when loading a path\n	# redefined in PrecisePath, extended by shape (for security checks)\n	# @param points [Array of Point] (optional) the points of the controlPath\n	loadPath: (points)->\n		for point, i in points\n			if i==0\n				@createBegin(point, null, true)\n			else\n				@createUpdate(point, null, true)\n		if points.length>0\n			@createEnd(points.last(), null, true)\n		@draw()\n		return\n\n	# common to all RItems\n	# called when a parameter is changed:\n	# - from user action (parameter.onChange) (update = true)\n	# - from websocket (another user changed the parameter) (update = false)\n	# @param update [Boolean] (optional, default is true) whether to update the RPath in database\n	parameterChanged: (update=true)->\n		@draw()		# if draw in simple mode, then how to see the change of parameters which matter?\n		if update then g.defferedExecution(@update, @getPk())\n		return\n\n	# add a path to the drawing group:\n	# - create the path\n	# - initilize it (stroke width, and colors) with @data\n	# - add to the drawing group\n	# @param path [Paper path] (optional) the path to add to drawing, create an empty one if not provided\n	# @return [Paper path] the resulting path\n	addPath: (path)->\n		path ?= new Path()\n		path.name = 'group path'\n		path.controller = @\n		path.strokeColor = @data.strokeColor\n		path.strokeWidth = @data.strokeWidth\n		path.fillColor = @data.fillColor\n		@drawing.addChild(path)\n		return path\n\n	# initialize the drawing group before drawing:\n	# - create drawing group and initialize it with @data (add it to group)\n	# - optionally create a child canvas to draw on it (drawn in a raster, add it to group)\n	#   - this child canvas is used to speed up drawing operations (bypass paper.js drawing tools) when heavy drawing operations are required\n	#   - the advantage is speed, the drawback is that we loose the great benefits of paper.js (ease of use, export to SVG)\n	#   - the image drawn on the child canvas can not be exported in svg since it is not taken into account by paper.js\n	#   - if there is no control path yet (meaning the user did not even start drawing the RPath, mouse was just pressed)\n	#     - create the canvas at the size of the view\n	#     else\n	#     - create canvas to the dimensions of the control path\n	# @param createCanvas [Boolean] (optional, default to true) whether to create a child canavs *@canverRaster*\n	initializeDrawing: (createCanvas=false)->\n		\n		@raster?.remove()\n		@raster = null\n\n		@controlPath.strokeWidth = @pathWidth()\n\n		# create drawing group and initialize it with @data\n		@drawing?.remove()\n		@drawing = new Group()\n		@drawing.name = \"drawing\"\n		@drawing.strokeColor = @data.strokeColor\n		@drawing.strokeWidth = @data.strokeWidth\n		@drawing.fillColor = @data.fillColor\n		@drawing.insertBelow(@controlPath)\n		@drawing.controlPath = @controlPath\n		@drawing.controller = @\n		@group.addChild(@drawing)\n\n		# optionally create a child canvas to draw on it\n		if createCanvas\n			canvas = document.createElement(\"canvas\")\n\n			# if their is no control path yet (meaning the user did not even start drawing the RPath, mouse was just pressed)\n			if @controlPath.length<=1\n				# create the canvas at the size of the view\n				canvas.width = view.size.width\n				canvas.height = view.size.height\n				position = view.center\n			else\n				# create canvas to the dimensions of the control path\n				canvas.width = @controlPath.strokeBounds.width\n				canvas.height = @controlPath.strokeBounds.height\n				position = @controlPath.strokeBounds.center\n\n			@canvasRaster?.remove()\n			@canvasRaster = new Raster(canvas, position)\n			@group.addChild(@canvasRaster)\n			@context = @canvasRaster.canvas.getContext(\"2d\")\n			@context.strokeStyle = @data.strokeColor\n			@context.fillStyle = @data.fillColor\n			@context.lineWidth = @data.strokeWidth\n		return\n\n	# set animated: push/remove RPath to/from g.animatedItems\n	# @param animated [Boolean] whether to set the path as animated or not animated\n	setAnimated: (animated)->\n		if animated\n			@registerAnimation()\n		else\n			@deregisterAnimation()\n		return\n\n	# register animation: push RPath to g.animatedItems\n	registerAnimation: ()->\n		i = g.animatedItems.indexOf(@)\n		if i<0 then g.animatedItems.push(@)\n		return\n\n	# deregister animation: remove RPath from g.animatedItems\n	deregisterAnimation: ()->\n		i = g.animatedItems.indexOf(@)\n		if i>=0 then g.animatedItems.splice(i, 1)\n		return\n	\n	# update the appearance of the path (the drawing group)\n	# called anytime the path is modified:\n	# by createBegin/Update/End, selectUpdate/End, parameterChanged, deletePoint, changePoint etc. and loadPath\n	# must be redefined in children RPath\n	draw: ()->\n		return\n\n	# called once after createEnd to initialize the path (add it to a game, or to the animated paths)\n	# must be redefined in children RPath\n	initialize: ()->\n		return\n\n	# createBegin, createUpdate, createEnd\n	# called from loadPath (draw the skeleton when path is loaded), then *event* is null\n	# called from PathTool.begin, PathTool.update and PathTool.end (when the user draws something), then *event* is the Paper mouse event\n	# @param point [Point] point to peform the action\n	# @param event [Paper event of REvent] the mouse event\n	createBegin: (point, event) ->\n		return\n\n	# see createBegin\n	createUpdate: (point, event) ->\n		return\n\n	# see createBegin\n	createEnd: (point, event) ->\n		@initialize()\n		return\n\n	# update the z index (to be used in further version) i.e. move the path to the right position\n	# - RPath are kept sorted by z-index in *g.sortedPath*\n	# - z-index are initialize to the current date (this is a way to provide a global z index even with RPath which are not loaded)\n	# to be updated\n	updateZIndex: ()->\n		if @date?\n			#insert path at the right place\n			if g.sortedPaths.length==0\n				g.sortedPaths.push(@)\n			for path, i in g.sortedPaths\n				if @date > path.date\n					g.sortedPaths.splice(i+1, 0, @)\n					@insertAbove(path)\n		return\n\n	# insert above given *path*\n	# @param path [RPath] path on which to insert this\n	# to be updated\n	insertAbove: (path)->\n		@controlPath.insertAbove(path.controlPath)\n		@drawing.insertBelow(@controlPath)\n		return\n\n	# common to all RItems\n	# get data, usually to save the RPath (some information must be added to data)\n	getData: ()->\n		return @data\n	\n	# common to all RItems\n	# @return [String] the stringified data\n	getStringifiedData: ()->\n		return JSON.stringify(@getData())\n\n	# @return [Point] the planet on which the RPath lies\n	planet: ()->\n		return projectToPlanet( @controlPath.segments[0].point )\n\n	# check that the path does not lie between two planets before update\n	# @return [Boolean] whether we can update the RPath or not (is contained in one planet or not)\n	prepareUpdate: ()->\n		path = @controlPath\n\n		if path.segments.length<2 					# ~deprecated: if the user want to add a single point: make another point beside to make is GeoJson valid\n			p0 = path.segments[0].point\n			path.add( new Point(p0.x+1, p0.y) )\n\n		if g.pathOverlapsTwoPlanets(path)\n			romanesco_alert(\"You can not create nor update a line in between two planets, this is not yet supported.\", \"info\")\n			return false\n\n		return true\n\n	# save RPath to server\n	save: ()->\n		if not @controlPath? then return\n		if not @prepareUpdate() then return\n		# ajaxPost '/savePath', {'points': @pathOnPlanet(), 'pID': @id, 'planet': @planet(), 'object_type': @constructor.rname, 'data': @getStringifiedData() } , @save_callback\n		Dajaxice.draw.savePath( @save_callback, {'points': @pathOnPlanet(), 'pID': @id, 'planet': @planet(), 'object_type': @constructor.rname, 'data': @getStringifiedData() } )\n		return\n\n	# check if the save was successful and set @pk if it is\n	save_callback: (result)=>\n		g.checkError(result)\n		@setPK(result.pk)\n\n	# update the RPath in the database\n	# often called after the RPath has changed, in a *g.defferedExecution(@update)*\n	# @param type [String] type of change to consider (in further version, could send only the required information to the server to make the update to improve performances)\n	update: (type)=>\n		console.log \"update: \" + @pk\n		if not @pk? then return 	# null when was deleted (update could be called on selectEnd)\n		if not @prepareUpdate() then return\n\n		Dajaxice.draw.updatePath( @updatePath_callback, {'pk': @pk, 'points':@pathOnPlanet(), 'planet': @planet(), 'data': @getStringifiedData() } )\n		\n		# if type == 'points'\n		# 	# ajaxPost '/updatePath', {'pk': @pk, 'points':@pathOnPlanet(), 'planet': @planet(), 'data': @getStringifiedData() }, @updatePath_callback\n		# 	Dajaxice.draw.updatePath( @updatePath_callback, {'pk': @pk, 'points':@pathOnPlanet(), 'planet': @planet(), 'data': @getStringifiedData() } )\n		# else\n		# 	# ajaxPost '/updatePath', {'pk': @pk, 'data': @getStringifiedData() } , @updatePath_callback\n		# 	Dajaxice.draw.updatePath( @updatePath_callback, {'pk': @pk, 'data': @getStringifiedData() } )\n\n		@changed = null\n		return\n\n	# check if update was successful\n	updatePath_callback: (result)->\n		g.checkError(result)\n		return\n\n	# get the database primary key (@pk) or @id if it is not saved yet\n	# @return [ID] @pk or @id\n	getPk: ()->\n		return if @pk? then @pk else @id\n\n	# set @pk, update g.items and emit @pk to other users\n	# @param pk [ID] the new pk\n	# @param updateRoom [updateRoom] (optional) whether to emit @pk to other users in the room\n	setPK: (pk, updateRoom=true)->\n		@pk = pk\n		g.paths[pk] = @\n		g.items[pk] = @\n		delete g.paths[@id]\n		if updateRoom\n			g.chatSocket.emit( \"setPathPK\", g.me, @id, @pk)\n		return\n	\n	# common to all RItems\n	# called by @delete() and to update users view through websockets\n	# @delete() removes the path and delete it in the database\n	# @remove() just removes visually\n	remove: ()->\n		@deselect()\n		@deregisterAnimation()\n		@group.remove()\n		@controlPath = null\n		@drawing = null\n		@raster ?= null\n		@canvasRaster ?= null\n		@group = null\n		g.sortedPaths.remove(@)\n		if @pk?\n			delete g.paths[@pk]\n			delete g.items[@pk]\n		else\n			delete g.paths[@id]\n		return\n\n	# common to all RItems\n	# @delete() removes the path and delete it in the database\n	# @remove() just removes visually\n	delete: ()->\n		@remove()\n		if not @pk? then return\n		console.log @pk\n		# ajaxPost '/deletePath', { pk: @pk } , @deletePath_callback\n		Dajaxice.draw.deletePath(@deletePath_callback, { pk: @pk })\n		@pk = null\n		return\n\n	# check if delete was successful and emit \"delete path\" to other users if so\n	deletePath_callback: (result)->\n		if g.checkError(result)\n			g.chatSocket.emit( \"delete path\", result.pk )\n		return\n\n	# @param controlSegments [Array<Paper Segment>] the control path segments to convert in planet coordinates\n	# return [Array of Paper point] a list of point from the control path converted in the planet coordinate system\n	pathOnPlanet: (controlSegments=@controlPath.segments)->\n		points = []\n		planet = @planet()\n		for segment in controlSegments\n			p = projectToPosOnPlanet(segment.point, planet)\n			points.push( pointToArray(p) )\n		return points\n\n@RPath = RPath\n\n# PrecisePath extends RPath to add precise editing functionalities\n# PrecisePath adds control handles to the control path (which can be hidden): \n# one can edit, add or remove points, to precisely shape the curve.\n# The user can edit the curve with the 'Edit Curve' folder of the gui\n\n# Points of a PrecisePath can have three states:\n# - smooth (default): the handles of the point are always aligned, they are not necessarly of the same size (although they are equal if the user presses the shift key)\n# - corner: the handles of the point are independent, giving the possibility to make sharp corners\n# - point: the point has no handles, it is simple to manipulate\n\n# A precise path has two modes:\n# - the default mode: handles are editable\n# - the smooth mode: handles are not editable and the control path is [smoothed](http://paperjs.org/reference/path/#smooth)\n\n# A precise path has two creation modes:\n# - the default mode: a point is added to the control path when the user drags the mouse (at each drag event), resulting in many close points\n# - the polygon mode: a point is added to the control path when the user clicks the mouse, and the last handle is modified when the user drags the mouse\n\n# # The drawing\n\n# The drawing is performed as follows:\n# - the control path is divided into a number of steps of fixed size (giving points along the control path at regular intervals)\n# - the drawing is updated at each of those points\n# - to have better results, the remaining step (which is shorter) is split in half and distributed among the first and last step\n# - the size of the steps is data.step, and can be added in the gui\n# - during the drawing process, the *offset* property corresponds to the current position along the control path where the drawing must be updated \n#   (offset can be seen as the length of the drawing along the path)\n\n# For example the simplest precise path is as a set of points regularly distributed along the control path;\n# a more complexe precise path would also be function of the normal and the tangent of the control point at each point.\n\n# The drawing is performed with three methods:\n# - drawBegin() called to initialize the drawing,\n# - drawUpdate() called at each update,\n# - drawEnd() called at the end of the drawing.\n\n# There are two cases where precise path is created:\n# - when the user creates the path with the mouse:\n#     - each time a new point is added to the control path:\n#       drawUpdate() is called to continue the drawing along the control path until *offset* (the length of the drawing) equals the control path length (minus the remaining step)\n#       this process takes place in {PrecisePath#checkUpdateDrawing} (it is overridden by {SpeedPath#checkUpdateDrawing})\n#       it is part of the createBegin/Update/End() process\n# - when the path is loaded (or when the control path exists):\n#     - the remaining step (which is shorter) is split in half and distributed among the first and last step\n#     - drawUpdate() is called in a loop to draw the whole drawing along the control path at once, in {PrecisePath#draw}\n\nclass PrecisePath extends RPath\n	@rname = 'Precise path'\n	@rdescription = \"This path offers precise controls, one can modify points along with their handles and their type.\"\n	@iconUrl = 'static/images/icons/inverted/editCurve.png'\n	@iconAlt = 'edit curve'\n\n	@hitOptions =\n		segments: true\n		stroke: true\n		fill: true\n		selected: true\n		curves: true\n		handles: true\n		tolerance: 5\n\n	@secureStep = 25\n\n	@parameters: ()->\n\n		parameters = super()\n\n		parameters['General'].polygonMode =\n			type: 'checkbox'\n			label: 'Polygon mode'\n			default: g.polygonMode\n			onChange: (value)-> g.polygonMode = value\n\n		parameters['Edit curve'] =\n			smooth:\n				type: 'checkbox'\n				label: 'Smooth'\n				default: false\n			pointType:\n				type: 'dropdown'\n				label: 'Point type'\n				values: ['smooth', 'corner', 'point']\n				default: 'smooth'\n				addController: true\n				onChange: (value)-> item.changeSelectedPoint?(true, value) for item in g.selectedItems(); return\n			deletePoint: \n				type: 'button'\n				label: 'Delete point'\n				default: ()-> item.deleteSelectedPoint?() for item in g.selectedItems(); return\n			simplify: \n				type: 'button'\n				label: 'Simplify'\n				default: ()-> \n					for item in g.selectedItems()\n						item.controlPath?.simplify()\n						item.draw()\n						item.update()\n					return\n\n		return parameters\n\n	# overload {RPath#constructor}\n	constructor: (@date=null, @data=null, @pk=null, points=null) ->\n		super(@date, @data, @pk, points)\n		@data.polygonMode = g.polygonMode\n		return\n\n	# redefine {RPath#loadPath}\n	# load control path from @data.points and check if *points* fit to the created control path\n	loadPath: (points)->\n		# load control path from @data.points\n		@createBegin(posOnPlanetToProject(@data.points[0], @data.planet), null, true)\n		for point, i in @data.points by 4\n			if i>0 then @controlPath.add(posOnPlanetToProject(point, @data.planet))\n			@controlPath.lastSegment.handleIn = new Point(@data.points[i+1])\n			@controlPath.lastSegment.handleOut = new Point(@data.points[i+2])\n			@controlPath.lastSegment.rtype = @data.points[i+3]\n		if points.length == 2 then @controlPath.add(points[1])\n		@createEnd(posOnPlanetToProject(@data.points[@data.points.length-4], @data.planet), null, true)\n\n		time = Date.now()\n\n		# check if points fit to the newly created control path:\n		# - flatten a copy of the control path, as it was flattened when the path was saved\n		# - check if *points* correspond to the points on this flattened path\n		flattenedPath = @controlPath.copyTo(project)\n		flattenedPath.flatten(@constructor.secureStep)\n		distanceMax = @constructor.secureDistance*@constructor.secureDistance\n\n		# only check 10 random points to speed up security check\n		for i in [1 .. 10]\n			index = Math.floor(Math.random()*points.length)\n			recordedPoint = points[index]\n			resultingPoint = flattenedPath.segments[index].point\n			if recordedPoint.getDistance(resultingPoint, true)>distanceMax\n				# @remove()\n				flattenedPath.strokeColor = 'red'\n				view.center = flattenedPath.bounds.center\n				console.log \"Error: invalid path\"\n				return\n		\n		flattenedPath.remove()\n		console.log \"Time to secure the path: \" + ((Date.now()-time)/1000) + \" sec.\"\n		return\n\n	# redefine hit test to test not only on the selection rectangle, but also on the control path\n	# @param point [Point] the point to test\n	# @param hitOptions [Object] the [paper hit test options](http://paperjs.org/reference/item/#hittest-point)\n	hitTest: (point, hitOptions)->\n		if @speedGroup?.visible then hitResult = @handleGroup?.hitTest(point)\n		hitResult ?= @selectionRectangle.hitTest(point)\n		hitResult ?= @controlPath.hitTest(point, hitOptions)\n		return hitResult\n\n	# initialize drawing\n	# @param createCanvas [Boolean] (optional, default to true) whether to create a child canavs *@canverRaster*\n	initializeDrawing: (createCanvas=false)->\n		@data.step ?= 20 	# developers do not need to put @data.step in the parameters, but there must be a default value\n		@offset = 0\n		super(createCanvas)\n		return\n\n	# default drawBegin function, will be redefined by children PrecisePath\n	# @param createCanvas [Boolean] (optional, default to true) whether to create a child canavs *@canverRaster*\n	drawBegin: (createCanvas=false)->\n		console.log \"drawBegin\"\n		@initializeDrawing(createCanvas)\n		@path = @addPath()\n		@path.segments = @controlPath.segments\n		@path.selected = false\n		return\n\n	# default drawUpdate function, will be redefined by children PrecisePath\n	# @param offset [Number] the offset along the control path to begin drawing\n	drawUpdate: (offset)->\n		console.log \"drawUpdate\"\n		@path.segments = @controlPath.segments\n		@path.selected = false\n		return\n\n	# default drawEnd function, will be redefined by children PrecisePath\n	drawEnd: ()->\n		@path.segments = @controlPath.segments\n		@path.selected = false\n		return\n\n	# continue drawing the path along the control path if necessary:\n	# - the drawing is performed every *@data.step* along the control path\n	# - each time the user adds a point to the control path (either by moving the mouse in normal mode, or by clicking in polygon mode)\n	#   *checkUpdateDrawing* check by how long the control path was extended, and calls @drawUpdate() if some draw step must be performed\n	# called only when creating the path (not when we load it) (by createUpdate and finishPath)\n	# @param event [Event] the mouse event\n	checkUpdateDrawing: (event)->\n		step = @data.step\n		controlPathLength = @controlPath.length\n\n		while @offset+step<controlPathLength\n			@offset += step\n			@drawUpdate(@offset)\n		return\n\n	# initialize the main group and the control path\n	# @param point [Point] the first point of the path\n	initializeControlPath: (point)->\n		@group = new Group()\n		@group.name = \"group\"\n		@group.controller = @\n\n		@controlPath = new Path()\n		@group.addChild(@controlPath)\n		@controlPath.name = \"controlPath\"\n		@controlPath.controller = @\n		@controlPath.strokeWidth = @pathWidth()\n		@controlPath.strokeColor = 'black'\n		@controlPath.visible = false\n		@controlPath.add(point)\n\n		return\n\n	# redefine {RPath#createBegin}\n	# begin create action:\n	# initialize the control path and draw begin\n	# called when user press mouse down, or on loading\n	# @param point [Point] the point to add\n	# @param event [Event] the mouse event\n	# @param loading [Boolean] (optional) whether the path is being loaded or being created by user\n	createBegin: (point, event, loading=false)->\n		# todo: better handle lock area\n		super()\n		if loading\n			@initializeControlPath(point)\n		else\n			if RLock.intersectPoint(point) then	return\n\n			if not @data.polygonMode 				# in normal mode: just initialize the control path and begin drawing\n				@initializeControlPath(point)\n				@drawBegin()\n			else 									# in polygon mode:\n				if not @controlPath?					# if the user just started the creation (first point, on mouse down)\n					@initializeControlPath(point)		# 	initialize the control path, add the point and begin drawing\n					@controlPath.add(point)\n					@drawBegin()\n				else 									# if the user already added some points: just add the point to the control path\n					@controlPath.add(point)\n				@controlPath.lastSegment.rtype = 'point'\n		return\n\n	# redefine {RPath#createUpdate}\n	# update create action:\n	# in normal mode:\n	# - check if path is not in an RLock\n	# - add point\n	# - @checkUpdateDrawing(event) (i.e. continue the draw steps to fit the control path)\n	# in polygon mode:\n	# - update the [handleIn](http://paperjs.org/reference/segment/#handlein) and handleOut of the last segment\n	# - draw in simplified (quick) mode\n	# called on mouse drag\n	# @param point [Point] the point to add\n	# @param event [Event] the mouse event\n	# @param loading [Boolean] (optional and deprecated) whether the path is being loaded or being created by user\n	createUpdate: (point, event, loading=false)->\n\n		if not @data.polygonMode\n			\n			if @inLockedArea\n				return\n			if RLock.intersectPoint(point) 		# check if path is not in an RLock\n				@inLockedArea = true\n				@save()\n				return\n\n			@controlPath.add(point)\n\n			# loading is never true in this case, createUpdate is not called in @loadPath() (but @createBegin() and @createEnd() are called)\n			if not loading then @checkUpdateDrawing(event)\n		else\n			# update the [handleIn](http://paperjs.org/reference/segment/#handlein) and handleOut of the last segment\n			lastSegment = @controlPath.lastSegment\n			previousSegment = lastSegment.previous\n			previousSegment.rtype = 'smooth'\n			previousSegment.handleOut = point.subtract(previousSegment.point)\n			if lastSegment != @controlPath.firstSegment\n				previousSegment.handleIn = previousSegment.handleOut.multiply(-1)\n			lastSegment.handleIn = lastSegment.handleOut = null\n			lastSegment.point = point\n			@draw(true) 		# draw in simplified (quick) mode\n		return\n\n	# update create action: only used when in polygon mode\n	# move the last point of the control path to the mouse position and draw in simple/quick mode\n	# called on mouse move\n	# @param event [Event] the mouse event\n	createMove: (event)->\n		@controlPath.lastSegment.point = event.point\n		@draw(true)\n		return\n\n	# redefine {RPath#createEnd}\n	# end create action: \n	# - in polygon mode: just finish the path (@finiPath())\n	# - in normal mode: compute speed, simplify path and update speed (necessary for SpeedPath) and finish path\n	# @param point [Point] the point to add\n	# @param event [Event] the mouse event\n	# @param loading [Boolean] (optional) whether the path is being loaded or being created by user\n	createEnd: (point, event, loading=false)->\n		if @data.polygonMode \n			if loading then @finishPath(loading)\n		else\n			@inLockedArea = false\n			if not loading and @controlPath.segments.length>=2\n				if @speeds? then @computeSpeed()\n				@controlPath.simplify()\n				if @speeds? then @updateSpeed()\n			@finishPath(loading)\n		super()\n		return\n\n	# finish path creation:\n	# @param loading [Boolean] (optional) whether the path is being loaded or being created by user\n	finishPath: (loading=false)->\n		if @data.polygonMode and not loading\n			@controlPath.lastSegment.remove()\n			@controlPath.lastSegment.handleOut = null\n\n		if @controlPath.segments.length<2\n			@remove()\n			return\n\n		# todo: uncomment update z index:\n		# @updateZIndex()\n		if @data.smooth then @controlPath.smooth()\n		if not loading\n			@checkUpdateDrawing()\n			@drawEnd()\n			@offset = 0\n		@draw(false, loading) 	# enable to have the correct @canvasRaster size and to have the exact same result after a load or a change\n		@rasterize()\n		return\n\n	# in simplified mode, the path is drawn quickly, with less details\n	# all parameters which are critical in terms of drawing time are set to *parameter.simplified*\n	simplifiedModeOn: ()->\n		@previousData = {}\n		for folderName, folder of @constructor.parameters()\n			for name, parameter of folder\n				if parameter.simplified? and @data[name]?\n					@previousData[name] = @data[name]\n					@data[name] = parameter.simplified\n		return\n\n	# retrieve parameters values we had before drawing in simplified mode\n	simplifiedModeOff: ()->\n		for folderName, folder of @constructor.parameters()\n			for name, parameter of folder\n				if parameter.simplified? and @data[name]? and @previousData[name]?\n					@data[name] = @previousData[name]\n					delete @previousData[name]\n		return\n\n	# update the appearance of the path (the drawing group)\n	# called anytime the path is modified:\n	# by createBegin/Update/End, selectUpdate/End, parameterChanged, deletePoint, changePoint etc. and loadPath\n	# - begin drawing (@drawBegin())\n	# - update drawing (@drawUpdate()) every *step* along the control path\n	# - end drawing (@drawEnd())\n	# @param simplified [Boolean] whether to draw in simplified mode or not (much faster)\n	# @param loading [Boolean] whether the path is being loaded or drawn by a user\n	draw: (simplified=false, loading=false)->\n\n		if @controlPath.segments.length < 2 then return\n	\n		if simplified then @simplifiedModeOn()\n		\n		# initialize dawing along control path \n		# the control path is divided into n steps of fixed length, the last step will be smaller than others\n		# to have a better result, the last (shorter) step is split in half and set as the first and the last step\n		step = @data.step\n		controlPathLength = @controlPath.length\n		nf = controlPathLength/step\n		nIteration  = Math.floor(nf)\n		reminder = nf-nIteration\n		offset = reminder*step/2\n\n		try 	# catch errors to log them in the code editor console (if user is making a script)\n\n			@drawBegin()\n\n			# update drawing (@drawUpdate()) every *step* along the control path\n			# n=0\n			while offset<controlPathLength\n\n				@drawUpdate(offset)\n				offset += step\n\n				# if n%10==0 then g.updateLoadingBar(offset/controlPathLength)\n				# n++\n\n			@drawEnd()\n\n		catch error\n			console.error error\n			throw error\n\n		if simplified \n			@simplifiedModeOff()\n		else\n			@rasterize()\n\n		return\n\n	# @return [Array of Paper point] a list of point from the control path converted in the planet coordinate system \n	pathOnPlanet: ()->\n		flatennedPath = @controlPath.copyTo(project)\n		flatennedPath.flatten(@constructor.secureStep)\n		flatennedPath.remove()\n		return super(flatennedPath.segments)\n\n	# get data, usually to save the RPath (some information must be added to data) \n	# the control path is stored in @data.points and @data.planet\n	getData: ()->\n		@data.planet = projectToPlanet(@controlPath.segments[0].point)\n		@data.points = []\n		for segment in @controlPath.segments\n			@data.points.push(projectToPosOnPlanet(segment.point))\n			@data.points.push(g.pointToObj(segment.handleIn))\n			@data.points.push(g.pointToObj(segment.handleOut))\n			@data.points.push(segment.rtype)\n		return @data\n\n	# @see RPath.select\n	# - bring control path to front and select it\n	# - call RPath.select\n	# @param updateOptions [Boolean] whether to update gui parameters with this RPath or not\n	select: (updateOptions=true)->\n		if not @controlPath? then return\n		if @selectionRectangle? then return\n		@index = @controlPath.index\n		@controlPath.bringToFront()\n		@controlPath.selected = true\n		super(updateOptions)\n		if not @data.smooth then @controlPath.fullySelected = true\n		return\n\n	# @see RPath.deselect\n	# deselect control path, remove selection highlight (@see PrecisePath.highlightSelectedPoint) and call RPath.deselect\n	deselect: ()->\n		# g.project.activeLayer.insertChild(@index, @controlPath)\n		@controlPath.selected = false\n		@selectionHighlight?.remove()\n		@selectionHighlight = null\n		super()\n		return\n\n	# highlight selection path point:\n	# draw a shape behind the selected point to be able to move and modify it\n	# the shape is a circle if point is 'smooth', a square if point is a 'corner' and a triangle otherwise\n	highlightSelectedPoint: ()->\n		if not @controlPath.selected then return\n		@selectionHighlight?.remove()\n		@selectionHighlight = null\n		if not @selectedSegment? then return\n		point = @selectedSegment.point\n		@selectedSegment.rtype ?= 'smooth'\n		switch @selectedSegment.rtype\n			when 'smooth'\n				@selectionHighlight = new Path.Circle(point, 5)\n			when 'corner'\n				offset = new Point(5, 5)\n				@selectionHighlight = new Path.Rectangle(point.subtract(offset), point.add(offset))\n			when 'point'\n				@selectionHighlight = new Path.RegularPolygon(point, 3, 5)\n		@selectionHighlight.name = 'selection highlight'\n		@selectionHighlight.controller = @\n		@selectionHighlight.strokeColor = g.selectionBlue\n		@selectionHighlight.strokeWidth = 1\n		@group.addChild(@selectionHighlight)\n		if @parameterControllers?.pointType? then g.setControllerValue(@parameterControllers.pointType, null, @selectedSegment.rtype, @)\n		return\n\n	# redefine {RPath#initSelection}\n	# Same functionnalities as {RPath#initSelection} (determine which action to perform depending on the the *hitResult*) but:\n	# - adds handle selection initialization, and highlight selected points if any\n	# - properly initialize transformation (rotation and scale) for PrecisePath\n	initSelection: (event, hitResult, userAction=true) ->\n		specialKey = g.specialKey(event)\n\n		@selectedSegment = null\n		@selectedHandle = null\n		@selectionHighlight?.remove()\n		@selectionHighlight = null\n		change = 'move'\n\n		if hitResult.type == 'segment'\n\n			if specialKey\n				hitResult.segment.remove()\n				@changed = change = 'deleted point'\n			else\n				if hitResult.item == @controlPath\n					@selectedSegment = hitResult.segment\n					change = 'segment'\n				else if hitResult.item == @selectionRectangle\n					if hitResult.segment.index >= 2 and hitResult.segment.index <= 4\n						@selectionRectangleRotation = 0\n						change = 'rotation'\n					else\n						@selectionRectangleScale = event.point.subtract(@selectionRectangle.bounds.center).length/@controlPath.scaling.x\n						change = 'scale'\n\n		if not @data.smooth\n			if hitResult.type is \"handle-in\"\n				@selectedHandle = hitResult.segment.handleIn\n				@selectedSegment = hitResult.segment\n				change = 'handle-in'\n			else if hitResult.type is \"handle-out\"\n				@selectedHandle = hitResult.segment.handleOut\n				@selectedSegment = hitResult.segment\n				change = 'handle-out'\n\n		if userAction then @highlightSelectedPoint()\n\n		return change\n\n	# segment.rtype == null or 'smooth': handles are aligned, and have the same length if shit\n	# segment.rtype == 'corner': handles are not equal\n	# segment.rtype == 'point': no handles\n\n	# redefine {RPath#selectUpdate}\n	# depending on the selected item, selectUpdate will:\n	# - move the selected handle,\n	# - move the selected point,\n	# - rotate the group,\n	# - scale the group,\n	# - or move the group.\n	# the selection rectangle must be updated if the curve is changed\n	# @param event [Paper event] the mouse event\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user\n	selectUpdate: (event, userAction=true)->\n		console.log \"selectUpdate\"\n\n		if @selectedHandle? 									# move the selected handle\n\n			# when segment.rtype == 'smooth' or 'corner'\n\n			# @selectedHandle = @selectedHandle.add(event.delta) # does not work\n			@selectedHandle.x += event.delta.x\n			@selectedHandle.y += event.delta.y\n\n			if @selectedSegment.rtype == 'smooth' or not @selectedSegment.rtype?\n				if @selectedHandle == @selectedSegment.handleOut and not @selectedSegment.handleIn.isZero()\n					@selectedSegment.handleIn = if not event.modifiers.shift then @selectedSegment.handleOut.normalize().multiply(-@selectedSegment.handleIn.length) else @selectedSegment.handleOut.multiply(-1)\n				if @selectedHandle == @selectedSegment.handleIn and not @selectedSegment.handleOut.isZero()\n					@selectedSegment.handleOut = if not event.modifiers.shift then @selectedSegment.handleIn.normalize().multiply(-@selectedSegment.handleOut.length) else @selectedSegment.handleIn.multiply(-1)		\n			@updateSelectionRectangle()\n			@draw(true)\n			@changed = 'moved handle'\n		else if @selectedSegment?								# move the selected point\n			@selectedSegment.point.x += event.delta.x\n			@selectedSegment.point.y += event.delta.y\n			@updateSelectionRectangle()\n			@draw(true)\n			@changed = 'moved point'\n		else if @selectionRectangleRotation?					# rotate the group\n			# @selectionRectangleRotation is 0 if we initialized rotation, null otherwise. \n			# The angle will be determined with the angle between the vector (cursor -> selection rectangle center) and the x axis\n			rotation = event.point.subtract(@selectionRectangle.bounds.center).angle + 90\n			@controlPath.rotation = rotation\n			@selectionRectangle.rotation = rotation\n			@draw(true)\n			@changed = 'rotated'\n		else if @selectionRectangleScale?						# scale the group\n			# let *L* be the length between the mouse and the selection rectangle center \n			# @selectionRectangleScale = *L* / current scaling, @selectionRectangleScale is the *intial scale*\n			# the ratio between the current length *L* and the *initial scale* gives the new scaling\n			ratio = event.point.subtract(@selectionRectangle.bounds.center).length/@selectionRectangleScale\n			scaling = new Point(ratio, ratio)\n			@controlPath.scaling = scaling\n			@selectionRectangle.scaling = scaling\n			@draw(true)\n			@changed = 'scaled'\n		else													# move the group\n			@group.position.x += event.delta.x\n			@group.position.y += event.delta.y\n			@updateSelectionRectangle()\n			# to optimize the move, the position of @drawing is updated at the end\n			# @drawing.position.x += event.delta.x\n			# @drawing.position.y += event.delta.y\n			@changed = 'moved'\n		console.log @changed\n\n		# @updateSelectionRectangle()\n\n		# @drawing.selected = false\n\n		if userAction or @selectionRectangle? then @selectionHighlight?.position = @selectedSegment.point\n\n		# if g.me? and userAction then g.chatSocket.emit( \"select update\", g.me, @pk, g.eventToObject(event))\n		return\n\n\n	# overload {RPath#selectUpdate} \n	selectEnd: (event, userAction=true)->\n		console.log \"selectEnd\"\n		# @updateSelectionRectangle()\n		if userAction or @selectionRectangle? then @selectionHighlight?.position = @selectedSegment.point\n		\n		# @drawing.position = @controlPath.position\n		\n		@selectedHandle = null\n\n		if @data.smooth then @controlPath.smooth()\n		if @changed? and @changed != 'moved' then @draw() # to update the curve when user add or remove points\n		# @changed = null in super()\n		super(event, userAction)\n		return\n\n	# smooth the point of *segment*, i.e. align the handles with the tangent at this point\n	# @param segment [Paper Segment] the segment to smooth\n	# @param offset [Number] (optional) the location of the segment (default is segment.location.offset)\n	smoothPoint: (segment, offset)->\n		segment.rtype = 'smooth'\n		segment.linear = false\n		\n		offset ?= segment.location.offset\n		tangent = segment.path.getTangentAt(offset)\n		if segment.previous? then segment.handleIn = tangent.multiply(-0.25)\n		if segment.next? then segment.handleOut = tangent.multiply(+0.25)\n\n		# a second version of the smooth\n		# if segment.previous? and segment.next?\n		# 	delta = segment.next.point.subtract(segment.previous.point)\n		# 	deltaN = delta.normalize()\n		# 	previousToSegment = segment.point.subtract(segment.previous.point)\n		# 	h = 0.5*deltaN.dot(previousToSegment)/delta.length\n		# 	segment.handleIn = delta.multiply(-h)\n		# 	segment.handleOut = delta.multiply(0.5-h)\n		# else if segment.previous?\n		# 	previousToSegment = segment.point.subtract(segment.previous.point)\n		# 	segment.handleIn = previousToSegment.multiply(0.5)\n		# else if segment.next?\n		# 	nextToSegment = segment.point.subtract(segment.next.point)\n		# 	segment.handleOut = nextToSegment.multiply(-0.5)\n		return\n\n	# double click event handler: \n	# if we click on a point:\n	# - roll over the three point modes (a 'smooth' point will become 'corner', a 'corner' will become 'point', and a 'point' will be deleted)\n	# else if we clicked on the control path:\n	# - create a point at *event* position\n	# @param event [jQuery event] the mouse event\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user\n	doubleClick: (event, userAction=true)->\n		# warning: event is a jQuery event, not a paper event\n		\n		specialKey = g.specialKey(event)\n		\n		point = if userAction then view.viewToProject(new Point(event.pageX, event.pageY)) else event.point\n\n		hitResult = @performeHitTest(point, @constructor.hitOptions)\n\n		if not hitResult?\n			return\n\n		hitCurve = hitResult.type == 'stroke' or hitResult.type == 'curve'\n\n		if hitResult.type == 'segment' 											# if we click on a point: roll over the three point modes \n			segment = hitResult.segment\n			@selectedSegment = segment\n\n			switch segment.rtype\n				when 'smooth', null, undefined\n					segment.rtype = 'corner'\n				when 'corner'\n					segment.rtype = 'point'\n					segment.linear = true\n					@draw()\n				when 'point'\n					@deletePoint(segment)\n				else\n					console.log \"segment.rtype not known.\"\n\n		else if hitCurve and not specialKey  									# else if we clicked on the control path: create a point at *event* position\n			location = hitResult.location \n			segment = hitResult.item.insert(location.index + 1, point)\n			\n			if userAction and not @data.smooth then segment.selected = true\n			@selectedSegment = segment\n			\n			@smoothPoint(segment, location.offset)\n\n		if userAction then @highlightSelectedPoint()\n\n		if hitResult.type == 'segment' or (hitCurve and not specialKey)\n			if @data.smooth then @controlPath.smooth()\n			if userAction\n				@update('point')\n				# if g.me? and userAction then g.chatSocket.emit( \"double click\", g.me, @pk, g.eventToObject(event))\n		return\n\n	# delete the point of *segment* (from curve) and delete curve if there are no points anymore\n	# @param segment [Paper Segment] the segment to delete\n	deletePoint: (segment)->\n		if not segment then return\n		@selectedSegment = if segment.next? then segment.next else segment.previous\n		if @selectedSegment then @selectionHighlight.position = @selectedSegment.point\n		segment.remove()\n		if @controlPath.segments.length <= 1\n			@delete()\n			return\n		if @data.smooth then @controlPath.smooth()\n		@draw()\n		view.draw()\n		return\n\n	# delete the selected point (from curve) and delete curve if there are no points anymore\n	# emit the action to websocket\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user\n	deleteSelectedPoint: (userAction=true)->\n		@deletePoint(@selectedSegment)\n		if g.me? and userAction then g.chatSocket.emit( \"parameter change\", g.me, @pk, \"deleteSelectedPoint\", null, \"rFunction\")\n		return\n\n	# - set selected point mode to *value*: 'smooth', 'corner' or 'point'\n	# - update the selected point highlight \n	# - emit action to websocket\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user\n	# @param value [String] new mode of the point: can be 'smooth', 'corner' or 'point'\n	changeSelectedPoint: (userAction=true, value)->\n		if not @selectedSegment? then return\n		if @data.smooth then return\n		@selectedSegment.rtype = value\n		switch value\n			when 'corner'\n				if @selectedSegment.linear = true\n					@selectedSegment.linear = false\n					@selectedSegment.handleIn = @selectedSegment.previous.point.subtract(@selectedSegment.point).multiply(0.5)\n					@selectedSegment.handleOut = @selectedSegment.next.point.subtract(@selectedSegment.point).multiply(0.5)\n			when 'point'\n				@selectedSegment.linear = true\n			when 'smooth'\n				@smoothPoint(@selectedSegment)\n		@highlightSelectedPoint()\n		if g.me? and userAction then g.chatSocket.emit( \"parameter change\", g.me, @pk, \"changeSelectedPoint\", value, \"rFunction\")\n		return\n\n	# overload {RPath#parameterChanged}, but update the control path state if 'smooth' was changed\n	# called when a parameter is changed\n	parameterChanged: (update=true)->\n		switch @changed\n			when 'smooth'\n				# todo: add a warning when changing smooth?\n				if @data.smooth 		# todo: put this in @draw()? and remove this function? \n					@controlPath.smooth()\n					@controlPath.fullySelected = false\n					@controlPath.selected = true\n					segment.rtype = 'smooth' for segment in @controlPath.segments\n				else\n					@controlPath.fullySelected = true\n		super(update)\n\n	# overload {RPath#remove}, but in addition: remove the selected point highlight and the canvas raster\n	remove: ()->\n		@selectionHighlight?.remove()\n		@selectionHighlight = null\n		@canvasRaster?.remove()\n		@canvasRaster =  null\n		super()\n\n@PrecisePath = PrecisePath\n\n@pathClasses = []\n@pathClasses.push(@PrecisePath)\n\n# SpeedPath extends PrecisePath to add speed functionnalities: \n#  - the speed at which the user has drawn the path is stored and has influence on the drawing,\n#  - the speed values are displayed as normals of the path, and can be edited thanks to handles,\n#  - when the user drags a handle, it will also influence surrounding speed values depending on how far from the normal the user drags the handle (with a gaussian attenuation)\n#  - the speed path and handles are added to a speed group, which is added to the main group\n#  - the speed group can be shown or hidden through the folder 'Edit curve' in the gui\nclass SpeedPath extends PrecisePath\n	@rname = 'Speed path'\n	@rdescription = \"This path offers speed.\"\n	@iconUrl = null\n	@iconAlt = null\n\n	@speedMax = 200\n	@speedStep = 20\n	@secureStep = 25\n\n	@parameters: ()->\n\n		parameters = super()\n\n		parameters['Edit curve'].showSpeed = \n				type: 'checkbox'\n				label: 'Show speed'\n				value: true\n\n		return parameters\n\n	# overloads {PrecisePath#loadPath}\n	loadPath: (points)->\n		@data ?= {}\n		@speeds = @data.speeds or []\n		super(points)\n		return\n\n	# redefine {PrecisePath#checkUpdateDrawing} to update speed while drawing\n	checkUpdateDrawing: (event)->\n		step = @data.step\n		controlPathLength = @controlPath.length\n		\n		if event?\n			delta = event.delta.length\n			startOffset = controlPathLength-delta\n			lastSpeed = @speeds.last()\n\n		while @offset+step<controlPathLength\n			@offset += step\n\n			if event? 	# compute speed\n				f = ( delta-(@offset-startOffset) ) / delta\n				speed = lastSpeed * (1-f) + delta * f\n				@speeds.push(Math.min(speed, @constructor.speedMax))\n\n			# update drawing\n			@drawUpdate(@offset)\n		return\n\n	# todo: better handle lock area\n	# overload {PrecisePath#createBegin} and add speed initialization\n	createBegin: (point, event, loading=false)->\n		if not loading then @speeds = (if g.polygonMode then [0] else [@constructor.speedMax/3])\n		super(point, event, loading)\n		return\n\n	# overload {PrecisePath#createEnd} and add speed initialization\n	createEnd: (point, event, loading=false)->\n		if not @data.polygonMode and not loading then @speeds = []\n		super(point, event, loading)\n		return\n\n	# compute the speed (deduced from the space between each point of the control path)\n	# the speed values are sampeled on regular intervals along the control path (same machanism as the drawing points)\n	# the distance between each sample is defined in @constructor.speedStep\n	# an average speed must be computed at each sample\n	computeSpeed: ()->\n\n		# 1. create an array *distances* containing speed values at regular intervals over the control path + speed values at the control path points\n		# the speed values computed between the control path points are interpolated from the two closest points\n		# the speed values of the points are equal to the length of the segment (distance between current and previous point)\n		# this array will be converted to real speed values in a second step, i.e. all values in the regular intervals will be summed up/integrated\n\n		# initialize variables\n		step = @constructor.speedStep\n\n		distances = []\n		controlPathLength = @controlPath.length\n		currentOffset = step\n		segment = @controlPath.firstSegment\n		distance = segment.point.getDistance(segment.next.point)\n		distances.push({speed: distance, offset: 0})\n		previousDistance = 0\n\n		pointOffset = 0\n		previousPointOffset = 0\n		\n		# we have a line with oddly distributed points:  |------|-------|--||-|-----------|--------|  ('|' represents the points, the speed at those point corresponds to the distance of the previous segment)\n		# we want to add values on regular intervals:    I---I--|I---I--|I-||I|--I---I---I|--I---I-| ('I' have been added every three units, the corresponding speeds are interpolated)\n		# (the last interval is shorter than the others)\n		# in a second step, we will integrate the values on those regular intervals\n\n		for segment, i in @controlPath.segments 		# loop over control path points\n			if i==0 then continue\n\n			point = segment.point\n			previousDistance = distance\n			distance = point.getDistance(segment.previous.point)\n			previousPointOffset = pointOffset\n			pointOffset += distance\n\n			while pointOffset > currentOffset 							# while we can add more sample on this segment, add them (values are interpolation)\n				f = (currentOffset-previousPointOffset)/distance\n				interpolation = previousDistance * (1-f) + distance * f\n				distances.push({speed: interpolation, offset: currentOffset})\n				currentOffset += step\n			\n			distances.push({speed: distance, offset: pointOffset})\n\n		distances.push({speed: distance, offset: currentOffset}) 		# push last point\n\n		# 2. intergate the values of the regular intervals to obtain final speed values\n\n		@speeds = []\n		\n		nextOffset = step\n	\n		speed = distances.first().speed\n		previousSpeed = speed\n		@speeds.push(speed)\n		offset = 0\n		previousOffset = offset\n		currentAverageSpeed = 0\n		\n		for distance, i in distances\n			if i==0 then continue\n\n			previousSpeed = speed\n			speed = distance.speed\n\n			previousOffset = offset\n			offset = distance.offset\n\n			currentAverageSpeed += ((speed+previousSpeed)/2.0)*(offset-previousOffset)/step\n			\n			if offset==nextOffset\n				@speeds.push(Math.min(currentAverageSpeed, @constructor.speedMax)) \n				currentAverageSpeed = 0\n				nextOffset += step\n\n		return\n\n	# update the speed group (curve and handles to visualize and edit the speeds)\n	updateSpeed: ()->\n		@speedGroup?.visible = @data.showSpeed\n		\n		if not @speeds? or not @data.showSpeed then return\n\n		step = @constructor.speedStep\n		\n		# create the speed group if it does not exist (add it to the main group)\n		alreadyExists = @speedGroup?\n\n		if alreadyExists\n			@speedGroup.bringToFront()\n			speedCurve = @speedGroup.firstChild\n		else\n			@speedGroup = new Group()\n			@speedGroup.name = \"speed group\"\n			@speedGroup.strokeWidth = 1\n			@speedGroup.strokeColor = selectionBlue\n			@speedGroup.controller = @\n			@group.addChild(@speedGroup)\n\n			speedCurve = new Path()\n			speedCurve.name = \"speed curve\"\n			speedCurve.strokeWidth = 1\n			speedCurve.strokeColor = selectionBlue\n			speedCurve.controller = @\n			@speedGroup.addChild(speedCurve)\n\n			@handleGroup = new Group()\n			@handleGroup.name = \"speed handle group\"\n			@speedGroup.addChild(@handleGroup)\n			\n		speedHandles = @handleGroup.children\n\n		offset = 0\n		controlPathLength = @controlPath.length\n\n		while (@speeds.length-1)*step < controlPathLength\n			@speeds.push(@speeds.last())\n\n		i = 0\n\n		# for all speed values: draw or update the corresponding curve point and handle\n		for speed, i in @speeds\n\n			offset = if i>0 then i*step else 0.1\n			o = if offset<controlPathLength then offset else controlPathLength - 0.1\n			\n			point = @controlPath.getPointAt(o)\n			normalNormalized = @controlPath.getNormalAt(o).normalize()\n			normal = normalNormalized.multiply(@speeds[i])\n			handlePoint = point.add(normal)\n\n			if alreadyExists and i<speedCurve.segments.length		# if the speed point (curve, segment and handle) already exists, move it the to correct place\n\n				speedCurve.segments[i].point = handlePoint\n				speedHandles[i].position = handlePoint\n				speedHandles[i].rsegment.firstSegment.point = point\n				speedHandles[i].rsegment.lastSegment.point = handlePoint\n				speedHandles[i].rnormal = normalNormalized\n\n			else 											# else (if the speed point does not exist) create it\n				speedCurve.add(handlePoint)\n\n				s = new Path()\n				s.name = 'speed segment'\n				s.strokeWidth = 1\n				s.strokeColor = selectionBlue\n				s.add(point)\n				s.add(handlePoint)\n				s.controller = @\n				@speedGroup.addChild(s)\n\n				handle = new Path.Rectangle(handlePoint.subtract(2), 4)\n				handle.name = 'speed handle'\n				handle.strokeWidth = 1\n				handle.strokeColor = selectionBlue\n				handle.fillColor = 'white'\n				handle.rnormal = normalNormalized\n				handle.rindex = i\n				handle.rsegment = s\n				handle.controller = @\n				@handleGroup.addChild(handle)\n\n			if offset>controlPathLength\n				break\n\n		# remove speed curve point and handles which are not on the control path anymore (if the curve path has been shrinked)\n		if offset > controlPathLength and i+1 <= speedHandles.length-1\n			speedHandlesLengthM1 = speedHandles.length-1\n			for j in [i+1 .. speedHandlesLengthM1]\n				speedHandle = @handleGroup.lastChild\n				speedHandle.rsegment.remove()\n				speedHandle.remove()\n				speedCurve.lastSegment.remove()\n\n		return\n\n	# get the speed at *offset*\n	# @param offset [Number] the offset along the control path at which getting the speed\n	# @return [Number] the computed speed:\n	# - the value is interpolated from the two closest speed values\n	# - if speeds are not computed yet: return half of the max speed\n	speedAt: (offset)->\n		f = offset%@constructor.speedStep\n		i = (offset-f) / @constructor.speedStep\n		f /= @constructor.speedStep\n		if @speeds?\n			if i<@speeds.length-1\n				return @speeds[i]*(1-f)+@speeds[i+1]*f\n			else\n				return @speeds.last()\n		else\n			@constructor.speedMax/2\n\n	# overload {PrecisePath#draw} and add speed update when *loading* is false\n	draw: (simplified=false, loading=false)->\n		super(simplified, loading)\n		if not loading then @updateSpeed()\n		return\n\n	# overload {PrecisePath#getData} and adds the speeds in @data.speeds (unused speed values are not stored)\n	getData: ()->\n		data = jQuery.extend({}, super())\n		data.speeds = if @speeds? and @handleGroup? then @speeds.slice(0, @handleGroup.children.length+1) else @speeds\n		return data\n\n	# overload {PrecisePath#select}, update speeds and show speed group\n	select: (updateOptions=true)->\n		if @selectionRectangle? then return\n		super(updateOptions)\n		@updateSpeed()\n		if @data.showSpeed then @speedGroup?.visible = true\n\n	# overload {PrecisePath#deselect} and hide speed group\n	deselect: ()->\n		@speedGroup?.visible = false\n		super()\n\n	# overload {PrecisePath#initSelection} but add the possibility to select speed handles\n	initSelection: (event, hitResult, userAction=true) ->\n		@speedSelectionHighlight?.remove()\n		@speedSelectionHighlight = null\n\n		if hitResult.item.name == \"speed handle\"\n			@selectedSpeedHandle = hitResult.item\n			change = 'speed handle'\n			return change\n\n		return super(event, hitResult, userAction)\n\n	# overload {PrecisePath#selectUpdate} but add the possibility to modify speed handles\n	selectUpdate: (event, userAction=true)->\n		if not @selectedSpeedHandle?\n			super(event, userAction)\n		else\n			@speedSelectionHighlight?.remove()\n\n			speedMax = @constructor.speedMax\n			\n			# initialize a line between the mouse and the handle, orthogonal to the normal\n			# the length of this line determines how much influence the change will have over the neighbour handles\n			@speedSelectionHighlight = new Path() \n			@speedSelectionHighlight.name = 'speed selection highlight'\n			@speedSelectionHighlight.strokeWidth = 1\n			@speedSelectionHighlight.strokeColor = 'blue'\n			@group.addChild(@speedSelectionHighlight)\n\n			handle = @selectedSpeedHandle\n			handlePosition = handle.bounds.center\n\n			handleToPoint = event.point.subtract(handlePosition)\n			projection = handleToPoint.project(handle.rnormal)\n			projectionLength = projection.length\n\n			# compute the new speed value\n			sign = Math.sign(projection.x) == Math.sign(handle.rnormal.x) and Math.sign(projection.y) == Math.sign(handle.rnormal.y)\n			sign = if sign then 1 else -1\n			\n			@speeds[handle.rindex] += sign * projectionLength\n\n			if @speeds[handle.rindex] < 0\n				@speeds[handle.rindex] = 0\n			else if @speeds[handle.rindex] > speedMax\n				@speeds[handle.rindex] = speedMax\n\n			newHandleToPoint = event.point.subtract(handle.position.add(projection))\n			influenceFactor = newHandleToPoint.length/(@constructor.speedStep*3)\n			\n			# spread the influence of this new speed value\n			max = g.gaussian(0, influenceFactor, 0)\n			i = 1\n			influence = 1\n			while influence > 0.1 and i<20\n				influence = g.gaussian(0, influenceFactor, i)/max\n				\n				delta = projectionLength*influence\n\n				for n in [-1 .. 1] by 2\n					index = handle.rindex+n*i\n					if index >= 0 and index < @handleGroup.children.length\n						handlei = @handleGroup.children[index]		\n\n						@speeds[index] += sign * delta\n						if @speeds[index] < 0\n							@speeds[index] = 0\n						else if @speeds[index] > speedMax\n							@speeds[index] = speedMax\n				i++\n			\n			# create the line between the mouse and the handle, orthogonal to the normal\n			@speedSelectionHighlight.strokeColor.hue -= Math.min(240*(influenceFactor/10), 240)\n			@speedSelectionHighlight.add(handle.position.add(projection))\n			@speedSelectionHighlight.add(event.point)\n\n			@draw(true)\n\n			@changed = 'speed handle moved'\n\n			if userAction or @selectionRectangle? then @selectionHighlight?.position = @selectedSegment.point\n			# if g.me? and userAction then g.chatSocket.emit( \"select update\", g.me, @pk, g.eventToObject(event))\n		return\n\n	# overload {PrecisePath#selectEnd} and reset speed handles\n	selectEnd: (event, userAction=true)->\n		@selectedSpeedHandle = null\n		@speedSelectionHighlight?.remove()\n		@speedSelectionHighlight = null\n		super(event, userAction)\n\n	# overload {PrecisePath#remove} and remove speed group\n	remove: ()->\n		@speedGroup?.remove()\n		@speedGroup = null\n		super()\n\n@SpeedPath = SpeedPath\n\n# The thickness pass demonstrates a simple use of the speed path: it draws a stroke which is thick where the user draws quickly, and thin elsewhere\n# The stroke width can be changed with the speed handles at any time\nclass ThicknessPath extends SpeedPath\n	@rname = 'Thickness path'\n	@rdescription = \"The stroke width is function of the drawing speed: the faster the wider.\"\n	@iconUrl = 'static/images/icons/inverted/rollerBrush.png'\n	@iconAlt = 'roller brush'\n\n	# The thickness path adds two parameters in the options bar:\n	# step: a number which defines the size of the steps along the control path (@data.step is already defined in precise path, this will bind it to the options bar)\n	# trackWidth: a number to control the stroke width (factor of the speed)\n	@parameters: ()->\n		parameters = super()\n\n		# override the default parameters, we do not need a stroke width, a stroke color and a fill color\n		parameters['Style'].strokeWidth.default = 0 \n		parameters['Style'].strokeColor.defaultCheck = false\n		parameters['Style'].fillColor.defaultCheck = true\n\n		parameters['Parameters'] ?= {}\n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 30\n			max: 300\n			default: 20\n			simplified: 20\n			step: 1\n		parameters['Parameters'].trackWidth =\n			type: 'slider'\n			label: 'Track width'\n			min: 1\n			max: 10\n			default: 2\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n		@path = @addPath()\n		@path.add(@controlPath.firstSegment.point)\n		return\n\n	drawUpdate: (offset)->\n		# get point, normal and speed at current position\n		point = @controlPath.getPointAt(offset)\n		normal = @controlPath.getNormalAt(offset).normalize()\n\n		speed = @speedAt(offset)\n\n		# create two points at each side of the control path (separated by a length function of the speed)\n		delta = normal.multiply(speed*@data.trackWidth/2)\n		top = point.add(delta)\n		bottom = point.subtract(delta)\n\n		# add the two points at the beginning and the end of the path\n		@path.add(top)\n		@path.insert(0, bottom)\n		@path.smooth()\n\n		return\n\n	drawEnd: ()->\n		# add the last segment, close and smooth the path\n		@path.add(@controlPath.lastSegment.point)\n		@path.closed = true\n		@path.smooth()\n		@path.selected = false 		# @path would be selected because we added the last point of the control path which is selected\n		return\n\n@ThicknessPath = ThicknessPath\n@pathClasses.push(@ThicknessPath)\n\n# Meander makes use of both the tangent and the normal of the control path to draw a spiral at each step\n# Many different versions can be derived from this one (some inspiration can be found here: http://www.dreamstime.com/photos-images/meander-wave-ancient-greek-ornament.html )\nclass Meander extends PrecisePath\n	@rname = 'Meander'\n	@rdescription = 'As Karl Kerenyi pointed out, \"the meander is the figure of a labyrinth in linear form\". \\nA meander or meandros (Greek: ) is a decorative border constructed from a continuous line, shaped into a repeated motif.\\nSuch a design is also called the Greek fret or Greek key design, although these are modern designations.\\n(source: http://en.wikipedia.org/wiki/Meander_(art))'\n	@iconUrl = 'static/images/icons/inverted/squareSpiral.png'\n	@iconAlt = 'square spiral'\n\n	# The thickness path adds 3 parameters in the options bar:\n	# step: a number which defines the size of the steps along the control path (@data.step is already defined in precise path, this will bind it to the options bar)\n	# thickness: the thickness of the spirals\n	# rsmooth: whether the path is smoothed or not (not that @data.smooth is already used to define if one can edit the control path handles or if they are automatically set)\n	@parameters: ()->\n		parameters = super()\n		parameters['Parameters'] ?= {}\n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 10\n			max: 100\n			default: 20\n			simplified: 20\n			step: 1\n		parameters['Parameters'].thickness =\n			type: 'slider'\n			label: 'Thickness'\n			min: 1\n			max: 30\n			default: 5\n			step: 1\n		parameters['Parameters'].rsmooth =\n			type: 'checkbox'\n			label: 'Smooth'\n			default: false\n\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n		@line = @addPath()\n		@spiral = @addPath()\n		return\n\n	drawUpdate: (offset)->\n\n		point = @controlPath.getPointAt(offset)\n		normal = @controlPath.getNormalAt(offset).normalize()\n		tangent = normal.rotate(90)\n\n		@line.add(point)\n\n		@spiral.add(point.add(normal.multiply(@data.thickness)))\n\n# line spiral\n#	|	|				\n#	0   0---------------1		\n#	|					|\n#	|	9-----------8	|\n#	|	|			|	|\n#	|	|	4---5	|	|\n#	|	|	|	|	|	|\n#	|	|	|	6---7	|\n#	|	|	|			|\n#	|	|	3-----------2\n#	|	|				\n#	0   0---------------1						\n#	|					|	\n#	|	9-----------8	|	\n#	|	|			|	|\n#	|	|	4---5	|	|	\n#	|	|	|	|	|	|	\n#	|	|	|	6---7	|	\n#	|	|	|			|	\n#	|	|	3-----------2	\n#	|	|\n#	0   0---------------1					\n#	|					|	\n\n		p1 = point.add(normal.multiply(@data.step))\n		@spiral.add(p1)\n\n		p2 = p1.add(tangent.multiply(@data.step-@data.thickness))\n		@spiral.add(p2)\n\n		p3 = p2.add(normal.multiply( -(@data.step-2*@data.thickness) ))\n		@spiral.add(p3)\n\n		p4 = p3.add(tangent.multiply( -(@data.step-3*@data.thickness) ))\n		@spiral.add(p4)\n\n		p5 = p4.add(normal.multiply( @data.thickness ))\n		@spiral.add(p5)\n\n		p6 = p5.add(tangent.multiply( @data.step-4*@data.thickness ))\n		@spiral.add(p6)\n\n		p7 = p6.add(normal.multiply( @data.step-4*@data.thickness ))\n		@spiral.add(p7)\n\n		p8 = p7.add(tangent.multiply( -(@data.step-3*@data.thickness) ))\n		@spiral.add(p8)\n\n		p9 = p8.add(normal.multiply( -(@data.step-2*@data.thickness) ))\n		@spiral.add(p9)\n\n		return\n\n	drawEnd: ()->\n		if @data.rsmooth\n			@spiral.smooth()\n			@line.smooth()\n		return\n\n@Meander = Meander\n@pathClasses.push(@Meander)\n\n# The grid path is similar to the thickness path, but draws a grid along the path\nclass GridPath extends SpeedPath\n	@rname = 'Grid path'\n	@rdescription = \"Draws a grid along the path, the thickness of the grid being function of the speed of the drawing.\"\n\n	@parameters: ()->\n		parameters = super()\n\n		parameters['Parameters'] ?= {} \n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 5\n			max: 100\n			default: 20\n			simplified: 20\n			step: 1\n		parameters['Parameters'].minWidth =\n			type: 'slider'\n			label: 'Min width'\n			min: 1\n			max: 100\n			default: 5\n		parameters['Parameters'].maxWidth =\n			type: 'slider'\n			label: 'Max width'\n			min: 1\n			max: 250\n			default: 200\n		parameters['Parameters'].minSpeed =\n			type: 'slider'\n			label: 'Min speed'\n			min: 1\n			max: 250\n			default: 1\n		parameters['Parameters'].maxSpeed =\n			type: 'slider'\n			label: 'Max speed'\n			min: 1\n			max: 250\n			default: 200\n		parameters['Parameters'].nLines =\n			type: 'slider'\n			label: 'N lines'\n			min: 1\n			max: 5\n			default: 2\n			simplified: 2\n			step: 1\n		parameters['Parameters'].symmetric =\n			type: 'dropdown'\n			label: 'Symmetry'\n			values: ['symmetric', 'top', 'bottom']\n			default: 'symmetric'\n		parameters['Parameters'].speedForWidth =\n			type: 'checkbox'\n			label: 'Speed for width'\n			default: true\n		parameters['Parameters'].speedForLength =\n			type: 'checkbox'\n			label: 'Speed for length'\n			default: false\n		parameters['Parameters'].orthoLines =\n			type: 'checkbox'\n			label: 'Orthogonal lines'\n			default: true\n		parameters['Parameters'].lengthLines =\n			type: 'checkbox'\n			label: 'Length lines'\n			default: true\n\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n\n		if @data.lengthLines\n			# create the required number of paths, and add them to the 'lines' array\n			@lines = []\n			nLines = @data.nLines\n			if @data.symmetric == 'symmetric' then nLines *= 2\n			for i in [1 .. nLines]\n				@lines.push( @addPath() )\n\n		@lastOffset = 0\n\n		return\n\n	drawUpdate: (offset)->\n		console.log \"drawUpdate\"\n\n		speed = @speedAt(offset)\n\n		# add a point at 'offset'\n		addPoint = (offset, speed)=>\n			point = @controlPath.getPointAt(offset)\n			normal = @controlPath.getNormalAt(offset).normalize()\n\n			# set the width of the step\n			if @data.speedForWidth\n				width = @data.minWidth + (@data.maxWidth - @data.minWidth) * speed / @constructor.speedMax		# map the speed to [@data.minWidth, @data.maxWidth]\n			else\n				width = @data.minWidth\n\n			# add the tangent lines (parallel or following the path)\n			if @data.lengthLines\n				divisor = if @data.nLines>1 then @data.nLines-1 else 1\n				if @data.symmetric == 'symmetric'\n					for line, i in @lines by 2\n						@lines[i+0].add(point.add(normal.multiply(i*width*0.5/divisor)))\n						@lines[i+1].add(point.add(normal.multiply(-i*width*0.5/divisor)))\n				else\n					if @data.symmetric == 'top'\n						line.add(point.add(normal.multiply(i*width/divisor))) for line, i in @lines\n					else if @data.symmetric == 'bottom'\n						line.add(point.add(normal.multiply(-i*width/divisor))) for line, i in @lines\n\n			# add the orthogonal lines\n			if @data.orthoLines\n				path = @addPath()\n				delta = normal.multiply(width)\n				switch @data.symmetric\n					when 'symmetric'\n						path.add(point.add(delta))\n						path.add(point.subtract(delta))\n					when 'top'\n						path.add(point.add(delta))\n						path.add(point)\n					when 'bottom'\n						path.add(point.subtract(delta))\n						path.add(point)\n			return\n\n		# if @data.speedForLength: the drawing is not updated at each step, but the step length is function of the speed\n		if not @data.speedForLength\n			addPoint(offset, speed)\n		else 	# @data.speedForLength\n\n			# map 'speed' to the interval [@data.minSpeed, @data.maxSpeed]\n			speed = @data.minSpeed + (speed / @constructor.speedMax) * (@data.maxSpeed - @data.minSpeed)\n			\n			# check when we must update the path (if the current position if greater than the last position we updated + speed)\n			stepOffset = offset-@lastOffset\n\n			if stepOffset>speed\n				midOffset = (offset+@lastOffset)/2\n				addPoint(midOffset, speed)\n				@lastOffset = offset\n\n		return\n\n	drawEnd: ()->\n		return\n\n@GridPath = GridPath\n@pathClasses.push(@GridPath)\n\n# The geometric lines path draws a line between pair of points which are close enough\n# This means that hundreds of lines will be drawn at each update.\n# To improve drawing efficiency (and because we do not need any complexe editing functionnality for those lines), we use a child canvas for the drawing.\n# We must convert the points in canvas coordinates, draw with the @context of the canvas (and use the native html5 canvas drawing functions, unless we load an external library)\nclass GeometricLines extends PrecisePath\n	@rname = 'Geometric lines'\n	@rdescription = \"Draws a line between pair of points which are close enough.\"\n	@iconUrl = 'static/images/icons/inverted/links.png'\n	@iconAlt = 'links'\n\n	@parameters: ()->\n		parameters = super()\n		# override the default color function, since we get better results with a very transparent color\n		parameters['Style'].strokeColor.defaultFunction = ()-> return \"rgba(39, 158, 224, 0.21)\"\n		delete parameters['Style'].fillColor 	# remove the fill color, we do not need it\n\n		parameters['Parameters'] ?= {}\n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 5\n			max: 100\n			default: 11\n			simplified: 20\n			step: 1\n		parameters['Parameters'].distance = 	# the maximum distance between two linked points\n			type: 'slider'\n			label: 'Distance'\n			min: 5\n			max: 250\n			default: 150\n			simplified: 100\n\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(true)\n		@points = [] 							# will contain the points to check distances\n		return\n\n	drawUpdate: (offset)->\n\n		point = @controlPath.getPointAt(offset)\n		normal = @controlPath.getNormalAt(offset).normalize()\n\n		point = @projectToRaster(point) 		#  convert the points from project to canvas coordinates\n		@points.push(point)\n		\n		distMax = @data.distance*@data.distance\n\n		# for all points: check if current point is close enough\n		for pt in @points\n\n			if point.getDistance(pt, true) < distMax 	# if points are close enough: draw a line between them\n				@context.beginPath()\n				@context.moveTo(point.x,point.y)\n				@context.lineTo(pt.x,pt.y)\n				@context.stroke()\n		\n		return\n\n	drawEnd: ()->\n		return\n\n@GeometricLines = GeometricLines\n@pathClasses.push(@GeometricLines)\n\n# The shape path draw a rectangle or an ellipse along the control path\nclass ShapePath extends SpeedPath\n	@rname = 'Shape path'\n	@rdescription = \"Draws rectangles or ellipses along the path. The size of the shapes is function of the drawing speed.\"\n\n	@parameters: ()->\n		parameters = super()\n\n		parameters['Parameters'] ?= {}\n		parameters['Parameters'].step =\n			type: 'slider'\n			label: 'Step'\n			min: 5\n			max: 100\n			default: 20\n			simplified: 20\n			step: 1\n		parameters['Parameters'].ellipse =\n			type: 'checkbox'\n			label: 'Ellipse'\n			default: false\n		parameters['Parameters'].minWidth =\n			type: 'slider'\n			label: 'Min width'\n			min: 1\n			max: 250\n			default: 1\n		parameters['Parameters'].maxWidth =\n			type: 'slider'\n			label: 'Max width'\n			min: 1\n			max: 250\n			default: 200\n		parameters['Parameters'].speedForLength =\n			type: 'checkbox'\n			label: 'Speed for length'\n			default: false\n		parameters['Parameters'].minSpeed =\n			type: 'slider'\n			label: 'Min speed'\n			min: 1\n			max: 250\n			default: 1\n		parameters['Parameters'].maxSpeed =\n			type: 'slider'\n			label: 'Max speed'\n			min: 1\n			max: 250\n			default: 200\n\n		return parameters\n\n	drawBegin: ()->\n		@initializeDrawing(false)\n		@lastOffset = 0\n		return\n\n	drawUpdate: (offset)->\n		console.log \"drawUpdate\"\n\n		speed = @speedAt(offset)\n\n		# add a shape at 'offset'\n		addShape = (offset, height, speed)=>\n			point = @controlPath.getPointAt(offset)\n			normal = @controlPath.getNormalAt(offset)\n\n			width = @data.minWidth + (@data.maxWidth - @data.minWidth) * speed / @constructor.speedMax\n			rectangle = new Rectangle(point.subtract(new Point(width/2, height/2)), new Size(width, height))\n			if not @data.ellipse\n				shape = @addPath(new Path.Rectangle(rectangle))\n			else\n				shape = @addPath(new Path.Ellipse(rectangle))\n			shape.rotation = normal.angle\n			return\n\n		# if @data.speedForLength: the drawing is not updated at each step, but the step length is function of the speed\n		if not @data.speedForLength\n			addShape(offset, @data.step, speed)\n		else 	# @data.speedForLength\n\n			# map 'speed' to the interval [@data.minSpeed, @data.maxSpeed]\n			speed = @data.minSpeed + (speed / @constructor.speedMax) * (@data.maxSpeed - @data.minSpeed)\n			\n			# check when we must update the path (if the current position if greater than the last position we updated + speed)\n			stepOffset = offset-@lastOffset\n			if stepOffset>speed\n				midOffset = (offset+@lastOffset)/2\n				addShape(midOffset, stepOffset, speed)\n				@lastOffset = offset\n\n		return\n\n	drawEnd: ()->\n		return\n\n@ShapePath = ShapePath\n@pathClasses.push(@ShapePath)\n\n# An RShape is defined by a rectangle in which the drawing should be included\n# during the creation, the user draw the rectangle with the mouse\nclass RShape extends RPath\n	@Shape = paper.Path.Rectangle\n	@rname = 'Shape'\n	@rdescription = \"Base shape class\"\n	@squareByDefault = true 				# whether the shape will be square by default (user must press the shift key to make it rectangle) or not\n	@centerByDefault = false 				# whether the shape will be centered on the first point by default \n											# (user must press the special key - command on a mac, control otherwise - to use the first point as the first corner of the shape) or not\n\n	# todo: check that control path always fit to rectangle: this is necessary for the getBounds method\n\n	# redefine {RPath#loadPath}\n	# - load the shape rectangle from @data.rectangle\n	# - initialize the control path\n	# - draw\n	# - check that the points in the database correspond to the new control path\n	loadPath: (points)->\n		if not @data.rectangle? then console.log 'Error loading shape ' + @pk + ': invalid rectangle.'\n		@rectangle = if @data.rectangle? then new Rectangle(@data.rectangle.x, @data.rectangle.y, @data.rectangle.width, @data.rectangle.height) else new Rectangle()\n		@initializeControlPath(@rectangle.topLeft, @rectangle.bottomRight, false, false, true)\n		@draw()\n		@controlPath.rotation = @data.rotation\n		@initialize()\n		# Check shape validity\n		distanceMax = @constructor.secureDistance*@constructor.secureDistance\n		for point, i in points\n			@controlPath.segments[i].point == point\n			if @controlPath.segments[i].point.getDistance(point, true)>distanceMax\n				# @remove()\n				@controlPath.strokeColor = 'red'\n				view.center = @controlPath.bounds.center\n				console.log \"Error: invalid shape!\"\n				return\n\n	# overload {RPath#moveBy} + update rectangle position\n	moveBy: (delta)-> \n		@rectangle.center.x += delta.x\n		@rectangle.center.y += delta.y\n		super(delta)\n		return\n\n	# overload {RPath#moveTo} + update rectangle position\n	moveTo: (position)-> \n		@rectangle.center = position\n		super(position)\n		return\n\n	# redefine {RPath#updateSelectionRectangle}\n	# the selection rectangle is slightly different for a shape since it is never reset (rotation and scale are stored in database)\n	updateSelectionRectangle: ()->\n		bounds = @rectangle.clone().expand(10+@pathWidth()/2)\n		@selectionRectangle?.remove()\n		@selectionRectangle = new Path.Rectangle(bounds)\n		@group.addChild(@selectionRectangle)\n		@selectionRectangle.name = 'selection rectangle'\n		@selectionRectangle.pivot = @selectionRectangle.bounds.center\n		@selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top))\n		@selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top-25))\n		@selectionRectangle.insert(2, new Point(bounds.center.x, bounds.top))\n		@selectionRectangle.rotation = @data.rotation\n		@selectionRectangle.selected = true\n		@selectionRectangle.controller = @\n		@controlPath.pivot = @selectionRectangle.pivot\n		return\n\n	# redefine {RPath#selectUpdate}\n	# depending on the selected item, selectUpdate will:\n	# - rotate the group,\n	# - scale the group,\n	# - or move the group.\n	# the shape is redrawn when scaled or rotated\n	# @param event [Paper event] the mouse event\n	# @param userAction [Boolean] whether this is an action from *g.me* or another user\n	selectUpdate: (event, userAction=true)->\n		console.log \"selectUpdate\"\n		if @selectionRectangleRotation?\n			direction = event.point.subtract(@selectionRectangle.bounds.center)\n			delta = @selectionRectangleRotation.getDirectedAngle(direction)\n			@selectionRectangleRotation = direction\n			@data.rotation += delta\n			@selectionRectangle.rotation += delta\n			@raster?.rotation += delta\n			@changed = 'rotated'\n			@draw()\n		else if @selectionRectangleScale?\n			length = event.point.subtract(@selectionRectangle.bounds.center).length\n			delta = length/@selectionRectangleScale\n			@selectionRectangleScale = length\n			@rectangle = @rectangle.scale(delta)\n			@selectionRectangle.scale(delta)\n			@raster?.scale(delta)\n			@changed = 'scaled'\n			@draw()\n		else\n			@group.position.x += event.delta.x\n			@group.position.y += event.delta.y\n\n			# @controlPath.position.x += event.delta.x\n			# @controlPath.position.y += event.delta.y\n			# @raster?.position.x += event.delta.x\n			# @raster?.position.y += event.delta.y\n			@rectangle.x += event.delta.x\n			@rectangle.y += event.delta.y\n			# @selectionRectangle.position.x += event.delta.x\n			# @selectionRectangle.position.y += event.delta.y\n			@changed = 'moved'\n\n		# if g.me? and userAction then g.chatSocket.emit( \"select update\", g.me, @pk, g.eventToObject(event))\n		return\n\n	# overload {RPath.pathWidth}\n	pathWidth: ()->\n		return @data.strokeWidth\n\n	# draw the shape\n	# the drawing logic goes here\n	# this is the main method that developer will redefine\n	createShape: ()->\n		@shape = @addPath(new @constructor.Shape(@rectangle))\n		return\n\n	# redefine {RPath#draw}\n	# initialize the drawing and draw the shape\n	draw: ()->\n		try 							# catch errors to log them in console (if the user has code editor open)\n			@initializeDrawing()\n			@createShape()\n			@drawing.rotation = @data.rotation\n			@rasterize()\n		catch error\n			console.error error\n			throw error\n		return\n\n	# initialize the control path\n	# create the rectangle from the two points and create the control path\n	# @param pointA [Paper point] the top left or bottom right corner of the rectangle\n	# @param pointB [Paper point] the top left or bottom right corner of the rectangle (opposite of point A)\n	# @param shift [Boolean] whether shift is pressed\n	# @param specialKey [Boolean] whether the special key is pressed (command on a mac, control otherwise)\n	# @param load [Boolean] whether the shape is being loaded\n	initializeControlPath: (pointA, pointB, shift, specialKey, load)->\n		@group = new Group()\n		@group.name = \"group\"\n		@group.controller = @\n\n		# create the rectangle from the two points\n		if load\n			@rectangle = new Rectangle(pointA, pointB)\n		else\n			square = if @constructor.squareByDefault then (not shift) else shift\n			createFromCenter = if @constructor.centerByDefault then (not specialKey) else specialKey\n			\n			if createFromCenter\n				delta = pointB.subtract(pointA)\n				@rectangle = new Rectangle(pointA.subtract(delta), pointB)\n				# @rectangle = new Rectangle(pointA.subtract(delta), new Size(delta.multiply(2)))\n				if square\n					center = @rectangle.center\n					if @rectangle.width>@rectangle.height\n						@rectangle.width = @rectangle.height\n					else\n						@rectangle.height = @rectangle.width\n					@rectangle.center = center\n			else\n				if not square\n					@rectangle = new Rectangle(pointA, pointB)\n				else\n					width = pointA.x-pointB.x\n					height = pointA.y-pointB.y\n					min = Math.min(Math.abs(width), Math.abs(height))\n					@rectangle = new Rectangle(pointA, pointA.subtract(g.sign(width)*min, g.sign(height)*min))\n		\n		# create the control path\n		@controlPath?.remove()\n		@controlPath = new Path.Rectangle(@rectangle)\n		@group.addChild(@controlPath)\n		@controlPath.name = \"controlPath\"\n		@controlPath.controller = @\n		@controlPath.strokeWidth = @pathWidth()\n		@controlPath.strokeColor = 'black'\n		@controlPath.visible = false\n		@data.rotation ?= 0\n		return\n\n	# overload {RPath#createBegin} + initialize the control path and draw\n	createBegin: (point, event, loading) ->\n		super()\n		@downPoint = point\n		@initializeControlPath(@downPoint, point, event?.modifiers?.shift, g.specialKey(event))\n		if not loading then @draw()\n		return\n\n	# redefine {RPath#createUpdate}: \n	# initialize the control path and draw\n	createUpdate: (point, event, loading) ->\n		console.log \" event.modifiers.command\"\n		console.log event.modifiers.command\n		console.log g.specialKey(event)\n		console.log event?.modifiers?.shift\n		@initializeControlPath(@downPoint, point, event?.modifiers?.shift, g.specialKey(event))\n		if not loading then @draw()\n		return\n\n	# overload {RPath#createEnd} + initialize the control path and draw\n	createEnd: (point, event, loading) ->\n		@initializeControlPath(@downPoint, point, event?.modifiers?.shift, g.specialKey(event))\n		@draw()\n		super()\n		return\n\n	# overload {RPath#getData} and add rectangle to @data\n	getData: ()->\n		data = jQuery.extend({}, @data)\n		data.rectangle = { x: @rectangle.x, y: @rectangle.y, width: @rectangle.width, height: @rectangle.height }\n		return data\n\n@RShape = RShape\n\n# Simple rectangle shape\nclass RectangleShape extends RShape\n	@Shape = paper.Path.Rectangle\n	@rname = 'Rectangle'\n	@rdescription = \"Simple rectangle, square by default (use shift key to draw a rectangle) which can have rounded corners.\\nUse special key (command on a mac, control otherwise) to center the shape on the first point.\"\n	@iconUrl = 'static/images/icons/inverted/rectangle.png'\n	@iconAlt = 'rectangle'\n\n	@parameters: ()->\n		parameters = super()\n		parameters['Style'] ?= {} \n		parameters['Style'].cornerRadius =\n			type: 'slider'\n			label: 'Corner radius'\n			min: 0\n			max: 100\n			default: 0\n		return parameters\n\n	createShape: ()->\n		@shape = @addPath(new @constructor.Shape(@rectangle, @data.cornerRadius)) 			# @constructor.Shape is a Path.Rectangle\n		return\n\n@RectangleShape = RectangleShape\n@pathClasses.push(@RectangleShape)\n\n# The ellipse path does not even override any function, the RShape.createShape draws the shape defined in @constructor.Shape by default\nclass EllipseShape extends RShape\n	@Shape = paper.Path.Ellipse 			# the shape to draw\n	@rname = 'Ellipse'\n	@rdescription = \"Simple ellipse, circle by default (use shift key to draw an ellipse).\\nUse special key (command on a mac, control otherwise) to avoid the shape to be centered on the first point.\"\n\n	@iconUrl = 'static/images/icons/inverted/circle.png'\n	@iconAlt = 'circle'\n	@squareByDefault = true\n	@centerByDefault = true\n\n@EllipseShape = EllipseShape\n@pathClasses.push(@EllipseShape)\n\n# The star shape can be animated\nclass StarShape extends RShape\n	@Shape = paper.Path.Star\n	@rname = 'Star'\n	@rdescription = \"Draws a star which can be animated (the color changes and it rotates).\"\n	@iconUrl = 'static/images/icons/inverted/star.png'\n	@iconAlt = 'star'\n\n	@parameters: ()->\n		parameters = super()\n		parameters['Style'] ?= {} \n		parameters['Style'].nPoints =\n			type: 'slider'\n			label: 'N points'\n			min: 1\n			max: 100\n			default: 5\n			step: 2\n		parameters['Style'].internalRadius =\n			type: 'slider'\n			label: 'Internal radius'\n			min: -200\n			max: 100\n			default: 37\n		parameters['Style'].rsmooth =\n			type: 'checkbox'\n			label: 'Smooth'\n			default: false\n		parameters['Style'].animate =\n			type: 'checkbox'\n			label: 'Animate'\n			default: false\n		return parameters\n\n	# animted paths must be initialized\n	initialize: ()->\n		@setAnimated(@data.animate)\n		return\n\n	createShape: ()->\n		rectangle = @rectangle\n		# make sure that the shape does not exceed the area defined by @rectangle\n		if @data.internalRadius>-100\n			externalRadius = rectangle.width/2\n			internalRadius = externalRadius*@data.internalRadius/100\n		else\n			internalRadius = rectangle.width/2\n			externalRadius = internalRadius*100/@data.internalRadius\n		# draw the star\n		@shape = @addPath(new @constructor.Shape(rectangle.center, @data.nPoints, externalRadius, internalRadius))\n		# optionally smooth it\n		if @data.rsmooth then @shape.smooth()\n		return\n\n	# called at each frame event\n	# this is the place where animated paths should be updated\n	onFrame: (event)=>\n		# very simple example of path animation\n		@shape.strokeColor.hue += 1\n		@shape.rotation += 1\n		return\n\n@StarShape = StarShape\n@pathClasses.push(@StarShape)\n\n# The spiral shape can have an intern radius, and a custom number of sides\n# A smooth spiral could be drawn with less points and with handles, that could be more efficient\nclass SpiralShape extends RShape\n	@Shape = paper.Path.Ellipse\n	@rname = 'Spiral'\n	@rdescription = \"The spiral shape can have an intern radius, and a custom number of sides.\"\n	@iconUrl = 'static/images/icons/inverted/spiral.png'\n	@iconAlt = 'spiral'\n\n	@parameters: ()->\n		parameters = super()\n\n		parameters['Parameters'] ?= {} \n		parameters['Parameters'].minRadius =\n			type: 'slider'\n			label: 'Minimum radius'\n			min: 0\n			max: 100\n			default: 0\n		parameters['Parameters'].nTurns =\n			type: 'slider'\n			label: 'Number of turns'\n			min: 1 \n			max: 50\n			default: 10\n		parameters['Parameters'].nSides =\n			type: 'slider'\n			label: 'Sides'\n			min: 3\n			max: 100\n			default: 50\n		parameters['Parameters'].animate =\n			type: 'checkbox'\n			label: 'Animate'\n			default: false\n		parameters['Parameters'].rotationSpeed =\n			type: 'slider'\n			label: 'Rotation speed'\n			min: -10\n			max: 10\n			default: 1\n\n		return parameters\n\n	# animted paths must be initialized\n	initialize: ()->\n		@setAnimated(@data.animate)\n		return\n\n	createShape: ()->\n		@shape = @addPath()\n\n		# drawing a spiral (as a set of straight lines) is like drawing a circle, but changing the radius of the circle at each step\n		# to draw a circle, we would do somehting like this: for each point: addPoint( radius*Math.cos(angle), radius*Math.sin(angle) )\n		# the same things applies for a spiral, except that radius decreases at each step\n		# ellipses are similar except the radius is different on the x axis and on the y axis\n\n		rectangle = @rectangle\n		hw = rectangle.width/2\n		hh = rectangle.height/2\n		c = rectangle.center\n		angle = 0\n\n		angleStep = 360.0/@data.nSides\n		spiralWidth = hw-hw*@data.minRadius/100.0\n		spiralHeight = hh-hh*@data.minRadius/100.0\n		radiusStepX = (spiralWidth / @data.nTurns) / @data.nSides 		# the amount by which decreasing the x radius at each step\n		radiusStepY = (spiralHeight / @data.nTurns) / @data.nSides 		# the amount by which decreasing the y radius at each step\n		for i in [0..@data.nTurns-1]\n			for step in [0..@data.nSides-1]\n				@shape.add(new Point(c.x+hw*Math.cos(angle), c.y+hh*Math.sin(angle)))\n				angle += (2.0*Math.PI*angleStep/360.0)\n				hw -= radiusStepX\n				hh -= radiusStepY\n		@shape.add(new Point(c.x+hw*Math.cos(angle), c.y+hh*Math.sin(angle)))\n		@shape.pivot = @rectangle.center\n		return\n\n	# called at each frame event\n	# this is the place where animated paths should be updated\n	onFrame: (event)=>\n		# very simple example of path animation\n		@shape.strokeColor.hue += 1\n		@shape.rotation += @data.rotationSpeed\n		return\n\n@SpiralShape = SpiralShape\n@pathClasses.push(@SpiralShape)\n\nclass FaceShape extends RShape\n	@Shape = paper.Path.Rectangle\n	@rname = 'Face generator'\n	# @iconUrl = 'static/images/icons/inverted/spiral.png'\n	# @iconAlt = 'spiral'\n	@rdescription = \"Face generator, inspired by weird faces study by Matthias Drfelt aka mokafolio.\"\n\n	@parameters: ()->\n		parameters = super()\n\n		parameters['Parameters'] ?= {} \n		parameters['Parameters'].minRadius =\n			type: 'slider'\n			label: 'Minimum radius'\n			min: 0\n			max: 100\n			default: 0\n		parameters['Parameters'].nTurns =\n			type: 'slider'\n			label: 'Number of turns'\n			min: 1 \n			max: 50\n			default: 10\n		parameters['Parameters'].nSides =\n			type: 'slider'\n			label: 'Sides'\n			min: 3\n			max: 100\n			default: 50\n\n		return parameters\n\n	createShape: ()->\n		@headShape = @addPath(new Path.Ellipse(@rectangle.expand(-20,-10)))\n		\n		@headShape.flatten(50)\n		for segment in @headShape.segments\n			segment.point.x += Math.random()*20\n			segment.point.y += Math.random()*5\n			segment.handleIn += Math.random()*5\n			segment.handleOut += Math.random()*5\n		\n		@headShape.smooth()\n		\n		nozeShape = Math.random()\n		\n		center = @rectangle.center\n		width = @rectangle.width\n		height = @rectangle.height\n		\n		rangeRandMM = (min, max)->\n			return min + (max-min)*Math.random()\n		\n		rangeRandC = (center, amplitude)->\n			return center + amplitude*(Math.random()-0.5)\n		\n		# noze\n		if nozeShape < 0.333	# two nostrils\n			deltaX = 0.1*width + Math.random()*10\n			x = center.x - deltaX\n			y = center.y + rangeRandC(0, 5)\n			position = center.add(x, y)\n			size = new Size(Math.random()*5, Math.random()*5)\n			nozeLeft = @addPath(new Path.Ellipse(position, size))\n			position += 2*deltaX\n			size = new Size(Math.random()*5, Math.random()*5)\n			nozeRight = @addPath(new Path.Ellipse(position, size))\n		else if nozeShape < 0.666 	# noze toward left\n			noze = @addPath()\n			noze.add(center)\n			noze.add(center.add(Math.random()*15, Math.random()*5))\n			noze.add(center.add(0, rangeRandMM(5,10)))\n			noze.smooth()\n		else				 	# noze toward right\n			noze = @addPath()\n			noze.add(center)\n			noze.add(center.add(-Math.random()*15, Math.random()*5))\n			noze.add(center.add(0, rangeRandMM(15,20)))\n			noze.smooth()\n		\n		# eyes\n		deltaX = rangeRandC(0, 0.1*width)\n		x = center.x - deltaX\n		y = @rectangle.top + width/3 + rangeRandC(0, 10)\n		position = new Point(x, y)\n		size = new Size(Math.max(Math.random()*30,deltaX), Math.random()*30)\n		eyeLeft = @addPath(new Path.Ellipse(position, size))\n		position.x += 2*deltaX\n		\n		eyeRight = @addPath(new Path.Ellipse(position, size))\n		\n		eyeRight.position.x += rangeRandC(0, 5)\n		eyeLeft.position.x += rangeRandC(0, 5)\n		\n		for i in [1 .. eyeLeft.segments.length-1]\n			eyeLeft.segments[i].point.x += Math.random()*3\n			eyeLeft.segments[i].point.y += Math.random()*3	\n			eyeRight.segments[i].point.x += Math.random()*3\n			eyeRight.segments[i].point.y += Math.random()*3	\n		return\n\n\n@FaceShape = FaceShape\n@pathClasses.push(@FaceShape)\n\n# class QuantificationPath extends PrecisePath\n#   @rname = 'Quantification path'\n#   @rdescription = \"Quantification path.\"\n\n#   @parameters: ()->\n#     parameters = super()\n    \n#     parameters['Parameters'] ?= {} \n#     parameters['Parameters'].quantification =\n#         type: 'slider'\n#         label: 'Quantification'\n#         min: 0\n#         max: 100\n#         default: 10\n    \n#     return parameters\n\n#   constructor: (@date=null, @data=null, @pk=null, points=null) ->\n#     super(@date, @data, @pk, points)\n\n#   drawBegin: ()->\n\n#     @initializeDrawing(false)\n\n#     @path = @addPath()\n#     return\n\n#   drawUpdate: (length)->\n\n#     point = @controlPath.getPointAt(length)\n#     quantification = @data.quantification\n#     point.x = Math.floor(point.x/quantification)*quantification\n#     point.y = Math.floor(point.y/quantification)*quantification\n#     @path.add(point)\n#     return\n\n#   drawEnd: ()->\n#     return\n\n# @QuantificationPath = QuantificationPath\n\n\n\n\n# class Brush extends PrecisePath\n# 	@rname = 'New path'\n# 	@rdescription = \"New tool description.\"\n\n# 	@parameters: ()->\n# 		parameters = super()\n# 		###\n# 		parameters['Parameters'] ?= {} \n# 		parameters['Parameters'].width =\n# 			type: 'slider'\n# 			label: 'Width'\n# 			min: 2\n# 			max: 100\n# 			default: 10\n# 		###\n# 		return parameters\n\n# 	drawBegin: ()->\n# 		@initializeDrawing(true)\n		\n# 		width = @data.strokeWidth\n		\n# 		canvas = document.createElement(\"canvas\")\n# 		context = canvas.getContext('2d')\n# 		gradient = context.createRadialGradient(width/2, width/2, 0, width/2, width/2, width/2)\n# 		gradient.addColorStop(0, '#8ED6FF')\n# 		gradient.addColorStop(1, '#004CB3')\n# 		context.fillStyle = gradient\n# 		context.fill()\n# 		@gradientData = context.getImageData(0, 0, width, width)\n# 		return\n\n# 	drawUpdate: (length)->\n# 		point = @controlPath.getPointAt(length)\n# 		point = @projectToRaster(point)\n# 		width = @data.strokeWidth\n# 		@context.putImageData(@gradientData, point.x-width/2, point.y-width/2)\n# 		return\n\n# 	drawEnd: ()->\n# 		return\n\n# Checkpoint is a video game element:\n# if placed on a video game area, it will be registered in it\nclass Checkpoint extends RShape\n	@Shape = paper.Path.Rectangle\n	@rname = 'Checkpoint'\n	@rdescription = \"Draw checkpoints on a video game area to create a race (the players must go through each checkpoint as fast as possible, with the car tool).\"\n	@squareByDefault = false\n	\n	@parameters: ()->\n		return {} 		# we do not need any parameter\n\n	# register the checkpoint if we are on a video game\n	initialize: ()->\n		@game = g.gameAt(@rectangle.center)\n		if @game?\n			if @game.checkpoints.indexOf(@)<0 then @game.checkpoints.push(@)\n			@data.checkpointNumber ?= @game.checkpoints.indexOf(@)\n		return\n\n	# just draw a red rectangle with the text 'Checkpoint N' N being the number of the checkpoint in the videogame\n	# we could also prevent users to draw outside a video game\n	createShape: ()->\n		@data.strokeColor = 'rgb(150,30,30)'\n		@data.fillColor = null\n		@shape = @addPath(new Path.Rectangle(@rectangle))\n		@text = @addPath(new PointText(@rectangle.center.add(0,4)))\n		@text.content = if @data.checkpointNumber? then 'Checkpoint ' + @data.checkpointNumber else 'Checkpoint'\n		@text.justification = 'center'\n		return\n\n	# checks if the checkpoints contains the point, used by the video game to test collisions between the car and the checkpoint\n	contains: (point)->\n		delta = point.subtract(@rectangle.center)\n		delta.rotation = -@data.rotation\n		return @rectangle.contains(@rectangle.center.add(delta))\n\n	# we must unregister the checkpoint before removing it\n	remove: ()->\n		@game?.checkpoints.remove(@)\n		super()\n		return\n\n@Checkpoint = Checkpoint\n@pathClasses.push(@Checkpoint)",
			"file": "coffee/path.coffee",
			"file_size": 109934,
			"file_write_time": 130633734670000000,
			"settings":
			{
				"buffer_size": 110046,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 29 files for \"initializeAnimation\"\n\n/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/pathSources.coffee:\n  738  # 	# can be used to initialize animated path or to initialize the path on a video game\n  739  # 	initialize: ()->\n  740: # 		@initializeAnimation(@data.animate) 		# initialize the animation\n  741  # 		return\n  742  \n  ...\n  777  # 		return\n  778  \n  779: # 	# called at each frame to update the path (for animated path, @initializeAnimation must have been called)\n  780  # 	onFrame: (event)=>\n  781  # 		@path.rotation += @data.rotationSpeed 		# rotate the path by @data.rotationSpeed\n\n2 matches in 1 file\n\n\nSearching 29 files for \"initializeAnimation\"\n\n/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/pathSources.coffee:\n  738  # 	# can be used to initialize animated path or to initialize the path on a video game\n  739  # 	initialize: ()->\n  740: # 		@initializeAnimation(@data.animate) 		# initialize the animation\n  741  # 		return\n  742  \n\n1 match in 1 file\n",
			"settings":
			{
				"buffer_size": 1003,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"contents": "\nclass FaceShape extends RShape\n	@Shape = paper.Path.Rectangle\n	@rname = 'Face generator'\n	# @iconUrl = 'static/icons/inverted/spiral.png'\n	# @iconAlt = 'spiral'\n	@rdescription = \"Face generator, inspired by weird faces study by Matthias Drfelt aka mokafolio.\"\n\n	@parameters: ()->\n		parameters = super()\n\n		parameters['Parameters'] ?= {} \n		parameters['Parameters'].minRadius =\n			type: 'slider'\n			label: 'Minimum radius'\n			min: 0\n			max: 100\n			default: 0\n		parameters['Parameters'].nTurns =\n			type: 'slider'\n			label: 'Number of turns'\n			min: 1 \n			max: 50\n			default: 10\n		parameters['Parameters'].nSides =\n			type: 'slider'\n			label: 'Sides'\n			min: 3\n			max: 100\n			default: 50\n\n		return parameters\n\n	createShape: ()->\n		@headShape = @addPath(new Path.Ellipse(@rectangle.expand(-20,-10)))\n		\n		@headShape.flatten(50)\n		for segment in @headShape.segments\n			segment.point.x += Math.random()*20\n			segment.point.y += Math.random()*5\n			segment.handleIn += Math.random()*5\n			segment.handleOut += Math.random()*5\n		\n		@headShape.smooth()\n		\n		nozeShape = Math.random()\n		\n		center = @rectangle.center\n		width = @rectangle.width\n		height = @rectangle.height\n		\n		rangeRandMM = (min, max)->\n			return min + (max-min)*Math.random()\n		\n		rangeRandC = (center, amplitude)->\n			return center + amplitude*(Math.random()-0.5)\n		\n		# noze\n		if nozeShape < 0.333	# two nostrils\n			deltaX = 0.1*width + Math.random()*10\n			x = center.x - deltaX\n			y = center.y + rangeRandC(0, 5)\n			position = center.add(x, y)\n			size = new Size(Math.random()*5, Math.random()*5)\n			nozeLeft = @addPath(new Path.Ellipse(position, size))\n			position += 2*deltaX\n			size = new Size(Math.random()*5, Math.random()*5)\n			nozeRight = @addPath(new Path.Ellipse(position, size))\n		else if nozeShape < 0.666 	# noze toward left\n			noze = @addPath()\n			noze.add(center)\n			noze.add(center.add(Math.random()*15, Math.random()*5))\n			if Math.random()>0.5\n			    noze.add(center.add(Math.random()*20, Math.random()*5))\n			noze.add(center.add(0, rangeRandMM(5,10)))\n			noze.smooth()\n		else				 	# noze toward right\n			noze = @addPath()\n			noze.add(center)\n			noze.add(center.add(-Math.random()*15, Math.random()*5))\n			if Math.random()>0.5\n			    noze.add(center.add(-Math.random()*20, Math.random()*5))\n			noze.add(center.add(0, rangeRandMM(15,20)))\n			noze.smooth()\n		\n		# eyes\n		deltaX = rangeRandC(0.2*width, 0.1*width*Math.random())\n		x = center.x - deltaX\n		y = @rectangle.top + width/3 + rangeRandC(0, 10)\n		position = new Point(x, y)\n		size = new Size(Math.max(Math.random()*30,deltaX), Math.random()*30)\n		eyeLeft = @addPath(new Path.Ellipse(position, size))\n		position.x += 2*deltaX\n		\n		size.width *= 0.5+Math.random()\n		size.height *= 0.5+Math.random()\n		eyeRight = @addPath(new Path.Ellipse(position, size))\n		\n		eyeRight.position.x += rangeRandC(0, 5)\n		eyeLeft.position.x += rangeRandC(0, 5)\n		\n		for i in [1 .. eyeLeft.segments.length-1]\n			eyeLeft.segments[i].point.x += Math.random()*3\n			eyeLeft.segments[i].point.y += Math.random()*3	\n			eyeRight.segments[i].point.x += Math.random()*3\n			eyeRight.segments[i].point.y += Math.random()*3	\n        \n        # mouth\n        mouth = @addPath()\n        mouth.add()\n        \n        return\n\n",
			"settings":
			{
				"buffer_size": 3222,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/pathSources.coffee",
			"settings":
			{
				"buffer_size": 22712,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/socket.coffee",
			"settings":
			{
				"buffer_size": 7772,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/tools.coffee",
			"settings":
			{
				"buffer_size": 43190,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/views.py",
			"settings":
			{
				"buffer_size": 23344,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/run.py",
			"settings":
			{
				"buffer_size": 1240,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "#!/usr/bin/env python\n\nfrom gevent import monkey\nmonkey.patch_all()\n\nimport os\nimport sys\nfrom psycogreen.gevent import patch_psycopg\n\n\ndir = os.path.dirname(__file__)\nsys.path.insert(0, os.path.join(dir, 'Romanesco'))\n\ntry:\n    import settings\nexcept ImportError:\n    sys.stderr.write(\"Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\\nYou'll have to run django-admin.py, passing it your settings module.\\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\\n\" % __file__)\n    sys.exit(1)\n\nsys.path.insert(0, os.path.join(settings.PROJECT_ROOT, \"draw\")) # should not be necessary\n\nPORT = 8000\n\nos.environ['DJANGO_SETTINGS_MODULE'] = 'settings'\n\npatch_psycopg()\n\nfrom django.core.wsgi import get_wsgi_application\napplication = get_wsgi_application()\n\n\nif __name__ == '__main__':\n    from socketio.server import SocketIOServer\n    server = SocketIOServer(('', PORT), application, resource=\"socket.io\")\n    server.serve_forever()",
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/runserver.py",
			"file_size": -1,
			"file_write_time": -1,
			"settings":
			{
				"buffer_size": 1018,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/Users/Arthur/Projects/romanesco/Romanesco/manage.py",
			"settings":
			{
				"buffer_size": 440,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/global.coffee",
			"settings":
			{
				"buffer_size": 21765,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/coordinateSystems.coffee",
			"settings":
			{
				"buffer_size": 4253,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/utils.coffee",
			"settings":
			{
				"buffer_size": 2032,
				"line_ending": "Unix",
				"name": "utils.coffee"
			}
		},
		{
			"file": "coffee/sound.coffee",
			"settings":
			{
				"buffer_size": 3887,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/lock.coffee",
			"settings":
			{
				"buffer_size": 5276,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/main.coffee",
			"settings":
			{
				"buffer_size": 18650,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/editor.coffee",
			"settings":
			{
				"buffer_size": 14475,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/facebook.coffee",
			"settings":
			{
				"buffer_size": 3244,
				"line_ending": "Unix"
			}
		},
		{
			"file": "coffee/options.coffee",
			"settings":
			{
				"buffer_size": 24143,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 392.0,
		"selected_items":
		[
			[
				"glo",
				"View: Toggle Open Files in Side Bar"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"tool",
				"View: Toggle Open Files in Side Bar"
			],
			[
				"instl",
				"Package Control: Install Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/div.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/ajax.py",
		"/Users/Arthur/Libraries/web/bootstrap-colorpickersliders/index.html",
		"/Users/Arthur/Library/Application Support/Sublime Text 3/Packages/User/Default (OSX).sublime-keymap",
		"/Users/Arthur/Library/Application Support/Sublime Text 3/Packages/Default/Default (OSX).sublime-keymap",
		"/Users/Arthur/Library/Application Support/Sublime Text 3/Packages/Default/Preferences.sublime-settings",
		"/Users/Arthur/Projects/romanesco/.gitignore",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/styles.css",
		"/Users/Arthur/Projects/digitalocean/romanesco/opt/romanesco/Romanesco/Romanesco/settings.py",
		"/Users/Arthur/Projects/romanesco/Romanesco/Romanesco/settings.py",
		"/Users/Arthur/Projects/digitalocean/romanesco/opt/romanesco/Romanesco/run.py",
		"/Users/Arthur/Projects/digitalocean/romanesco/opt/romanesco/Romanesco/runserver.py",
		"/Users/Arthur/Projects/digitalocean/romanesco/opt/help.txt",
		"/Users/Arthur/Projects/digitalocean/romanesco/opt/romanesco/Romanesco/manage.py",
		"/Users/Arthur/Projects/digitalocean/romanesco/opt/romanesco/gunicorn_config.py",
		"/Users/Arthur/Projects/digitalocean/romanesco/etc/nginx/nginx.conf",
		"/Users/Arthur/Projects/digitalocean/romanesco/etc/nginx/sites-available/romanesco",
		"/Users/Arthur/Projects/digitalocean/romanesco/etc/nginx/site-available/romanesco",
		"/Users/Arthur/Projects/romanesco/Romanesco/socketio_runserver/management/commands/socketio_runserver.py",
		"/Users/Arthur/Libraries/web/Turbulenz/turbulenz_engine/test2.html",
		"/Users/Arthur/Libraries/web/decode-audio-data-gh-pages/index.html",
		"/Users/Arthur/Projects/Evolution/evolution-server/coffee/index.coffee",
		"/Users/Arthur/Projects/Evolution/evolution-server/coffee/EvolutionCommons.coffee",
		"/Users/Arthur/Projects/Evolution/evolution-server/coffee/evolutionController.coffee",
		"/Users/Arthur/Projects/digitalocean/romanesco/opt/romanescoBckp/gunicorn_config.py",
		"/Users/Arthur/Projects/digitalocean/romanesco/opt/romanesco/Romanesco/Romanesco/urls.py",
		"/Users/Arthur/Projects/digitalocean/romanesco/opt/gunicorn_config.py",
		"/Users/Arthur/Projects/digitalocean/romanesco/etc/opt/help.txt",
		"/Users/Arthur/Projects/digitalocean/romanesco/etc/nginx/sites-available/Find help to work with nginx, unicorn and django h",
		"/Users/Arthur/Projects/digitalocean/romanesco/etc/nginx/sites-available/default",
		"/Users/Arthur/Projects/secret_key.txt",
		"/Users/Arthur/Projects/romanesco/Romanesco/Romanesco/urls.py",
		"/Users/Arthur/Projects/euphony-mapping/lib/MIDI.js/MIDI.Player.js",
		"/Users/Arthur/Libraries/web/euphony-master/lib/MIDI.js/MIDI.Player.js",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/templates/socialaccount/signup.html",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/templates/account/login.html",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/templates/socialaccount/snippets/login_extra.html",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/templates/socialaccount/connections.html",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/account/email_confirm.html",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/templates/base.html",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/pathSources.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/socket.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/tools.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/coordinateSystems.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/views.py",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/global.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/lock.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/main.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/less/styles.less",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/templates/openid/login.html",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/templates/openid/base.html",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/templates/socialaccount/base.html",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/account/signup.html",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/account/base.html",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/account/login.html",
		"/Users/Arthur/Libraries/web/bootstrap-3.2.0/docs/examples/signin/index.html",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/load.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/icons/logo.svg",
		"/Users/Arthur/Libraries/Turbulenz/SDK/0.28.0/samples/jslib/draw2d.js",
		"/Users/Arthur/Libraries/Turbulenz/SDK/0.28.0/samples/jslib/canvas.js",
		"/Users/Arthur/Libraries/Turbulenz/SDK/0.28.0/samples/2dcanvas.canvas.js",
		"/Users/Arthur/Libraries/Turbulenz/SDK/0.28.0/samples/2dcanvas.canvas.release.html",
		"/Users/Arthur/Libraries/Turbulenz/SDK/0.28.0/samples/draw2d.canvas.release.html",
		"/Users/Arthur/Libraries/Turbulenz/SDK/0.28.0/samples/physics_benchmark.canvas.release.html",
		"/Users/Arthur/Libraries/web/MIDI.js/build/MIDI.js",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/utils.py",
		"/Users/Arthur/Libraries/web/bootstrap-3.2.0/docs/examples/signin/signin.css",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/account/loginBckp.html",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/static/css/styles.css",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/static/styles.css",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/styles.css",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/static/css/style.css",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/accountBckp/base.html",
		"/Users/Arthur/Libraries/web/Turbulenz/turbulenz_engine/test1.html",
		"/Users/Arthur/Libraries/web/Turbulenz/turbulenz_engine/deps.yaml",
		"/Users/Arthur/Libraries/web/turbulenz_engine/tools/Makefile",
		"/Users/Arthur/Libraries/web/turbulenz_engine/manage.py",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/js/main.js",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/allauth/urls.py",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/less/flexbox.less",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/libs/ZeroClipboard/ZeroClipboard.min.js",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/libs/ZeroClipboard.min.js",
		"/Users/Arthur/Projects/project-curry/.gitmodules",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/transformBox.paper",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/transformBox2.paper",
		"/Users/Arthur/Library/Application Support/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/item.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/ajax.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/options.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/index.html",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/models.py",
		"/Users/Arthur/Projects/romanesco/Romanesco/draw/sockets.py",
		"/Users/Arthur/Projects/reflect/reflect/run.py",
		"/Applications/Sublime Text.app/Contents/MacOS/changelog.txt",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/romanesco.sublime-workspace",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/coffee/path.coffee",
		"/Users/Arthur/Libraries/web/Harmony/Harmony.html",
		"/Users/Arthur/Libraries/web/harmony.js",
		"/Users/Arthur/Libraries/web/Harmony/Harmony_files/ga.js",
		"/Users/Arthur/Projects/reflect/reflect/static/coffee/app.coffee",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/css/styles.css",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/libs/paper/paper-full.js",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/libs/paper/paper-fullOld.js",
		"/Users/Arthur/Projects/reflect/reflect/graph/sockets.py",
		"/Users/Arthur/Projects/romanesco/lib/python2.7/site-packages/socketio/namespace.py",
		"/Users/Arthur/Projects/reflect/reflect/reflect/settings.py",
		"/Users/Arthur/Projects/reflect/reflect/graph/views.py",
		"/Users/Arthur/Projects/reflect/reflect/static/reflect.sublime-workspace",
		"/Users/Arthur/Projects/of_v0.8.4_osx_release/apps/LaSophisteApps/Ondes/bin/data/shaders/sines2.frag",
		"/Users/Arthur/Projects/of_v0.8.4_osx_release/apps/LaSophisteApps/Ondes/bin/data/shaders/sines3.frag",
		"/Users/Arthur/Projects/of_v0.8.4_osx_release/apps/LaSophisteApps/Ondes/bin/data/shaders/sines4.frag",
		"/Users/Arthur/Projects/of_v0.8.4_osx_release/apps/LaSophisteApps/Ondes/bin/data/shaders/sines1.frag",
		"/Users/Arthur/Projects/particles/coffee/main 3.coffee",
		"/Users/Arthur/Projects/of_v0.8.3_osx_release/apps7.4/La Sophiste Apps/GraFX/bin/data/scripts/midiGraphX.lua",
		"/Users/Arthur/Projects/particles/coffee/main 2.coffee",
		"/Users/Arthur/Projects/of_v0.8.3_osx_release/apps7.4/La Sophiste Apps/GraFX/bin/data/scripts/midiExample.lua",
		"/Users/Arthur/Projects/particles/index.html",
		"/Users/Arthur/Projects/reflect/reflect/manage.py",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/libs/dat.gui.js",
		"/Users/Arthur/Projects/romanesco/Romanesco/static/styles.less",
		"/Users/Arthur/Projects/reflect/reflect/static/coffee/global.coffee",
		"/Users/Arthur/Libraries/web/bootstrap-3.2.0/docs/examples/cover/index.html",
		"/Users/Arthur/Libraries/web/index.html",
		"/Users/Arthur/Libraries/web/bootstrap-3.2.0/docs/examples/blog/index.html",
		"/Users/Arthur/Libraries/web/bg-splitter-master/index.html",
		"/Users/Arthur/Libraries/web/bg-splitter-master/css/style.css",
		"/Users/Arthur/Libraries/web/bg-splitter-master/css/splitter.css",
		"/Users/Arthur/Libraries/web/ui-layout-master/demo/index.html"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
			"",
			"div.coffee",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"setCss",
			"Tool",
			"@data.",
			"initializeAnimation",
			"@pk",
			"parameters:",
			"url-group",
			"url",
			"onhashc\nonhashchange",
			"onhashc",
			"windowonhashc",
			"window.onhashc",
			"defferedExecution",
			"favoriteTools",
			"hasClass(\"dg-sidebar\"",
			"$(g.gui.domElement).parent().hasClass(\"dg-sidebar\"",
			"tiny",
			"colorpicker",
			"@iconUrl = '",
			"@iconUrl = '/static/",
			"[]",
			"@data.smooth",
			"#codeEditor button",
			"add a path to the drawing group",
			"dg-right",
			"dg.a",
			"parentJ",
			"15px",
			"roller",
			"rolle",
			"dat-gui",
			".sidebar",
			"dat.gui",
			"z-index",
			"s-index",
			"\n// .container-fluid, #stage {\n// 	div.item {\n// 		z-index: 1001;\n// 	}\n// }",
			"#dat",
			"rollerpath",
			"dat-gui",
			"g.gui",
			"gui",
			"dat",
			"transform-origin, 0% 0% 0",
			"dat",
			"drawUpdate(",
			"initializeDrawing:",
			"http://",
			"127",
			"projectToRaster",
			"createCanvas",
			"createCanvaz",
			"For example",
			"return",
			"  ",
			"updateBackgroundMode",
			"setPopover",
			"updateGame",
			"update",
			"controlPath",
			"updateBackgroundMode",
			"common",
			"respons",
			"all RIte",
			"posBeforeScale",
			"zoom(",
			"zoom",
			"custom-",
			"Paper ",
			"save_callback(",
			"website",
			"box",
			"RLink",
			"save(",
			"@object_type = ",
			"@object_type",
			"object_type",
			"overrid",
			"override",
			"overload",
			"overload {",
			"overload",
			"replace",
			"overload",
			"selectionRectangleScale",
			"checkUpdateDrawing",
			"checkUpdateBrush",
			"polygon mode",
			"@smooth",
			"intersects",
			"event",
			"checkUpdateBrush",
			"checkUpdatBrush",
			"successfull",
			"successful",
			"successfuly",
			"successfull",
			"projectToPlanet",
			"cap",
			"capital",
			"words",
			"separate words",
			"separate",
			"navigate",
			"initializeDrawing",
			"/)\n",
			"hitTestAndInitSelection",
			"rasterize",
			"there are not",
			"selectionRec",
			"prepareHitTest",
			"pathWidth",
			"rValue",
			"loadFonts",
			"g.usedFonts",
			"rFunction",
			"update",
			"@param",
			"[{",
			"@param",
			"@param ",
			"# This is a poor and dirty implementation",
			"@param",
			"@param[{",
			"@param [ {",
			"@param [{",
			"@param [",
			"@param [{",
			"updateParameters"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": true,
		"regex": false,
		"replace_history":
		[
			"checkUpdateDrawing",
			"successfully",
			"successful",
			"objectToEvent",
			"eventToObject",
			"/images/icons/inverted",
			"images/cursors/hand",
			"inverted",
			"images/icons/",
			"offset",
			"return",
			"# return simplejson.dumps(",
			"# return simplejson.dumps( { ",
			"#@dajaxice_register\n@ajax",
			"@currentCheckpoint",
			"loadingBarJ",
			"loadingContainerJ",
			"rname",
			"rDivModal",
			"divModal",
			"'Move'",
			"event = g.snap",
			"->",
			"@drawing",
			".getBounds()",
			"xMax",
			"yMax",
			"xMin",
			"yMin",
			"yMax",
			"xMax",
			"yMin",
			"xMin",
			"getBounds()",
			"@getBounds()",
			"delete g.currentPaths[from]",
			"delete g.currentPaths[g.me]",
			"CodeTool",
			"pushRequestBtnJ",
			"typeaheadFontEngine",
			"@hover-blue",
			"@sidebar-dark-background-color",
			"@hover-purple",
			"@sidebar-background-color",
			"romanesco-ui",
			"messageBoxJ",
			"group",
			"[]",
			"handleGroup",
			"handle",
			"updateSpeed",
			"simplified",
			"simplify:",
			"drawEnd",
			"drawUpdate",
			"drawBegin",
			"initializeDrawing",
			"initDraw",
			"draw",
			"event",
			"point = event.point",
			"parameterChanged",
			"loadPath",
			"point, event, ",
			"",
			"(point, event)",
			"compoundPath",
			"shape",
			"PrecisePath",
			"@smoothPoint",
			"'Move'",
			"point",
			"chatRoom",
			"chatRoomJ",
			"super(@date, @data, @pk, points)",
			"constructor: (@date=null, @data=null, @pk=null, points=null)",
			"constructor: (@date=null, @data=null, @pk=null)",
			"'input'",
			"initModal",
			"@controlPath.strokeWidth = 0",
			"@controlPath.strokeWidth = if not @controlPath.selected then 0 else 5 ",
			"save",
			"boxFromRectangle",
			"super()",
			"data",
			"g.checkError",
			"event.point.y",
			"event.point.x",
			"@dragOffset",
			"@draggedHandleJ",
			"userAction",
			"from==g.me",
			"g.items",
			"g.currentPaths[from]",
			"updateTransform",
			"b",
			"r",
			"t",
			"l",
			"b",
			"r",
			"t",
			"l",
			"viewBounds",
			"view",
			"@data",
			"@data.strokeWidth",
			"@data.strokeColor",
			"@data.fillColor",
			"cursorName",
			"static 'icons/inversed/",
			"static 'icons/",
			"static 'icons/inversed/",
			"', '",
			", ",
			"",
			"g.socket",
			"organization",
			"branch.relativePos.x",
			"branch.relativePos.y",
			"updateBranches",
			"update",
			"columnNumber",
			"proposition",
			"",
			":"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 15,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/templates/index.html",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 39829,
						"regions":
						{
						},
						"selection":
						[
							[
								22269,
								22269
							]
						],
						"settings":
						{
							"syntax": "Packages/HTML/HTML.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7111.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/urls.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 684,
						"regions":
						{
						},
						"selection":
						[
							[
								202,
								202
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 27,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/Romanesco/urls.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 921,
						"regions":
						{
						},
						"selection":
						[
							[
								550,
								550
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 26,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "less/styles.less",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 23026,
						"regions":
						{
						},
						"selection":
						[
							[
								15574,
								15574
							]
						],
						"settings":
						{
							"syntax": "Packages/LESS/LESS.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 13665.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "less/flexbox.less",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3460,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/LESS/LESS.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/ajax.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17945,
						"regions":
						{
						},
						"selection":
						[
							[
								720,
								720
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "coffee/ajax.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 17868,
						"regions":
						{
						},
						"selection":
						[
							[
								21,
								21
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/sockets.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11068,
						"regions":
						{
						},
						"selection":
						[
							[
								2484,
								2484
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 22,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/models.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4566,
						"regions":
						{
						},
						"selection":
						[
							[
								3735,
								3739
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1412.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/Romanesco/settings.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8109,
						"regions":
						{
						},
						"selection":
						[
							[
								8068,
								8068
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "coffee/path.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 110046,
						"regions":
						{
						},
						"selection":
						[
							[
								27596,
								27601
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 8671.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 11,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1003,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										256,
										275
									],
									[
										451,
										470
									],
									[
										894,
										913
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								912,
								912
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 2,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 255.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 12,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3222,
						"regions":
						{
						},
						"selection":
						[
							[
								709,
								709
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 553.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "coffee/pathSources.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 22712,
						"regions":
						{
						},
						"selection":
						[
							[
								18854,
								18854
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 10294.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "coffee/socket.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7772,
						"regions":
						{
						},
						"selection":
						[
							[
								235,
								235
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 20,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "coffee/tools.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 43190,
						"regions":
						{
						},
						"selection":
						[
							[
								32805,
								32833
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/draw/views.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 23344,
						"regions":
						{
						},
						"selection":
						[
							[
								239,
								239
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 21,
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/run.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1240,
						"regions":
						{
						},
						"selection":
						[
							[
								375,
								375
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 24,
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/runserver.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1018,
						"regions":
						{
						},
						"selection":
						[
							[
								580,
								580
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "/Users/Arthur/Projects/romanesco/Romanesco/manage.py",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 440,
						"regions":
						{
						},
						"selection":
						[
							[
								322,
								330
							]
						],
						"settings":
						{
							"syntax": "Packages/Python/Python.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 25,
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "coffee/global.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 21765,
						"regions":
						{
						},
						"selection":
						[
							[
								14912,
								14912
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 7131.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "coffee/coordinateSystems.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4253,
						"regions":
						{
						},
						"selection":
						[
							[
								1089,
								1089
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "coffee/utils.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2032,
						"regions":
						{
						},
						"selection":
						[
							[
								1534,
								1534
							]
						],
						"settings":
						{
							"auto_name": "utils.coffee",
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 23,
					"file": "coffee/sound.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3887,
						"regions":
						{
						},
						"selection":
						[
							[
								1794,
								1794
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 19,
					"type": "text"
				},
				{
					"buffer": 24,
					"file": "coffee/lock.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5276,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 28,
					"type": "text"
				},
				{
					"buffer": 25,
					"file": "coffee/main.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 18650,
						"regions":
						{
						},
						"selection":
						[
							[
								13224,
								13224
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4874.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 26,
					"file": "coffee/editor.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14475,
						"regions":
						{
						},
						"selection":
						[
							[
								780,
								780
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 27,
					"file": "coffee/facebook.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3244,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 23,
					"type": "text"
				},
				{
					"buffer": 28,
					"file": "coffee/options.coffee",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24143,
						"regions":
						{
						},
						"selection":
						[
							[
								20596,
								20596
							]
						],
						"settings":
						{
							"syntax": "Packages/Better CoffeeScript/CoffeeScript.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 8625.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 34.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 100.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"project": "romanesco.sublime-project",
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
			[
				"div",
				"~/Projects/romanesco/Romanesco/static/coffee/div.coffee"
			],
			[
				"tools",
				"~/Projects/romanesco/Romanesco/static/coffee/tools.coffee"
			],
			[
				"",
				"~/Projects/romanesco/Romanesco/draw/ajax.py"
			],
			[
				"mod",
				"~/Projects/romanesco/Romanesco/draw/models.py"
			],
			[
				"aja",
				"~/Projects/romanesco/Romanesco/draw/ajax.py"
			],
			[
				"pa",
				"~/Projects/romanesco/Romanesco/static/coffee/path.coffee"
			],
			[
				"source",
				"~/Projects/romanesco/Romanesco/static/coffee/pathSources.coffee"
			],
			[
				"path",
				"~/Projects/romanesco/Romanesco/static/coffee/path.coffee"
			],
			[
				"tool",
				"~/Projects/romanesco/Romanesco/static/coffee/tools.coffee"
			],
			[
				"s",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"in",
				"~/Projects/romanesco/Romanesco/draw/templates/index.html"
			],
			[
				"inde",
				"~/Projects/romanesco/Romanesco/draw/templates/index.html"
			],
			[
				"sty",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"glo",
				"~/Projects/romanesco/Romanesco/static/coffee/global.coffee"
			],
			[
				"main",
				"~/Projects/romanesco/Romanesco/static/coffee/main.coffee"
			],
			[
				"ind",
				"~/Projects/romanesco/Romanesco/draw/templates/index.html"
			],
			[
				"gl",
				"~/Projects/romanesco/Romanesco/static/coffee/global.coffee"
			],
			[
				"index",
				"~/Projects/romanesco/Romanesco/draw/templates/index.html"
			],
			[
				"too",
				"~/Projects/romanesco/Romanesco/static/coffee/tools.coffee"
			],
			[
				"otp",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			],
			[
				"pat",
				"~/Projects/romanesco/Romanesco/static/coffee/path.coffee"
			],
			[
				"st",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"op",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			],
			[
				"ut",
				"~/Projects/romanesco/Romanesco/static/coffee/utils.coffee"
			],
			[
				"ma",
				"~/Projects/romanesco/Romanesco/static/coffee/main.coffee"
			],
			[
				"styl",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"opt",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			],
			[
				"mai",
				"~/Projects/romanesco/Romanesco/static/coffee/main.coffee"
			],
			[
				"nd",
				"~/Projects/romanesco/Romanesco/draw/templates/index.html"
			],
			[
				"pathso",
				"~/Projects/romanesco/Romanesco/static/coffee/pathSources.coffee"
			],
			[
				"edi",
				"~/Projects/romanesco/Romanesco/static/coffee/editor.coffee"
			],
			[
				"sou",
				"~/Projects/romanesco/Romanesco/static/coffee/pathSources.coffee"
			],
			[
				"di",
				"~/Projects/romanesco/Romanesco/static/coffee/div.coffee"
			],
			[
				"index.ht",
				"~/Projects/romanesco/Romanesco/draw/templates/index.html"
			],
			[
				"index.h",
				"~/Projects/romanesco/Romanesco/draw/templates/index.html"
			],
			[
				"style",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"index.",
				"~/Projects/romanesco/Romanesco/draw/templates/index.html"
			],
			[
				"ed",
				"~/Projects/romanesco/Romanesco/static/coffee/editor.coffee"
			],
			[
				"code",
				"~/Projects/romanesco/Romanesco/static/coffee/editor.coffee"
			],
			[
				"tol",
				"~/Projects/romanesco/Romanesco/static/coffee/tools.coffee"
			],
			[
				"edit",
				"~/Projects/romanesco/Romanesco/static/coffee/editor.coffee"
			],
			[
				"opti",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			],
			[
				"sound",
				"~/Projects/romanesco/Romanesco/static/coffee/sound.coffee"
			],
			[
				"aj",
				"~/Projects/romanesco/Romanesco/draw/ajax.py"
			],
			[
				"model",
				"~/Projects/romanesco/Romanesco/draw/models.py"
			],
			[
				"ajax",
				"~/Projects/romanesco/Romanesco/draw/ajax.py"
			],
			[
				"coor",
				"~/Projects/romanesco/Romanesco/static/coffee/coordinateSystems.coffee"
			],
			[
				"socke",
				"~/Projects/romanesco/Romanesco/static/coffee/socket.coffee"
			],
			[
				"aa",
				"~/Projects/romanesco/Romanesco/static/coffee/ajax.coffee"
			],
			[
				"sock",
				"~/Projects/romanesco/Romanesco/static/coffee/socket.coffee"
			],
			[
				"globa",
				"~/Projects/romanesco/Romanesco/static/coffee/global.coffee"
			],
			[
				"socket",
				"~/Projects/romanesco/Romanesco/static/coffee/socket.coffee"
			],
			[
				"fac",
				"~/Projects/romanesco/Romanesco/static/coffee/facebook.coffee"
			],
			[
				"coo",
				"~/Projects/romanesco/Romanesco/static/coffee/coordinateSystems.coffee"
			],
			[
				"utils",
				"~/Projects/romanesco/Romanesco/static/coffee/utils.coffee"
			],
			[
				"pah",
				"~/Projects/romanesco/Romanesco/static/coffee/path.coffee"
			],
			[
				"global",
				"~/Projects/romanesco/Romanesco/static/coffee/global.coffee"
			],
			[
				"edito",
				"~/Projects/romanesco/Romanesco/static/coffee/editor.coffee"
			],
			[
				"co",
				"~/Projects/romanesco/Romanesco/static/coffee/coordinateSystems.coffee"
			],
			[
				"util",
				"~/Projects/romanesco/Romanesco/static/coffee/utils.coffee"
			],
			[
				"gloa",
				"~/Projects/romanesco/Romanesco/static/coffee/global.coffee"
			],
			[
				"facb",
				"~/Projects/romanesco/Romanesco/static/coffee/facebook.coffee"
			],
			[
				"item",
				"~/Projects/romanesco/Romanesco/static/coffee/coordinateSystems.coffee"
			],
			[
				"glob",
				"~/Projects/romanesco/Romanesco/static/coffee/global.coffee"
			],
			[
				"settings",
				"~/Projects/romanesco/Romanesco/Romanesco/settings.py"
			],
			[
				"sett",
				"~/Projects/romanesco/Romanesco/Romanesco/settings.py"
			],
			[
				"run",
				"~/Projects/romanesco/Romanesco/run.py"
			],
			[
				"view",
				"~/Projects/romanesco/Romanesco/draw/views.py"
			],
			[
				"url",
				"~/Projects/romanesco/Romanesco/draw/urls.py"
			],
			[
				"setting",
				"~/Projects/romanesco/Romanesco/Romanesco/settings.py"
			],
			[
				"guni",
				"~/Projects/digitalocean/romanesco/opt/romanesco/gunicorn_config.py"
			],
			[
				"setti",
				"~/Projects/romanesco/Romanesco/Romanesco/settings.py"
			],
			[
				"mana",
				"~/Projects/romanesco/Romanesco/manage.py"
			],
			[
				"set",
				"~/Projects/romanesco/Romanesco/Romanesco/settings.py"
			],
			[
				"settin",
				"~/Projects/romanesco/Romanesco/Romanesco/settings.py"
			],
			[
				"so",
				"~/Projects/romanesco/Romanesco/draw/sockets.py"
			],
			[
				"soc",
				"~/Projects/romanesco/Romanesco/draw/sockets.py"
			],
			[
				"sourc",
				"~/Projects/romanesco/Romanesco/static/coffee/pathSources.coffee"
			],
			[
				"mode",
				"~/Projects/romanesco/Romanesco/draw/models.py"
			],
			[
				"models",
				"~/Projects/romanesco/Romanesco/draw/models.py"
			],
			[
				"vie",
				"~/Projects/romanesco/Romanesco/draw/views.py"
			],
			[
				"ett",
				"~/Projects/romanesco/Romanesco/Romanesco/settings.py"
			],
			[
				"a",
				"~/Projects/romanesco/Romanesco/draw/ajax.py"
			],
			[
				"dov",
				"~/Projects/romanesco/Romanesco/static/coffee/div.coffee"
			],
			[
				"styles",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"mo",
				"~/Projects/romanesco/Romanesco/draw/models.py"
			],
			[
				"tols",
				"~/Projects/romanesco/Romanesco/static/coffee/tools.coffee"
			],
			[
				"glba",
				"~/Projects/romanesco/Romanesco/static/coffee/global.coffee"
			],
			[
				"patj",
				"~/Projects/romanesco/Romanesco/static/coffee/ajax.coffee"
			],
			[
				"amin",
				"~/Projects/romanesco/Romanesco/static/coffee/main.coffee"
			],
			[
				"gloab",
				"~/Projects/romanesco/Romanesco/static/coffee/global.coffee"
			],
			[
				"d",
				"~/Projects/romanesco/Romanesco/static/coffee/div.coffee"
			],
			[
				"optio",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			],
			[
				"vei",
				"~/Projects/romanesco/Romanesco/draw/views.py"
			],
			[
				"maion",
				"~/Projects/romanesco/Romanesco/static/coffee/main.coffee"
			],
			[
				"se",
				"~/Projects/romanesco/Romanesco/Romanesco/settings.py"
			],
			[
				"fa",
				"~/Projects/romanesco/Romanesco/static/coffee/facebook.coffee"
			],
			[
				"tooo",
				"~/Projects/romanesco/Romanesco/static/coffee/tools.coffee"
			],
			[
				"corr",
				"~/Projects/romanesco/Romanesco/draw/models.py"
			],
			[
				"to",
				"~/Projects/romanesco/Romanesco/static/coffee/tools.coffee"
			],
			[
				"option",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			],
			[
				"min",
				"~/Projects/romanesco/Romanesco/static/coffee/main.coffee"
			],
			[
				"ine",
				"~/Projects/romanesco/Romanesco/draw/templates/index.html"
			],
			[
				"dv",
				"~/Projects/romanesco/Romanesco/static/coffee/div.coffee"
			],
			[
				"opto",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			],
			[
				"toools",
				"~/Projects/romanesco/Romanesco/static/coffee/tools.coffee"
			],
			[
				"pta",
				"~/Projects/romanesco/Romanesco/static/coffee/path.coffee"
			],
			[
				"py",
				"~/Projects/romanesco/Romanesco/draw/ajax.py"
			],
			[
				"fiv",
				"~/Projects/romanesco/Romanesco/static/coffee/div.coffee"
			],
			[
				"lo",
				"~/Projects/romanesco/Romanesco/static/coffee/lock.coffee"
			],
			[
				"ajaxp",
				"~/Projects/romanesco/Romanesco/draw/ajax.py"
			],
			[
				"m",
				"~/Projects/romanesco/Romanesco/draw/models.py"
			],
			[
				"ajax.",
				"~/Projects/romanesco/Romanesco/draw/ajax.py"
			],
			[
				"sour",
				"~/Projects/romanesco/Romanesco/static/coffee/pathSources.coffee"
			],
			[
				"man",
				"~/Projects/romanesco/Romanesco/static/coffee/main.coffee"
			],
			[
				"mi",
				"~/Projects/romanesco/Romanesco/static/coffee/main.coffee"
			],
			[
				"stl",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"p",
				"~/Projects/romanesco/Romanesco/draw/ajax.py"
			],
			[
				"less",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"les",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"t",
				"~/Projects/romanesco/Romanesco/static/coffee/tools.coffee"
			],
			[
				"maio",
				"~/Projects/romanesco/Romanesco/static/coffee/main.coffee"
			],
			[
				"tyl",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"options",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			],
			[
				"otio",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			],
			[
				"l",
				"~/Projects/romanesco/Romanesco/static/less/styles.less"
			],
			[
				"socek",
				"~/Projects/romanesco/Romanesco/static/coffee/socket.coffee"
			],
			[
				"otpin",
				"~/Projects/romanesco/Romanesco/static/coffee/options.coffee"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 392.0,
		"selected_items":
		[
		],
		"width": 392.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": false,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
